[
  {
    "title": "12.2 Depth First Search",
    "description": "# 12.2 Depth First Search\n\nDepth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array. A graph can have more than one DFS traversal.\nFor a given graph G, print DFS traversal from a given source vertex.\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n4 3\n0 1\n0 2\n0 3\n0\n\nOutput:\n0 1 2 3\n```\n\n### Example 2:\n\n```\nInput:\n5 4\n0 1\n0 2\n0 3\n2 4\n0\n\nOutput:\n0 1 2 3 4\n```\n\n### Example 3:\n\n```\nInput:\n6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0\n\nOutput:\n0 1 3 4 2 5\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "4 3\n0 1\n0 2\n0 3\n0",
        "expected_output": "0 1 2 3",
        "is_visible": true
      },
      {
        "input": "5 4\n0 1\n0 2\n0 3\n2 4\n0",
        "expected_output": "0 1 2 3 4",
        "is_visible": true
      },
      {
        "input": "6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0",
        "expected_output": "0 1 3 4 2 5",
        "is_visible": true
      },
      {
        "input": "7 6\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n0",
        "expected_output": "0 1 3 4 2 5 6",
        "is_visible": true
      },
      {
        "input": "8 7\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n0",
        "expected_output": "0 1 3 6 4 7 2 5",
        "is_visible": true
      },
      {
        "input": "10 9\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n0",
        "expected_output": "0 1 3 6 9 4 7 2 5 8",
        "is_visible": false
      },
      {
        "input": "12 11\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n0",
        "expected_output": "0 1 3 6 9 4 7 10 2 5 8 11",
        "is_visible": false
      },
      {
        "input": "15 14\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n0",
        "expected_output": "0 1 3 6 9 12 4 7 10 13 2 5 8 11 14",
        "is_visible": false
      },
      {
        "input": "20 19\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n0",
        "expected_output": "0 1 3 6 9 12 15 18 4 7 10 13 16 19 2 5 8 11 14 17",
        "is_visible": false
      },
      {
        "input": "25 24\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n0",
        "expected_output": "0 1 3 6 9 12 15 18 21 24 4 7 10 13 16 19 22 2 5 8 11 14 17 20 23",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int E = sc.nextInt();\n            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < V; i++) adj.add(new ArrayList<>());\n            for (int i = 0; i < E; i++) {\n                int u = sc.nextInt();\n                int v = sc.nextInt();\n                adj.get(u).add(v);\n            }\n            int source = sc.hasNextInt() ? sc.nextInt() : 0;\n            ArrayList<Integer> result = dfs(V, adj, source);\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i) + (i < result.size() - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static ArrayList<Integer> dfs(int V, ArrayList<ArrayList<Integer>> adj, int source) {\n        // Write your code here...\n        return new ArrayList<>();\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "12.3 Best First Search (Informed Search)",
    "description": "# 12.3 Best First Search (Informed Search)\n\nThe idea of Best First Search is to use an evaluation function to decide which adjacent is most promising and then explore. Best First Search falls under the category of Heuristic Search or Informed Search.\nImplementation of Best First Search:\nWe use a priority queue or heap to store the costs of nodes that have the lowest evaluation function value. So the implementation is a variation of BFS, we just need to change Queue to PriorityQueue.\nAlgorithm:\nBest-First-Search(Graph g, Node start)\n1) Create an empty PriorityQueue\n   PriorityQueue pq;\n2) Insert \"start\" in pq.\n   pq.insert(start)\n3) Until PriorityQueue is empty\n   u = PriorityQueue.DeleteMin\n   If u is the goal\n    Exit\n   Else\n    Foreach neighbor v of u\n    If v \"Unvisited\"\n    Mark v \"Visited\"\n    pq.insert(v)\n    Mark u \"Examined\"\nEnd procedure\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n5 6\n0 1 4\n0 2 2\n1 3 5\n1 4 12\n2 3 2\n3 4 3\n0 4\n\nOutput:\n0 2 3 4\n```\n\n### Example 2:\n\n```\nInput:\n6 8\n0 1 7\n0 2 9\n0 5 14\n1 2 10\n1 3 15\n2 3 11\n2 5 2\n3 4 6\n0 4\n\nOutput:\n0 2 5 3 4\n```\n\n### Example 3:\n\n```\nInput:\n7 10\n0 1 4\n0 2 3\n1 3 2\n1 4 5\n2 3 1\n2 5 6\n3 4 7\n3 5 4\n4 6 3\n5 6 2\n0 6\n\nOutput:\n0 2 3 1 4 6\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "5 6\n0 1 4\n0 2 2\n1 3 5\n1 4 12\n2 3 2\n3 4 3\n0 4",
        "expected_output": "0 2 3 4",
        "is_visible": true
      },
      {
        "input": "6 8\n0 1 7\n0 2 9\n0 5 14\n1 2 10\n1 3 15\n2 3 11\n2 5 2\n3 4 6\n0 4",
        "expected_output": "0 2 5 3 4",
        "is_visible": true
      },
      {
        "input": "7 10\n0 1 4\n0 2 3\n1 3 2\n1 4 5\n2 3 1\n2 5 6\n3 4 7\n3 5 4\n4 6 3\n5 6 2\n0 6",
        "expected_output": "0 2 3 1 4 6",
        "is_visible": true
      },
      {
        "input": "8 12\n0 1 3\n0 2 6\n0 3 2\n1 4 4\n2 4 5\n2 5 8\n3 5 9\n4 6 7\n4 7 5\n5 6 3\n5 7 4\n6 7 2\n0 7",
        "expected_output": "0 1 4 7",
        "is_visible": true
      },
      {
        "input": "10 15\n0 1 2\n0 2 4\n0 3 3\n1 4 7\n2 4 5\n2 5 6\n3 5 8\n4 6 4\n4 7 5\n5 7 3\n5 8 6\n6 9 2\n7 9 4\n7 8 5\n8 9 3\n0 9",
        "expected_output": "0 1 4 6 9",
        "is_visible": true
      },
      {
        "input": "12 20\n0 1 4\n0 2 3\n0 3 5\n1 4 6\n2 4 7\n2 5 8\n3 5 9\n4 6 2\n4 7 5\n5 7 4\n5 8 6\n6 9 3\n6 10 7\n7 9 5\n7 10 8\n8 10 9\n8 11 6\n9 11 4\n10 11 5\n0 11",
        "expected_output": "0 2 4 6 9 11",
        "is_visible": false
      },
      {
        "input": "15 25\n0 1 2\n0 2 4\n0 3 3\n1 4 5\n2 4 6\n2 5 7\n3 5 8\n4 6 9\n4 7 4\n5 7 5\n5 8 6\n6 9 3\n6 10 7\n7 9 5\n7 10 8\n8 10 9\n8 11 6\n9 12 4\n9 13 5\n10 13 6\n10 14 7\n11 14 8\n12 14 9\n13 14 3\n0 14",
        "expected_output": "0 1 4 7 9 12 14",
        "is_visible": false
      },
      {
        "input": "20 30\n0 1 3\n0 2 5\n0 3 4\n1 4 6\n2 4 7\n2 5 8\n3 5 9\n4 6 10\n4 7 5\n5 7 6\n5 8 7\n6 9 8\n6 10 9\n7 9 10\n7 10 11\n8 10 12\n8 11 13\n9 12 14\n9 13 15\n10 13 16\n10 14 17\n11 14 18\n12 15 19\n12 16 20\n13 16 21\n13 17 22\n14 17 23\n14 18 24\n15 19 25\n16 19 26\n0 19",
        "expected_output": "0 1 4 7 9 12 15 19",
        "is_visible": false
      },
      {
        "input": "25 40\n0 1 4\n0 2 5\n0 3 6\n1 4 7\n2 4 8\n2 5 9\n3 5 10\n4 6 11\n4 7 12\n5 7 13\n5 8 14\n6 9 15\n6 10 16\n7 10 17\n7 11 18\n8 11 19\n8 12 20\n9 13 21\n9 14 22\n10 14 23\n10 15 24\n11 15 25\n11 16 26\n12 16 27\n13 17 28\n13 18 29\n14 18 30\n14 19 31\n15 19 32\n15 20 33\n16 20 34\n16 21 35\n17 22 36\n18 22 37\n19 23 38\n20 23 39\n21 24 40\n22 24 41\n23 24 42\n0 24",
        "expected_output": "0 1 4 7 10 15 19 23 24",
        "is_visible": false
      },
      {
        "input": "30 50\n0 1 5\n0 2 6\n0 3 7\n1 4 8\n2 4 9\n2 5 10\n3 5 11\n4 6 12\n4 7 13\n5 7 14\n5 8 15\n6 9 16\n6 10 17\n7 10 18\n7 11 19\n8 11 20\n9 12 21\n9 13 22\n10 13 23\n10 14 24\n11 14 25\n11 15 26\n12 16 27\n13 16 28\n13 17 29\n14 17 30\n14 18 31\n15 18 32\n16 19 33\n17 19 34\n17 20 35\n18 20 36\n19 21 37\n20 21 38\n21 22 39\n22 23 40\n23 24 41\n24 25 42\n25 26 43\n26 27 44\n27 28 45\n28 29 46\n0 29",
        "expected_output": "0 1 4 7 10 14 18 21 24 27 29",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int E = sc.nextInt();\n            ArrayList<ArrayList<int[]>> adj = new ArrayList<>();\n            for (int i = 0; i < V; i++) adj.add(new ArrayList<>());\n            for (int i = 0; i < E; i++) {\n                int u = sc.nextInt();\n                int v = sc.nextInt();\n                int w = sc.nextInt();\n                adj.get(u).add(new int[]{v, w});\n            }\n            int source = sc.nextInt();\n            int target = sc.nextInt();\n            ArrayList<Integer> result = bestFirstSearch(V, adj, source, target);\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i) + (i < result.size() - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static ArrayList<Integer> bestFirstSearch(int V, ArrayList<ArrayList<int[]>> adj, int source, int target) {\n        // Write your code here...\n        return new ArrayList<>();\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "12.4 Breadth First Traversal of a Graph",
    "description": "# 12.4 Breadth First Traversal of a Graph\n\nGiven a directed graph. The task is to do Breadth First Traversal of this graph starting from 0. One can move from node u to node v only if there's an edge from u to v. Find the BFS traversal of the graph starting from the 0th vertex, from left to right according to the input graph. Also, you should only take nodes directly or indirectly connected from Node 0 in consideration.\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n5 4\n0 1\n0 2\n0 3\n2 4\n0\n\nOutput:\n0 1 2 3 4\n```\n\n### Example 2:\n\n```\nInput:\n6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0\n\nOutput:\n0 1 2 3 4 5\n```\n\n### Example 3:\n\n```\nInput:\n7 6\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n0\n\nOutput:\n0 1 2 3 4 5 6\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "5 4\n0 1\n0 2\n0 3\n2 4\n0",
        "expected_output": "0 1 2 3 4",
        "is_visible": true
      },
      {
        "input": "6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0",
        "expected_output": "0 1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "7 6\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n0",
        "expected_output": "0 1 2 3 4 5 6",
        "is_visible": true
      },
      {
        "input": "8 7\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n0",
        "expected_output": "0 1 2 3 4 5 6 7",
        "is_visible": true
      },
      {
        "input": "10 9\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n0",
        "expected_output": "0 1 2 3 4 5 6 7 8 9",
        "is_visible": true
      },
      {
        "input": "12 11\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n0",
        "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11",
        "is_visible": false
      },
      {
        "input": "15 14\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n0",
        "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14",
        "is_visible": false
      },
      {
        "input": "20 19\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n0",
        "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19",
        "is_visible": false
      },
      {
        "input": "25 24\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n0",
        "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24",
        "is_visible": false
      },
      {
        "input": "30 29\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n22 25\n23 26\n24 27\n25 28\n26 29\n0",
        "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int E = sc.nextInt();\n            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < V; i++) adj.add(new ArrayList<>());\n            for (int i = 0; i < E; i++) {\n                int u = sc.nextInt();\n                int v = sc.nextInt();\n                adj.get(u).add(v);\n            }\n            int source = sc.hasNextInt() ? sc.nextInt() : 0;\n            ArrayList<Integer> result = bfs(V, adj, source);\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i) + (i < result.size() - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static ArrayList<Integer> bfs(int V, ArrayList<ArrayList<Integer>> adj, int source) {\n        // Write your code here...\n        return new ArrayList<>();\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "12.5 Depth First Search (DFS) for Disconnected Graph",
    "description": "# 12.5 Depth First Search (DFS) for Disconnected Graph\n\nGiven a Disconnected Graph, the task is to implement DFS or Depth First Search Algorithm for this Disconnected Graph.\nProcedure for DFS on Disconnected Graph:\nIterate over all the vertices of the graph and for any unvisited vertex, run a DFS from that vertex.\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n6 4\n0 1\n0 2\n1 2\n3 4\n5\n\nOutput:\n0 1 2 3 4 5\n```\n\n### Example 2:\n\n```\nInput:\n8 6\n0 1\n0 2\n1 3\n2 3\n4 5\n6 7\n\nOutput:\n0 1 3 2 4 5 6 7\n```\n\n### Example 3:\n\n```\nInput:\n10 8\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n\nOutput:\n0 1 3 2 4 5 6 8 7 9\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "6 4\n0 1\n0 2\n1 2\n3 4\n5",
        "expected_output": "0 1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "8 6\n0 1\n0 2\n1 3\n2 3\n4 5\n6 7",
        "expected_output": "0 1 3 2 4 5 6 7",
        "is_visible": true
      },
      {
        "input": "10 8\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9",
        "expected_output": "0 1 3 2 4 5 6 8 7 9",
        "is_visible": true
      },
      {
        "input": "12 10\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n11",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11",
        "is_visible": true
      },
      {
        "input": "15 12\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14",
        "is_visible": true
      },
      {
        "input": "20 16\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19",
        "is_visible": false
      },
      {
        "input": "25 20\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24",
        "is_visible": false
      },
      {
        "input": "30 24\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24\n25 26\n25 27\n26 28\n27 29",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24 25 26 28 27 29",
        "is_visible": false
      },
      {
        "input": "35 28\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24\n25 26\n25 27\n26 28\n27 29\n30 31\n30 32\n31 33\n32 34",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24 25 26 28 27 29 30 31 33 32 34",
        "is_visible": false
      },
      {
        "input": "40 32\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24\n25 26\n25 27\n26 28\n27 29\n30 31\n30 32\n31 33\n32 34\n35 36\n35 37\n36 38\n37 39",
        "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24 25 26 28 27 29 30 31 33 32 34 35 36 38 37 39",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int E = sc.nextInt();\n            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < V; i++) adj.add(new ArrayList<>());\n            for (int i = 0; i < E; i++) {\n                int u = sc.nextInt();\n                int v = sc.nextInt();\n                adj.get(u).add(v);\n            }\n            ArrayList<Integer> result = dfsDisconnected(V, adj);\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i) + (i < result.size() - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static ArrayList<Integer> dfsDisconnected(int V, ArrayList<ArrayList<Integer>> adj) {\n        // Write your code here...\n        return new ArrayList<>();\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "13.1 Kruskal\u2019s Algorithm",
    "description": "# 13.1 Kruskal\u2019s Algorithm\n\nIn Kruskal\u2019s algorithm, sort all edges of the given graph in increasing order. Then it keeps on adding new edges and nodes in the MST if the newly added edge does not form a cycle. It picks the minimum weighted edge at first and the maximum weighted edge at last.\nMST using Kruskal\u2019s algorithm:\n1. Sort all the edges in non-decreasing order of their weight.\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If the cycle is not formed, include this edge. Else, discard it.\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\nKruskal\u2019s algorithm to find the minimum cost spanning tree uses the greedy approach. The Greedy Choice is to pick the smallest weight edge that does not cause a cycle in the MST constructed so far.\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n4 5\n0 1 10\n0 2 6\n0 3 5\n1 3 15\n2 3 4\n\nOutput:\n2 3 4\n0 3 5\n0 1 10\n19\n```\n\n### Example 2:\n\n```\nInput:\n5 7\n0 1 2\n0 3 6\n1 2 3\n1 3 8\n1 4 5\n2 4 7\n3 4 9\n\nOutput:\n0 1 2\n1 2 3\n1 4 5\n0 3 6\n16\n```\n\n### Example 3:\n\n```\nInput:\n6 9\n0 1 4\n0 2 4\n1 2 2\n1 3 6\n2 3 8\n2 4 4\n3 4 9\n3 5 2\n4 5 3\n\nOutput:\n1 2 2\n3 5 2\n4 5 3\n0 1 4\n0 2 4\n14\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "4 5\n0 1 10\n0 2 6\n0 3 5\n1 3 15\n2 3 4",
        "expected_output": "2 3 4\n0 3 5\n0 1 10\n19",
        "is_visible": true
      },
      {
        "input": "5 7\n0 1 2\n0 3 6\n1 2 3\n1 3 8\n1 4 5\n2 4 7\n3 4 9",
        "expected_output": "0 1 2\n1 2 3\n1 4 5\n0 3 6\n16",
        "is_visible": true
      },
      {
        "input": "6 9\n0 1 4\n0 2 4\n1 2 2\n1 3 6\n2 3 8\n2 4 4\n3 4 9\n3 5 2\n4 5 3",
        "expected_output": "1 2 2\n3 5 2\n4 5 3\n0 1 4\n0 2 4\n14",
        "is_visible": true
      },
      {
        "input": "7 11\n0 1 7\n0 3 5\n1 2 8\n1 3 9\n1 4 7\n2 4 5\n3 4 15\n3 5 6\n4 5 8\n4 6 9\n5 6 11",
        "expected_output": "0 3 5\n2 4 5\n3 5 6\n0 1 7\n1 4 7\n4 6 9\n39",
        "is_visible": true
      },
      {
        "input": "8 14\n0 1 4\n0 7 8\n1 2 8\n1 7 11\n2 3 7\n2 5 4\n2 8 2\n3 4 9\n3 5 14\n4 5 10\n5 6 2\n6 7 1\n6 8 6\n7 8 7",
        "expected_output": "6 7 1\n2 8 2\n5 6 2\n0 1 4\n2 5 4\n2 3 7\n0 7 8\n1 2 8\n37",
        "is_visible": true
      },
      {
        "input": "10 20\n0 1 2\n0 2 4\n0 3 3\n1 4 7\n2 4 5\n2 5 6\n3 5 8\n4 6 4\n4 7 5\n5 7 3\n5 8 6\n6 9 2\n7 9 4\n7 8 5\n8 9 3\n9 10 1\n10 11 2\n11 12 3\n12 13 4\n13 14 5",
        "expected_output": "9 10 1\n0 1 2\n6 9 2\n10 11 2\n5 7 3\n8 9 3\n11 12 3\n0 3 3\n0 2 4\n4 6 4\n7 9 4\n12 13 4\n2 4 5\n4 7 5\n7 8 5\n13 14 5\n2 5 6\n5 8 6\n1 4 7\n3 5 8\n92",
        "is_visible": false
      },
      {
        "input": "12 25\n0 1 3\n0 2 5\n0 3 4\n1 4 6\n2 4 7\n2 5 8\n3 5 9\n4 6 10\n4 7 5\n5 7 6\n5 8 7\n6 9 8\n6 10 9\n7 9 10\n7 10 11\n8 10 12\n8 11 13\n9 11 14\n9 12 15\n10 12 16\n10 13 17\n11 13 18\n12 13 19\n12 14 20\n13 14 21",
        "expected_output": "0 1 3\n0 3 4\n4 7 5\n1 4 6\n5 7 6\n5 8 7\n6 9 8\n6 10 9\n7 9 10\n4 6 10\n7 10 11\n8 10 12\n8 11 13\n9 11 14\n9 12 15\n10 12 16\n10 13 17\n11 13 18\n12 13 19\n12 14 20\n13 14 21\n238",
        "is_visible": false
      },
      {
        "input": "15 30\n0 1 4\n0 2 5\n0 3 6\n1 4 7\n2 4 8\n2 5 9\n3 5 10\n4 6 11\n4 7 12\n5 7 13\n5 8 14\n6 9 15\n6 10 16\n7 10 17\n7 11 18\n8 11 19\n8 12 20\n9 13 21\n9 14 22\n10 14 23\n10 15 24\n11 15 25\n11 16 26\n12 16 27\n13 17 28\n14 17 29\n15 18 30\n16 18 31\n17 19 32\n18 19 33",
        "expected_output": "0 1 4\n0 2 5\n0 3 6\n1 4 7\n2 4 8\n2 5 9\n3 5 10\n4 6 11\n4 7 12\n5 7 13\n5 8 14\n6 9 15\n6 10 16\n7 10 17\n7 11 18\n8 11 19\n8 12 20\n9 13 21\n9 14 22\n10 14 23\n10 15 24\n11 15 25\n11 16 26\n12 16 27\n13 17 28\n14 17 29\n15 18 30\n16 18 31\n17 19 32\n18 19 33\n465",
        "is_visible": false
      },
      {
        "input": "20 40\n0 1 5\n0 2 6\n0 3 7\n1 4 8\n2 4 9\n2 5 10\n3 5 11\n4 6 12\n4 7 13\n5 7 14\n5 8 15\n6 9 16\n6 10 17\n7 10 18\n7 11 19\n8 11 20\n9 12 21\n9 13 22\n10 13 23\n10 14 24\n11 14 25\n11 15 26\n12 16 27\n13 16 28\n13 17 29\n14 17 30\n14 18 31\n15 18 32\n16 19 33\n17 19 34\n18 20 35\n19 20 36\n20 21 37\n21 22 38\n22 23 39\n23 24 40\n24 25 41\n25 26 42\n26 27 43\n27 28 44",
        "expected_output": "0 1 5\n0 2 6\n0 3 7\n1 4 8\n2 4 9\n2 5 10\n3 5 11\n4 6 12\n4 7 13\n5 7 14\n5 8 15\n6 9 16\n6 10 17\n7 10 18\n7 11 19\n8 11 20\n9 12 21\n9 13 22\n10 13 23\n10 14 24\n11 14 25\n11 15 26\n12 16 27\n13 16 28\n13 17 29\n14 17 30\n14 18 31\n15 18 32\n16 19 33\n17 19 34\n18 20 35\n19 20 36\n20 21 37\n21 22 38\n22 23 39\n23 24 40\n24 25 41\n25 26 42\n26 27 43\n27 28 44\n860",
        "is_visible": false
      },
      {
        "input": "25 50\n0 1 6\n0 2 7\n0 3 8\n1 4 9\n2 4 10\n2 5 11\n3 5 12\n4 6 13\n4 7 14\n5 7 15\n5 8 16\n6 9 17\n6 10 18\n7 10 19\n7 11 20\n8 11 21\n9 12 22\n9 13 23\n10 13 24\n10 14 25\n11 14 26\n11 15 27\n12 16 28\n13 16 29\n13 17 30\n14 17 31\n14 18 32\n15 18 33\n16 19 34\n17 19 35\n18 20 36\n19 20 37\n20 21 38\n21 22 39\n22 23 40\n23 24 41\n24 25 42\n25 26 43\n26 27 44\n27 28 45\n28 29 46\n29 30 47\n30 31 48\n31 32 49\n32 33 50\n33 34 51\n34 35 52\n35 36 53\n36 37 54\n37 38 55",
        "expected_output": "0 1 6\n0 2 7\n0 3 8\n1 4 9\n2 4 10\n2 5 11\n3 5 12\n4 6 13\n4 7 14\n5 7 15\n5 8 16\n6 9 17\n6 10 18\n7 10 19\n7 11 20\n8 11 21\n9 12 22\n9 13 23\n10 13 24\n10 14 25\n11 14 26\n11 15 27\n12 16 28\n13 16 29\n13 17 30\n14 17 31\n14 18 32\n15 18 33\n16 19 34\n17 19 35\n18 20 36\n19 20 37\n20 21 38\n21 22 39\n22 23 40\n23 24 41\n24 25 42\n25 26 43\n26 27 44\n27 28 45\n28 29 46\n29 30 47\n30 31 48\n31 32 49\n32 33 50\n33 34 51\n34 35 52\n35 36 53\n36 37 54\n37 38 55\n1463",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class MSTResult {\n        List<int[]> edges; // {u, v, w}\n        int minCost;\n        public MSTResult(List<int[]> edges, int minCost) {\n            this.edges = edges;\n            this.minCost = minCost;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int E = sc.nextInt();\n            int[][] edges = new int[E][3];\n            for (int i = 0; i < E; i++) {\n                edges[i][0] = sc.nextInt();\n                edges[i][1] = sc.nextInt();\n                edges[i][2] = sc.nextInt();\n            }\n            MSTResult result = kruskal(V, edges);\n            for (int[] edge : result.edges) {\n                System.out.println(edge[0] + \" \" + edge[1] + \" \" + edge[2]);\n            }\n            System.out.println(result.minCost);\n        }\n        sc.close();\n    }\n// endregion\n    public static MSTResult kruskal(int V, int[][] edges) {\n        // Write your code here...\n        // Return new MSTResult(new ArrayList<>(), 0);\n        return null;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "13.2 Prim\u2019s Algorithm",
    "description": "# 13.2 Prim\u2019s Algorithm\n\nThe Prim\u2019s algorithm starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, and the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.\nPrim\u2019s Algorithm:\nThe working of Prim\u2019s algorithm can be described by using the following steps:\n1. Determine an arbitrary vertex as the starting vertex of the MST.\n2. Follow steps 3 to 5 till there are vertices that are not included in the MST (known as fringe vertex).\n3. Find edges connecting any tree vertex with the fringe vertices.\n4. Find the minimum among these edges.\n5. Add the chosen edge to the MST if it does not form any cycle.\n6. Return the MST and exit\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n4\n0 2 0 6\n2 0 3 8\n0 3 0 0\n6 8 0 0\n\nOutput:\n0 - 1 2\n1 - 2 3\n0 - 3 6\n11\n```\n\n### Example 2:\n\n```\nInput:\n5\n0 2 0 6 0\n2 0 3 8 5\n0 3 0 0 7\n6 8 0 0 9\n0 5 7 9 0\n\nOutput:\n0 - 1 2\n1 - 2 3\n0 - 3 6\n1 - 4 5\n16\n```\n\n### Example 3:\n\n```\nInput:\n6\n0 4 0 0 0 0\n4 0 8 0 0 0\n0 8 0 7 0 4\n0 0 7 0 9 14\n0 0 0 9 0 10\n0 0 4 14 10 0\n\nOutput:\n0 - 1 4\n2 - 3 7\n2 - 5 4\n3 - 4 9\n1 - 2 8\n32\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "4\n0 2 0 6\n2 0 3 8\n0 3 0 0\n6 8 0 0",
        "expected_output": "0 - 1 2\n1 - 2 3\n0 - 3 6\n11",
        "is_visible": true
      },
      {
        "input": "5\n0 2 0 6 0\n2 0 3 8 5\n0 3 0 0 7\n6 8 0 0 9\n0 5 7 9 0",
        "expected_output": "0 - 1 2\n1 - 2 3\n0 - 3 6\n1 - 4 5\n16",
        "is_visible": true
      },
      {
        "input": "6\n0 4 0 0 0 0\n4 0 8 0 0 0\n0 8 0 7 0 4\n0 0 7 0 9 14\n0 0 0 9 0 10\n0 0 4 14 10 0",
        "expected_output": "0 - 1 4\n2 - 3 7\n2 - 5 4\n3 - 4 9\n1 - 2 8\n32",
        "is_visible": true
      },
      {
        "input": "7\n0 7 0 5 0 0 0\n7 0 8 9 7 0 0\n0 8 0 0 5 0 0\n5 9 0 0 15 6 0\n0 7 5 15 0 8 9\n0 0 0 6 8 0 11\n0 0 0 0 9 11 0",
        "expected_output": "0 - 1 7\n0 - 3 5\n1 - 4 7\n2 - 4 5\n3 - 5 6\n4 - 6 9\n39",
        "is_visible": true
      },
      {
        "input": "8\n0 4 0 0 0 0 0 8\n4 0 8 0 0 0 0 11\n0 8 0 7 0 4 0 0\n0 0 7 0 9 14 0 0\n0 0 0 9 0 10 0 0\n0 0 4 14 10 0 2 0\n0 0 0 0 0 2 0 1\n8 11 0 0 0 0 1 0",
        "expected_output": "0 - 1 4\n2 - 3 7\n2 - 5 4\n5 - 6 2\n6 - 7 1\n1 - 2 8\n0 - 7 8\n34",
        "is_visible": true
      },
      {
        "input": "10\n0 10 0 0 0 0 0 0 0 0\n10 0 20 0 0 0 0 0 0 0\n0 20 0 30 0 0 0 0 0 0\n0 0 30 0 40 0 0 0 0 0\n0 0 0 40 0 50 0 0 0 0\n0 0 0 0 50 0 60 0 0 0\n0 0 0 0 0 60 0 70 0 0\n0 0 0 0 0 0 70 0 80 0\n0 0 0 0 0 0 0 80 0 90\n0 0 0 0 0 0 0 0 90 0",
        "expected_output": "0 - 1 10\n1 - 2 20\n2 - 3 30\n3 - 4 40\n4 - 5 50\n5 - 6 60\n6 - 7 70\n7 - 8 80\n8 - 9 90\n450",
        "is_visible": false
      },
      {
        "input": "12\n0 5 0 0 0 0 0 0 0 0 0 0\n5 0 10 0 0 0 0 0 0 0 0 0\n0 10 0 15 0 0 0 0 0 0 0 0\n0 0 15 0 20 0 0 0 0 0 0 0\n0 0 0 20 0 25 0 0 0 0 0 0\n0 0 0 0 25 0 30 0 0 0 0 0\n0 0 0 0 0 30 0 35 0 0 0 0\n0 0 0 0 0 0 35 0 40 0 0 0\n0 0 0 0 0 0 0 40 0 45 0 0\n0 0 0 0 0 0 0 0 45 0 50 0\n0 0 0 0 0 0 0 0 0 50 0 55\n0 0 0 0 0 0 0 0 0 0 55 0",
        "expected_output": "0 - 1 5\n1 - 2 10\n2 - 3 15\n3 - 4 20\n4 - 5 25\n5 - 6 30\n6 - 7 35\n7 - 8 40\n8 - 9 45\n9 - 10 50\n10 - 11 55\n330",
        "is_visible": false
      },
      {
        "input": "15\n0 3 0 0 0 0 0 0 0 0 0 0 0 0 0\n3 0 4 0 0 0 0 0 0 0 0 0 0 0 0\n0 4 0 5 0 0 0 0 0 0 0 0 0 0 0\n0 0 5 0 6 0 0 0 0 0 0 0 0 0 0\n0 0 0 6 0 7 0 0 0 0 0 0 0 0 0\n0 0 0 0 7 0 8 0 0 0 0 0 0 0 0\n0 0 0 0 0 8 0 9 0 0 0 0 0 0 0\n0 0 0 0 0 0 9 0 10 0 0 0 0 0 0\n0 0 0 0 0 0 0 10 0 11 0 0 0 0 0\n0 0 0 0 0 0 0 0 11 0 12 0 0 0 0\n0 0 0 0 0 0 0 0 0 12 0 13 0 0 0\n0 0 0 0 0 0 0 0 0 0 13 0 14 0 0\n0 0 0 0 0 0 0 0 0 0 0 14 0 15 0\n0 0 0 0 0 0 0 0 0 0 0 0 15 0 16\n0 0 0 0 0 0 0 0 0 0 0 0 0 16 0",
        "expected_output": "0 - 1 3\n1 - 2 4\n2 - 3 5\n3 - 4 6\n4 - 5 7\n5 - 6 8\n6 - 7 9\n7 - 8 10\n8 - 9 11\n9 - 10 12\n10 - 11 13\n11 - 12 14\n12 - 13 15\n13 - 14 16\n119",
        "is_visible": false
      },
      {
        "input": "20\n0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 3 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 4 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 5 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 6 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 7 0 8 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 8 0 9 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 9 0 10 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 10 0 11 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 11 0 12 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 12 0 13 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 13 0 14 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 14 0 15 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 15 0 16 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 0 17 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 17 0 18 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 0 19 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19 0 20\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 0",
        "expected_output": "0 - 1 2\n1 - 2 3\n2 - 3 4\n3 - 4 5\n4 - 5 6\n5 - 6 7\n6 - 7 8\n7 - 8 9\n8 - 9 10\n9 - 10 11\n10 - 11 12\n11 - 12 13\n12 - 13 14\n13 - 14 15\n14 - 15 16\n15 - 16 17\n16 - 17 18\n17 - 18 19\n18 - 19 20\n209",
        "is_visible": false
      },
      {
        "input": "25\n0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 3 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 5 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 6 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 7 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 8 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 9 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 10 0 11 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 11 0 12 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 12 0 13 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 13 0 14 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 15 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 0 16 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 0 17 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 17 0 18 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 0 19 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19 0 20 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 0 21 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 21 0 22 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 23 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 23 0 24\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 24 0",
        "expected_output": "0 - 1 1\n1 - 2 2\n2 - 3 3\n3 - 4 4\n4 - 5 5\n5 - 6 6\n6 - 7 7\n7 - 8 8\n8 - 9 9\n9 - 10 10\n10 - 11 11\n11 - 12 12\n12 - 13 13\n13 - 14 14\n14 - 15 15\n15 - 16 16\n16 - 17 17\n17 - 18 18\n18 - 19 19\n19 - 20 20\n20 - 21 21\n21 - 22 22\n22 - 23 23\n23 - 24 24\n300",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class MSTResult {\n        List<String> edges; // formatted edge strings \"u - v w\"\n        int minCost;\n        public MSTResult(List<String> edges, int minCost) {\n            this.edges = edges;\n            this.minCost = minCost;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int[][] matrix = new int[V][V];\n            for (int i = 0; i < V; i++) {\n                for (int j = 0; j < V; j++) {\n                    matrix[i][j] = sc.nextInt();\n                }\n            }\n            MSTResult result = prim(V, matrix);\n            for (String edge : result.edges) {\n                System.out.println(edge);\n            }\n            System.out.println(result.minCost);\n        }\n        sc.close();\n    }\n// endregion\n    public static MSTResult prim(int V, int[][] matrix) {\n        // Write your code here...\n        // Format edges as \"u - v w\" strings\n        return null;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "13.3 Total Number of Spanning Trees in a Graph",
    "description": "# 13.3 Total Number of Spanning Trees in a Graph\n\nIf a graph is a complete graph with n vertices, then total number of spanning trees is n^(n-2) where n is the number of nodes in the graph. In complete graph, the task is equal to counting different labeled trees with n nodes for which have Cayley's formula.\n**Laplacian matrix:**\nA Laplacian matrix L, where L[i, j] is the degree of node i and L[i, j] = -1 if there is an edge between nodes i and j, and otherwise L[i, j] = 0.\nKirchhoff\u2019s theorem provides a way to calculate the number of spanning trees for a given graph as a determinant of a special matrix.\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n4\n0 1 1 1\n1 0 1 1\n1 1 0 1\n1 1 1 0\n\nOutput:\n16\n```\n\n### Example 2:\n\n```\nInput:\n3\n0 1 1\n1 0 1\n1 1 0\n\nOutput:\n3\n```\n\n### Example 3:\n\n```\nInput:\n5\n0 1 1 1 1\n1 0 1 1 1\n1 1 0 1 1\n1 1 1 0 1\n1 1 1 1 0\n\nOutput:\n125\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "4\n0 1 1 1\n1 0 1 1\n1 1 0 1\n1 1 1 0",
        "expected_output": "16",
        "is_visible": true
      },
      {
        "input": "3\n0 1 1\n1 0 1\n1 1 0",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "5\n0 1 1 1 1\n1 0 1 1 1\n1 1 0 1 1\n1 1 1 0 1\n1 1 1 1 0",
        "expected_output": "125",
        "is_visible": true
      },
      {
        "input": "2\n0 1\n1 0",
        "expected_output": "1",
        "is_visible": true
      },
      {
        "input": "6\n0 1 1 1 1 1\n1 0 1 1 1 1\n1 1 0 1 1 1\n1 1 1 0 1 1\n1 1 1 1 0 1\n1 1 1 1 1 0",
        "expected_output": "1296",
        "is_visible": true
      },
      {
        "input": "7\n0 1 1 1 1 1 1\n1 0 1 1 1 1 1\n1 1 0 1 1 1 1\n1 1 1 0 1 1 1\n1 1 1 1 0 1 1\n1 1 1 1 1 0 1\n1 1 1 1 1 1 0",
        "expected_output": "16807",
        "is_visible": false
      },
      {
        "input": "8\n0 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1\n1 1 0 1 1 1 1 1\n1 1 1 0 1 1 1 1\n1 1 1 1 0 1 1 1\n1 1 1 1 1 0 1 1\n1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 0",
        "expected_output": "262144",
        "is_visible": false
      },
      {
        "input": "9\n0 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1\n1 1 1 1 0 1 1 1 1\n1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 0 1 1\n1 1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 1 0",
        "expected_output": "4782969",
        "is_visible": false
      },
      {
        "input": "10\n0 1 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1 1\n1 1 1 1 0 1 1 1 1 1\n1 1 1 1 1 0 1 1 1 1\n1 1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 1 0 1 1\n1 1 1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 1 1 0",
        "expected_output": "10000000",
        "is_visible": false
      },
      {
        "input": "11\n0 1 1 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1 1 1\n1 1 1 1 0 1 1 1 1 1 1\n1 1 1 1 1 0 1 1 1 1 1\n1 1 1 1 1 1 0 1 1 1 1\n1 1 1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 1 1 0 1 1\n1 1 1 1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 1 1 1 0",
        "expected_output": "19487171",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int[][] matrix = new int[V][V];\n            for (int i = 0; i < V; i++) {\n                for (int j = 0; j < V; j++) {\n                    matrix[i][j] = sc.nextInt();\n                }\n            }\n            System.out.println(countSpanningTrees(V, matrix));\n        }\n        sc.close();\n    }\n// endregion\n    public static long countSpanningTrees(int V, int[][] matrix) {\n        // Write your code here...\n        return 0;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "13.4 Minimum Product Spanning Tree",
    "description": "# 13.4 Minimum Product Spanning Tree\n\nA minimum product spanning tree for a weighted, connected, and undirected graph is a spanning tree with a weight product less than or equal to the weight product of every other spanning tree. The weight product of a spanning tree is the product of weights corresponding to each edge of the spanning tree. All weights of the given graph will be positive for simplicity.\nThis problem can be solved using standard minimum spanning tree algorithms like Kruskal and prim\u2019s algorithm, but we need to modify our graph to use these algorithms. Minimum spanning tree algorithms tries to minimize the total sum of weights, here we need to minimize the total product of weights. We can use the property of logarithms to overcome this problem.\nlog(w1* w2 * w3 * .... * wN) = log(w1) + log(w2) + log(w3) .... + log(wN)\nWe can replace each weight of the graph by its log value, then we apply any minimum spanning tree algorithm which will try to minimize the sum of log(wi) which in turn minimizes the weight product.\n\n## Examples\n\n### Example 1:\n\n```\nInput:\n5\n0 2 0 6 0\n2 0 3 8 5\n0 3 0 0 7\n6 8 0 0 9\n0 5 7 9 0\n\nOutput:\n0 1 2\n1 2 3\n0 3 6\n1 4 5\n180\n```\n\n### Example 2:\n\n```\nInput:\n4\n0 5 0 10\n5 0 6 0\n0 6 0 15\n10 0 15 0\n\nOutput:\n0 1 5\n1 2 6\n0 3 10\n300\n```\n\n### Example 3:\n\n```\nInput:\n6\n0 4 0 0 0 0\n4 0 8 0 0 0\n0 8 0 7 0 4\n0 0 7 0 9 14\n0 0 0 9 0 10\n0 0 4 14 10 0\n\nOutput:\n0 1 4\n2 3 7\n2 5 4\n3 4 9\n1 2 8\n32256\n```\n\n## Constraints:\n\n- `1 <= V <= 100`\n- `0 <= E <= V * (V - 1) / 2`\n- All edge weights are non-negative (unless specified otherwise).\n- The graph may be disconnected (unless specified otherwise).\n",
    "testcases": [
      {
        "input": "5\n0 2 0 6 0\n2 0 3 8 5\n0 3 0 0 7\n6 8 0 0 9\n0 5 7 9 0",
        "expected_output": "0 1 2\n1 2 3\n0 3 6\n1 4 5\n180",
        "is_visible": true
      },
      {
        "input": "4\n0 5 0 10\n5 0 6 0\n0 6 0 15\n10 0 15 0",
        "expected_output": "0 1 5\n1 2 6\n0 3 10\n300",
        "is_visible": true
      },
      {
        "input": "6\n0 4 0 0 0 0\n4 0 8 0 0 0\n0 8 0 7 0 4\n0 0 7 0 9 14\n0 0 0 9 0 10\n0 0 4 14 10 0",
        "expected_output": "0 1 4\n2 3 7\n2 5 4\n3 4 9\n1 2 8\n32256",
        "is_visible": true
      },
      {
        "input": "7\n0 2 0 3 0 0 0\n2 0 4 0 5 0 0\n0 4 0 6 0 7 0\n3 0 6 0 8 0 9\n0 5 0 8 0 10 0\n0 0 7 0 10 0 11\n0 0 0 9 0 11 0",
        "expected_output": "0 1 2\n0 3 3\n1 2 4\n2 5 7\n3 4 8\n5 6 11\n29568",
        "is_visible": true
      },
      {
        "input": "8\n0 3 0 4 0 0 0 0\n3 0 5 0 6 0 0 0\n0 5 0 7 0 8 0 0\n4 0 7 0 9 0 10 0\n0 6 0 9 0 11 0 12\n0 0 8 0 11 0 13 0\n0 0 0 10 0 13 0 14\n0 0 0 0 12 0 14 0",
        "expected_output": "0 1 3\n0 3 4\n1 2 5\n2 5 8\n3 4 9\n4 7 12\n5 6 13\n786240",
        "is_visible": true
      },
      {
        "input": "10\n0 2 0 3 0 0 0 0 0 0\n2 0 4 0 5 0 0 0 0 0\n0 4 0 6 0 7 0 0 0 0\n3 0 6 0 8 0 9 0 0 0\n0 5 0 8 0 10 0 11 0 0\n0 0 7 0 10 0 12 0 13 0\n0 0 0 9 0 12 0 14 0 15\n0 0 0 0 11 0 14 0 16 0\n0 0 0 0 0 13 0 16 0 17\n0 0 0 0 0 0 15 0 17 0",
        "expected_output": "0 1 2\n0 3 3\n1 2 4\n2 5 7\n3 4 8\n4 7 11\n5 6 12\n6 9 15\n7 8 16\n8 9 17\n170559360",
        "is_visible": false
      },
      {
        "input": "12\n0 3 0 4 0 0 0 0 0 0 0 0\n3 0 5 0 6 0 0 0 0 0 0 0\n0 5 0 7 0 8 0 0 0 0 0 0\n4 0 7 0 9 0 10 0 0 0 0 0\n0 6 0 9 0 11 0 12 0 0 0 0\n0 0 8 0 11 0 13 0 14 0 0 0\n0 0 0 10 0 13 0 15 0 16 0 0\n0 0 0 0 12 0 15 0 17 0 18 0\n0 0 0 0 0 14 0 17 0 19 0 20\n0 0 0 0 0 0 16 0 19 0 21 0\n0 0 0 0 0 0 0 18 0 21 0 22\n0 0 0 0 0 0 0 0 20 0 22 0",
        "expected_output": "0 1 3\n0 3 4\n1 2 5\n2 5 8\n3 4 9\n4 7 12\n5 6 13\n6 9 16\n7 8 17\n8 11 20\n9 10 21\n10 11 22\n1203948748800",
        "is_visible": false
      },
      {
        "input": "15\n0 4 0 5 0 0 0 0 0 0 0 0 0 0 0\n4 0 6 0 7 0 0 0 0 0 0 0 0 0 0\n0 6 0 8 0 9 0 0 0 0 0 0 0 0 0\n5 0 8 0 10 0 11 0 0 0 0 0 0 0 0\n0 7 0 10 0 12 0 13 0 0 0 0 0 0 0\n0 0 9 0 12 0 14 0 15 0 0 0 0 0 0\n0 0 0 11 0 14 0 16 0 17 0 0 0 0 0\n0 0 0 0 13 0 16 0 18 0 19 0 0 0 0\n0 0 0 0 0 15 0 18 0 20 0 21 0 0 0\n0 0 0 0 0 0 17 0 20 0 22 0 23 0 0\n0 0 0 0 0 0 0 19 0 22 0 24 0 25 0\n0 0 0 0 0 0 0 0 21 0 24 0 26 0 27\n0 0 0 0 0 0 0 0 0 23 0 26 0 28 0\n0 0 0 0 0 0 0 0 0 0 25 0 28 0 29\n0 0 0 0 0 0 0 0 0 0 0 27 0 29 0",
        "expected_output": "0 1 4\n0 3 5\n1 2 6\n2 5 9\n3 4 10\n4 7 13\n5 6 14\n6 9 17\n7 8 18\n8 11 21\n9 10 22\n10 13 25\n11 12 26\n12 14 29\n13 14 29\n1.2234528E19",
        "is_visible": false
      },
      {
        "input": "20\n0 5 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n5 0 7 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 7 0 9 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n6 0 9 0 11 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 0 11 0 13 0 14 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 10 0 13 0 15 0 16 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 12 0 15 0 17 0 18 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 14 0 17 0 19 0 20 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 16 0 19 0 21 0 22 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 18 0 21 0 23 0 24 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 20 0 23 0 25 0 26 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 22 0 25 0 27 0 28 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 24 0 27 0 29 0 30 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 26 0 29 0 31 0 32 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 28 0 31 0 33 0 34 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 30 0 33 0 35 0 36 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 35 0 37 0 38\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 34 0 37 0 39 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 36 0 39 0 40\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 38 0 40 0",
        "expected_output": "0 1 5\n0 3 6\n1 2 7\n2 5 10\n3 4 11\n4 7 14\n5 6 15\n6 9 18\n7 8 19\n8 11 22\n9 10 23\n10 13 26\n11 12 27\n12 15 30\n13 14 31\n14 17 34\n15 16 35\n16 19 38\n17 18 39\n18 19 40\n1.1342748E28",
        "is_visible": false
      },
      {
        "input": "25\n0 6 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n6 0 8 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 0 10 0 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n7 0 10 0 12 0 13 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 9 0 12 0 14 0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 11 0 14 0 16 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 13 0 16 0 18 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 15 0 18 0 20 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 17 0 20 0 22 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 19 0 22 0 24 0 25 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 21 0 24 0 26 0 27 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 23 0 26 0 28 0 29 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 25 0 28 0 30 0 31 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 27 0 30 0 32 0 33 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 29 0 32 0 34 0 35 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 31 0 34 0 36 0 37 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 33 0 36 0 38 0 39 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 35 0 38 0 40 0 41 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 37 0 40 0 42 0 43 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 39 0 42 0 44 0 45 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41 0 44 0 46 0 47 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 43 0 46 0 48 0 49\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 45 0 48 0 50 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 47 0 50 0 51\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 49 0 51 0",
        "expected_output": "0 1 6\n0 3 7\n1 2 8\n2 5 11\n3 4 12\n4 7 15\n5 6 16\n6 9 19\n7 8 20\n8 11 23\n9 10 24\n10 13 27\n11 12 28\n12 15 31\n13 14 32\n14 17 35\n15 16 36\n16 19 39\n17 18 40\n18 21 43\n19 20 44\n20 23 47\n21 22 48\n22 24 50\n23 24 51\n1.0384593E38",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ProductMSTResult {\n        List<int[]> edges; // {u, v, w}\n        double product; // Use double for large products handling (or String/BigDecimal if needed, but sample has E notation)\n        public ProductMSTResult(List<int[]> edges, double product) {\n            this.edges = edges;\n            this.product = product;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int V = sc.nextInt();\n            int[][] matrix = new int[V][V];\n            for (int i = 0; i < V; i++) {\n                for (int j = 0; j < V; j++) {\n                    matrix[i][j] = sc.nextInt();\n                }\n            }\n            ProductMSTResult result = minProductMST(V, matrix);\n            for (int[] edge : result.edges) {\n                System.out.println(edge[0] + \" \" + edge[1] + \" \" + edge[2]);\n            }\n            System.out.println(result.product);\n        }\n        sc.close();\n    }\n// endregion\n    public static ProductMSTResult minProductMST(int V, int[][] matrix) {\n        // Write your code here...\n        return null;\n    }\n// region boilerplate\n}\n// endregion"
    }
  }
]