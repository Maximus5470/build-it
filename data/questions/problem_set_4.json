[
  {
    "title": "6.3 Queue using Stacks",
    "description": "# Queue using Stacks\n\nImplement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n- `void push(int x)` Pushes element x to the back of the queue.\n- `int pop()` Removes the element from the front of the queue and returns it.\n- `int peek()` Returns the element at the front of the queue.\n- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n## Example 1:\n\n```\nInput\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n```",

    "testcases": [
      {
        "input": "push 1\npush 2\npeek\npop\nempty",
        "expected_output": "1\n1\nfalse",
        "is_visible": true
      },
      {
        "input": "push 10\npush 20\npop\npeek",
        "expected_output": "10\n20",
        "is_visible": true
      },
      {
        "input": "push 5\npop\nempty",
        "expected_output": "5\ntrue",
        "is_visible": true
      },
      {
        "input": "push 100\npush 200\npush 300\npop\npop\npeek",
        "expected_output": "100\n200\n300",
        "is_visible": true
      },
      {
        "input": "empty\npush 50\nempty",
        "expected_output": "true\nfalse",
        "is_visible": true
      },
      {
        "input": "push 1\npush 2\npush 3\npop\npush 4\npop\npeek",
        "expected_output": "1\n2\n3",
        "is_visible": false
      },
      {
        "input": "push 10\npush 20\npush 30\npop\npop\npush 40\npop\npeek",
        "expected_output": "10\n20\n30\n40",
        "is_visible": false
      },
      {
        "input": "empty\npush 5\npush 10\npop\nempty\npush 15\npop\npeek",
        "expected_output": "true\n5\nfalse\n10\n15",
        "is_visible": false
      },
      {
        "input": "push 1\npush 2\npush 3\npush 4\npush 5\npop\npop\npop\npop\npop\nempty",
        "expected_output": "1\n2\n3\n4\n5\ntrue",
        "is_visible": false
      },
      {
        "input": "push 100\npush 200\npop\npush 300\npush 400\npop\npop\npeek\nempty",
        "expected_output": "100\n200\n300\n400\nfalse",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        MyQueue q = new MyQueue();\n        while (sc.hasNext()) {\n            String cmd = sc.next();\n            switch (cmd) {\n                case \"push\": q.push(sc.nextInt()); break;\n                case \"pop\": System.out.println(q.pop()); break;\n                case \"peek\": System.out.println(q.peek()); break;\n                case \"empty\": System.out.println(q.empty()); break;\n            }\n        }\n        sc.close();\n    }\n// endregion\n    static class MyQueue {\n        public void push(int x) {\n            // Write your code here\n        }\n        public int pop() {\n            // Write your code here\n            return 0;\n        }\n        public int peek() {\n            // Write your code here\n            return 0;\n        }\n        public boolean empty() {\n            // Write your code here\n            return false;\n        }\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "6.4 Circular Queue",
    "description": "# Circular Queue\n\nA **Circular Queue** is an extended version of a normal queue where the last element of the queue is connected to the first element of the queue forming a circle. The operations are performed based on FIFO (First In First Out) principle. It is also called 'Ring Buffer'.\n\n## Operations:\n\n- `MyCircularQueue(k)`: Initializes the object with the size of the queue to be `k`.\n- `int Front()`: Gets the front item from the queue. If the queue is empty, return -1.\n- `int Rear()`: Gets the last item from the queue. If the queue is empty, return -1.\n- `boolean enQueue(int value)`: Inserts an element into the circular queue. Return true if the operation is successful.\n- `boolean deQueue()`: Deletes an element from the circular queue. Return true if the operation is successful.\n- `boolean isEmpty()`: Checks whether the circular queue is empty or not.\n- `boolean isFull()`: Checks whether the circular queue is full or not.\n\n## Example 1:\n\n```\nInput\n[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\nOutput\n[null, true, true, true, false, 3, true, true, true, 4]\n```",

    "testcases": [
      {
        "input": "5\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\ndisplay",
        "expected_output": "30 40",
        "is_visible": true
      },
      {
        "input": "3\nenqueue 5\nenqueue 10\ndequeue",
        "expected_output": "5",
        "is_visible": true
      },
      {
        "input": "4\nenqueue 100\nenqueue 200\ndequeue\ndequeue",
        "expected_output": "Queue is empty",
        "is_visible": true
      },
      {
        "input": "6\nenqueue 1\nenqueue 2\nenqueue 3\ndequeue\nenqueue 4\ndisplay",
        "expected_output": "2 3 4",
        "is_visible": true
      },
      {
        "input": "5\nenqueue 99\ndequeue\nenqueue 88\ndequeue\ndequeue",
        "expected_output": "Queue is empty",
        "is_visible": true
      },
      {
        "input": "8\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\nenqueue 50\nenqueue 60\nenqueue 70\ndisplay",
        "expected_output": "30 40 50 60 70",
        "is_visible": false
      },
      {
        "input": "10\nenqueue 5\nenqueue 10\nenqueue 15\ndequeue\nenqueue 20\ndequeue\nenqueue 25\nenqueue 30\ndequeue\ndequeue\ndisplay",
        "expected_output": "20 25 30",
        "is_visible": false
      },
      {
        "input": "12\nenqueue 100\nenqueue 200\nenqueue 300\ndequeue\nenqueue 400\ndequeue\nenqueue 500\nenqueue 600\ndequeue\ndequeue\ndequeue\ndisplay",
        "expected_output": "600",
        "is_visible": false
      },
      {
        "input": "15\nenqueue 1\nenqueue 2\nenqueue 3\nenqueue 4\nenqueue 5\ndequeue\ndequeue\ndequeue\nenqueue 6\nenqueue 7\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
        "expected_output": "6 7",
        "is_visible": false
      },
      {
        "input": "20\nenqueue 10\nenqueue 20\nenqueue 30\nenqueue 40\nenqueue 50\ndequeue\ndequeue\nenqueue 60\nenqueue 70\ndequeue\nenqueue 80\nenqueue 90\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
        "expected_output": "Queue is empty",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int k = sc.nextInt();\n            MyCircularQueue q = new MyCircularQueue(k);\n            while (sc.hasNext()) {\n                String cmd = sc.next();\n                switch (cmd) {\n                    case \"enqueue\": q.enQueue(sc.nextInt()); break;\n                    case \"dequeue\": q.deQueue(); break;\n                    case \"display\": q.display(); break;\n                }\n            }\n        }\n        sc.close();\n    }\n// endregion\n    static class MyCircularQueue {\n        public MyCircularQueue(int k) {\n            // Write your code here\n        }\n        public void enQueue(int value) {\n            // Write your code here\n        }\n        public void deQueue() {\n            // Write your code here\n        }\n        public void display() {\n            // Write your code here\n        }\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "6.5 Deque (Doubly Ended Queue)",
    "description": "# Deque (Doubly Ended Queue)\n\nIn a **Deque** (Doubly Ended Queue), one can perform insert (append) and delete (pop) operations from both the ends of the container.\n\n## Operations:\n\n1. `append(x)`: Insert `x` to the right end.\n2. `appendleft(x)`: Insert `x` to the left end.\n3. `pop()`: Delete from the right end.\n4. `popleft()`: Delete from the left end.\n5. `display()`: Print the current deque.\n\n## Example 1:\n\n```\nInput: append(1), append(2), appendleft(3), display()\nOutput: 3 1 2\n```",

    "testcases": [
      {
        "input": "append 10\nappend 20\nappend 30\npopleft\npop\ndisplay",
        "expected_output": "20",
        "is_visible": true
      },
      {
        "input": "appendleft 5\nappend 10\nappend 15\npopleft\nappend 20\ndisplay",
        "expected_output": "10 15 20",
        "is_visible": true
      },
      {
        "input": "append 100\nappend 200\npopleft\npop\ndisplay",
        "expected_output": "Deque is empty",
        "is_visible": true
      },
      {
        "input": "append 1\nappend 2\nappendleft 0\npop\ndisplay",
        "expected_output": "0 1",
        "is_visible": true
      },
      {
        "input": "append 50\nappendleft 40\nappend 60\npopleft\nappendleft 30\ndisplay",
        "expected_output": "30 50 60",
        "is_visible": true
      },
      {
        "input": "append 10\nappend 20\nappend 30\nappendleft 5\nappendleft 1\npop\npopleft\ndisplay",
        "expected_output": "5 10 20",
        "is_visible": false
      },
      {
        "input": "append 100\nappend 200\nappend 300\npopleft\nappendleft 50\nappend 400\npop\ndisplay",
        "expected_output": "50 200 300",
        "is_visible": false
      },
      {
        "input": "append 1\nappend 2\nappend 3\nappendleft 0\nappend 4\npopleft\npop\nappendleft -1\ndisplay",
        "expected_output": "-1 1 2 3",
        "is_visible": false
      },
      {
        "input": "append 10\nappend 20\nappend 30\nappend 40\nappend 50\npopleft\npopleft\nappendleft 5\nappend 60\npop\ndisplay",
        "expected_output": "5 30 40 50",
        "is_visible": false
      },
      {
        "input": "append 100\nappend 200\nappendleft 50\nappend 300\nappendleft 25\npopleft\npop\nappend 400\nappendleft 75\ndisplay",
        "expected_output": "75 50 100 200 300",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        MyDeque q = new MyDeque();\n        while (sc.hasNext()) {\n            String cmd = sc.next();\n            switch (cmd) {\n                case \"append\": q.append(sc.nextInt()); break;\n                case \"appendleft\": q.appendleft(sc.nextInt()); break;\n                case \"pop\": q.pop(); break;\n                case \"popleft\": q.popleft(); break;\n                case \"display\": q.display(); break;\n            }\n        }\n        sc.close();\n    }\n// endregion\n    static class MyDeque {\n        public void append(int x) {\n            // Write your code here\n        }\n        public void appendleft(int x) {\n            // Write your code here\n        }\n        public void pop() {\n            // Write your code here\n        }\n        public void popleft() {\n            // Write your code here\n        }\n        public void display() {\n            // Write your code here\n        }\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.1 Singly Linked List",
    "description": "# Singly Linked List\n\nA **singly linked list** is a linear data structure in which the elements are not stored in contiguous memory locations and each element is connected only to its next element using a pointer.\n\n## Operations:\n\n1. `insertAtEnd(data)`\n2. `remove_first_node()`\n3. `remove_last_node()`\n4. `remove_at_index(i)`\n5. `updateNode(data, i)`\n6. `sizeOfLL()`\n\n## Example 1:\n\n```\nInput: insertAtEnd(1), insertAtEnd(2), sizeOfLL()\nOutput: 2\n```",

    "testcases": [
      {
        "input": "insertAtEnd A\ninsertAtEnd B\ninsertAtEnd C\nremove_first_node\nprintln",
        "expected_output": "B C",
        "is_visible": true
      },
      {
        "input": "insertAtEnd 10\ninsertAtEnd 20\ninsertAtEnd 30\nremove_last_node\nprintln",
        "expected_output": "10 20",
        "is_visible": true
      },
      {
        "input": "insertAtEnd X\ninsertAtEnd Y\ninsertAtEnd Z\nremove_at_index 1\nprintln",
        "expected_output": "X Z",
        "is_visible": true
      },
      {
        "input": "insertAtEnd apple\ninsertAtEnd banana\ninsertAtEnd cherry\nremove_node banana\nprintln",
        "expected_output": "apple cherry",
        "is_visible": true
      },
      {
        "input": "insertAtEnd 1\ninsertAtEnd 2\ninsertAtEnd 3\nsizeOfLL",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "insertAtEnd A\ninsertAtEnd B\ninsertAtEnd C\ninsertAtEnd D\nremove_at_index 2\nremove_first_node\nprintln",
        "expected_output": "B D",
        "is_visible": false
      },
      {
        "input": "insertAtEnd 10\ninsertAtEnd 20\ninsertAtEnd 30\ninsertAtEnd 40\nupdateNode 25 2\nremove_last_node\nprintln",
        "expected_output": "10 20 25",
        "is_visible": false
      },
      {
        "input": "insertAtEnd red\ninsertAtEnd green\ninsertAtEnd blue\ninsertAtEnd yellow\nremove_node green\nremove_at_index 0\nprintln",
        "expected_output": "blue yellow",
        "is_visible": false
      },
      {
        "input": "insertAtEnd 1\ninsertAtEnd 2\ninsertAtEnd 3\ninsertAtEnd 4\ninsertAtEnd 5\nremove_first_node\nremove_last_node\nremove_at_index 1\nprintln",
        "expected_output": "2 4",
        "is_visible": false
      },
      {
        "input": "insertAtEnd A\ninsertAtEnd B\ninsertAtEnd C\ninsertAtEnd D\ninsertAtEnd E\nremove_node C\nupdateNode X 1\nremove_first_node\nsizeOfLL",
        "expected_output": "3",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        MyLinkedList list = new MyLinkedList();\n        while (sc.hasNext()) {\n            String cmd = sc.next();\n            switch (cmd) {\n                case \"insertAtEnd\": list.insertAtEnd(sc.next()); break;\n                case \"remove_first_node\": list.remove_first_node(); break;\n                case \"remove_last_node\": list.remove_last_node(); break;\n                case \"remove_at_index\": list.remove_at_index(sc.nextInt()); break;\n                case \"remove_node\": list.remove_node(sc.next()); break;\n                case \"sizeOfLL\": System.out.println(list.sizeOfLL()); break;\n                case \"updateNode\": String val = sc.next(); int idx = sc.nextInt(); list.updateNode(val, idx); break;\n                case \"println\": list.println(); break;\n            }\n        }\n        sc.close();\n    }\n// endregion\n    static class MyLinkedList {\n        public void insertAtEnd(String data) {\n            // Write your code here\n        }\n        public void remove_first_node() {\n            // Write your code here\n        }\n        public void remove_last_node() {\n            // Write your code here\n        }\n        public void remove_at_index(int i) {\n            // Write your code here\n        }\n        public void remove_node(String data) {\n            // Write your code here\n        }\n        public int sizeOfLL() {\n            // Write your code here\n            return 0;\n        }\n        public void updateNode(String data, int i) {\n            // Write your code here\n        }\n        public void println() {\n            // Write your code here\n        }\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.2 Linked List Cycle",
    "description": "# Linked List Cycle\n\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` *if there is a cycle in the linked list*. Otherwise, return `false`.\n\n## Example 1:\n\n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n```\n\n## Example 2:\n\n```\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n```\n\n## Example 3:\n\n```\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n```",

    "testcases": [
      {
        "input": "4\n3 2 0 -4\n1",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "2\n1 2\n0",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "1\n1\n-1",
        "expected_output": "false",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\n-1",
        "expected_output": "false",
        "is_visible": true
      },
      {
        "input": "3\n1 2 3\n0",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\n3",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "7\n1 2 3 4 5 6 7\n6",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "8\n5 4 3 2 1 0 -1 -2\n-1",
        "expected_output": "false",
        "is_visible": false
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10\n9",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "12\n100 200 300 400 500 600 700 800 900 1000 1100 1200\n-1",
        "expected_output": "false",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) { val = x; next = null; }\n    }\n    static ListNode buildList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (int i=0; i<n; i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ListNode head = buildList(sc);\n        if(sc.hasNextInt()) {\n            int pos = sc.nextInt();\n            if (pos != -1) {\n                ListNode tail = head;\n                while(tail.next != null) tail = tail.next;\n                ListNode cycle = head;\n                for(int i=0; i<pos; i++) cycle = cycle.next;\n                tail.next = cycle;\n            }\n        }\n        System.out.println(hasCycle(head));\n        sc.close();\n    }\n// endregion\n    public static boolean hasCycle(ListNode head) {\n        // Write your code here\n        return false;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.3 Remove Linked List Elements",
    "description": "# Remove Linked List Elements\n\nGiven the `head` of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return *the new head*.\n\n## Example 1:\n\n```\nInput: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]\n```\n\n## Example 2:\n\n```\nInput: head = [], val = 1\nOutput: []\n```\n\n## Example 3:\n\n```\nInput: head = [7,7,7,7], val = 7\nOutput: []\n```",

    "testcases": [
      {
        "input": "7\n1 2 6 3 4 5 6\n6",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "0\n\n1",
        "expected_output": "",
        "is_visible": true
      },
      {
        "input": "4\n7 7 7 7\n7",
        "expected_output": "",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\n10",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "6\n10 20 10 30 10 40\n10",
        "expected_output": "20 30 40",
        "is_visible": true
      },
      {
        "input": "8\n5 1 5 2 5 3 5 4\n5",
        "expected_output": "1 2 3 4",
        "is_visible": false
      },
      {
        "input": "10\n1 1 2 2 3 3 4 4 5 5\n3",
        "expected_output": "1 1 2 2 4 4 5 5",
        "is_visible": false
      },
      {
        "input": "12\n100 200 300 100 200 300 100 200 300 100 200 300\n100",
        "expected_output": "200 300 200 300 200 300 200 300",
        "is_visible": false
      },
      {
        "input": "15\n0 1 0 2 0 3 0 4 0 5 0 6 0 7 0\n0",
        "expected_output": "1 2 3 4 5 6 7",
        "is_visible": false
      },
      {
        "input": "20\n5 10 5 15 5 20 5 25 5 30 5 35 5 40 5 45 5 50 5 55\n5",
        "expected_output": "10 15 20 25 30 35 40 45 50 55",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) { val = x; next = null; }\n    }\n    static ListNode buildList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (int i=0; i<n; i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n    static void printList(ListNode head) {\n        ListNode temp = head;\n        while(temp != null) {\n            System.out.print(temp.val + (temp.next!=null?\" \":\"\"));\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ListNode head = buildList(sc);\n        if(sc.hasNextInt()) {\n            int val = sc.nextInt();\n            ListNode res = removeElements(head, val);\n            printList(res);\n        }\n        sc.close();\n    }\n// endregion\n    public static ListNode removeElements(ListNode head, int val) {\n        // Write your code here\n        return null;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.4 Reverse Linked List",
    "description": "# Reverse Linked List\n\nGiven the `head` of a singly linked list, reverse the list, and return *the reversed list*.\n\n## Example 1:\n\n```\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n```\n\n## Example 2:\n\n```\nInput: head = [1,2]\nOutput: [2,1]\n```\n\n## Example 3:\n\n```\nInput: head = []\nOutput: []\n```\n\n## Constraints:\n\n- The number of nodes in the list is the range `[0, 5000]`.\n- `-5000 <= Node.val <= 5000`",

    "testcases": [
      {
        "input": "5\n1 2 3 4 5",
        "expected_output": "5 4 3 2 1",
        "is_visible": true
      },
      {
        "input": "2\n1 2",
        "expected_output": "2 1",
        "is_visible": true
      },
      {
        "input": "1\n10",
        "expected_output": "10",
        "is_visible": true
      },
      {
        "input": "4\n4 3 2 1",
        "expected_output": "1 2 3 4",
        "is_visible": true
      },
      {
        "input": "3\n100 200 300",
        "expected_output": "300 200 100",
        "is_visible": true
      },
      {
        "input": "6\n1 3 5 7 9 11",
        "expected_output": "11 9 7 5 3 1",
        "is_visible": false
      },
      {
        "input": "8\n10 20 30 40 50 60 70 80",
        "expected_output": "80 70 60 50 40 30 20 10",
        "is_visible": false
      },
      {
        "input": "10\n5 10 15 20 25 30 35 40 45 50",
        "expected_output": "50 45 40 35 30 25 20 15 10 5",
        "is_visible": false
      },
      {
        "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12",
        "expected_output": "12 11 10 9 8 7 6 5 4 3 2 1",
        "is_visible": false
      },
      {
        "input": "15\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500",
        "expected_output": "1500 1400 1300 1200 1100 1000 900 800 700 600 500 400 300 200 100",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) { val = x; next = null; }\n    }\n    static ListNode buildList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (int i=0; i<n; i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n    static void printList(ListNode head) {\n        ListNode temp = head;\n        while(temp != null) {\n            System.out.print(temp.val + (temp.next!=null?\" \":\"\"));\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ListNode head = buildList(sc);\n        ListNode res = reverseList(head);\n        printList(res);\n        sc.close();\n    }\n// endregion\n    public static ListNode reverseList(ListNode head) {\n        // Write your code here\n        return null;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.5 Palindrome Linked List",
    "description": "# Palindrome Linked List\n\nGiven the `head` of a singly linked list, return `true` if it is a palindrome or `false` otherwise.\n\n## Example 1:\n\n```\nInput: head = [1,2,2,1]\nOutput: true\n```\n\n## Example 2:\n\n```\nInput: head = [1,2]\nOutput: false\n```\n\n## Constraints:\n\n- The number of nodes in the list is the range `[1, 10^5]`.\n- `0 <= Node.val <= 9`",

    "testcases": [
      {
        "input": "4\n1 2 2 1",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "2\n1 2",
        "expected_output": "false",
        "is_visible": true
      },
      {
        "input": "3\n1 2 1",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "1\n5",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 2 1",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "6\n1 2 3 3 2 1",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "7\n1 2 3 4 3 2 1",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "8\n1 2 3 4 4 3 2 1",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "5\n1 2 3 4 5",
        "expected_output": "false",
        "is_visible": false
      },
      {
        "input": "10\n1 2 3 4 5 5 4 3 2 1",
        "expected_output": "true",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) { val = x; next = null; }\n    }\n    static ListNode buildList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (int i=0; i<n; i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ListNode head = buildList(sc);\n        System.out.println(isPalindrome(head));\n        sc.close();\n    }\n// endregion\n    public static boolean isPalindrome(ListNode head) {\n        // Write your code here\n        return false;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.6 Middle of the Linked List",
    "description": "# Middle of the Linked List\n\nGiven the `head` of a singly linked list, return *the middle node of the linked list*.\n\nIf there are two middle nodes, return the **second middle node**.\n\n## Example 1:\n\n```\nInput: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n```\n\n## Example 2:\n\n```\nInput: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n```",

    "testcases": [
      {
        "input": "5\n1 2 3 4 5",
        "expected_output": "3 4 5",
        "is_visible": true
      },
      {
        "input": "6\n1 2 3 4 5 6",
        "expected_output": "4 5 6",
        "is_visible": true
      },
      {
        "input": "1\n10",
        "expected_output": "10",
        "is_visible": true
      },
      {
        "input": "3\n100 200 300",
        "expected_output": "200 300",
        "is_visible": true
      },
      {
        "input": "2\n5 10",
        "expected_output": "10",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7",
        "expected_output": "4 5 6 7",
        "is_visible": false
      },
      {
        "input": "8\n10 20 30 40 50 60 70 80",
        "expected_output": "50 60 70 80",
        "is_visible": false
      },
      {
        "input": "9\n1 3 5 7 9 11 13 15 17",
        "expected_output": "9 11 13 15 17",
        "is_visible": false
      },
      {
        "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12",
        "expected_output": "7 8 9 10 11 12",
        "is_visible": false
      },
      {
        "input": "15\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500",
        "expected_output": "800 900 1000 1100 1200 1300 1400 1500",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) { val = x; next = null; }\n    }\n    static ListNode buildList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (int i=0; i<n; i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n    static void printList(ListNode head) {\n        ListNode temp = head;\n        while(temp != null) {\n            System.out.print(temp.val + (temp.next!=null?\" \":\"\"));\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ListNode head = buildList(sc);\n        ListNode mid = middleNode(head);\n        printList(mid);\n        sc.close();\n    }\n// endregion\n    public static ListNode middleNode(ListNode head) {\n        // Write your code here\n        return null;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "7.7 Convert Binary Number in a Linked List to Integer",
    "description": "# Convert Binary Number in a Linked List to Integer\n\nGiven `head` which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\n\nReturn the *decimal value* of the number in the linked list.\n\nThe most significant bit is at the head of the linked list.\n\n## Example 1:\n\n```\nInput: head = [1,0,1]\nOutput: 5\nExplanation: (101) in base 2 = (5) in base 10\n```\n\n## Example 2:\n\n```\nInput: head = [0]\nOutput: 0\n```",

    "testcases": [
      {
        "input": "3\n1 0 1",
        "expected_output": "5",
        "is_visible": true
      },
      {
        "input": "1\n0",
        "expected_output": "0",
        "is_visible": true
      },
      {
        "input": "4\n1 1 1 1",
        "expected_output": "15",
        "is_visible": true
      },
      {
        "input": "5\n1 0 1 0 1",
        "expected_output": "21",
        "is_visible": true
      },
      {
        "input": "2\n1 0",
        "expected_output": "2",
        "is_visible": true
      },
      {
        "input": "6\n1 0 0 1 1 0",
        "expected_output": "38",
        "is_visible": false
      },
      {
        "input": "8\n1 1 0 0 1 1 0 1",
        "expected_output": "205",
        "is_visible": false
      },
      {
        "input": "10\n1 0 1 0 1 0 1 0 1 0",
        "expected_output": "682",
        "is_visible": false
      },
      {
        "input": "12\n1 1 1 1 0 0 0 0 1 1 1 1",
        "expected_output": "3855",
        "is_visible": false
      },
      {
        "input": "15\n1 0 0 0 0 0 0 0 0 0 0 0 0 0 1",
        "expected_output": "16385",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) { val = x; next = null; }\n    }\n    static ListNode buildList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (int i=0; i<n; i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ListNode head = buildList(sc);\n        System.out.println(getDecimalValue(head));\n        sc.close();\n    }\n// endregion\n    public static int getDecimalValue(ListNode head) {\n        // Write your code here\n        return 0;\n    }\n// region boilerplate\n}\n// endregion"
    }
  }
]