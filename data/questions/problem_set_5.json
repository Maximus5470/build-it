[
  {
    "title": "8.1 Circular Linked List",
    "description": "The circular linked list is a linked list where all nodes are connected to form a circle. In a circular linked list, the first node and the last node are connected to each other which forms a circle. There is no NULL at the end. Operations on the circular linked list: 1. Insertion at the beginning 2. Insertion at the end 3. Insertion in between the nodes 4. Deletion at the beginning 5. Deletion at the end 6. Deletion in between the nodes 7. Traversal",
    "starter_code": "import java.util.ArrayList;\npublic class Main{\n    static class Node{\n    int data;\n    Node next;\n    Node(int data){\n    this.data = data;\n    this.next = null;\n    }\n}\nstatic class CircularLinkedList\n{\n# Write Code Here\n}\nNode addAfter(int data, int item)\n{\n# Write Code Here\n}\nvoid deleteNode(Node last, int key)\n{\n# Write Code Here\n}\nSystem.",
    "testcases": [
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeginning\ntraverse",
        "expected_output": "20 30",
        "is_visible": true
      },
      {
        "input": "insertBeginning 5\ninsertEnd 15\ntraverse",
        "expected_output": "5 15",
        "is_visible": true
      },
      {
        "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ndeleteEnd\ntraverse",
        "expected_output": "100 200",
        "is_visible": true
      },
      {
        "input": "insertEnd 1\ninsertEnd 2\ninsertEnd 3\ndeleteKey 2\ntraverse",
        "expected_output": "1 3",
        "is_visible": true
      },
      {
        "input": "insertBeginning 50\ninsertEnd 100\ninsertAfter 75 50\ntraverse",
        "expected_output": "50 75 100",
        "is_visible": true
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ndeleteBeginning\ndeleteEnd\ntraverse",
        "expected_output": "20 30",
        "is_visible": false
      },
      {
        "input": "insertBeginning 5\ninsertEnd 10\ninsertAfter 7 5\ninsertEnd 15\ndeleteKey 10\ntraverse",
        "expected_output": "5 7 15",
        "is_visible": false
      },
      {
        "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ninsertEnd 400\ndeleteBeginning\ndeleteKey 300\ntraverse",
        "expected_output": "200 400",
        "is_visible": false
      },
      {
        "input": "insertBeginning 1\ninsertEnd 2\ninsertEnd 3\ninsertEnd 4\ninsertEnd 5\ndeleteEnd\ndeleteBeginning\ninsertAfter 6 3\ntraverse",
        "expected_output": "2 3 6 4",
        "is_visible": false
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ninsertEnd 50\ndeleteKey 30\ndeleteBeginning\ndeleteEnd\ntraverse",
        "expected_output": "20 40",
        "is_visible": false
      }
    ]
  },
  {
    "title": "8.2 Doubly Linked List",
    "description": "The A doubly linked list is a type of linked list in which each node consists of 3 components: 1. *prev - address of the previous node 2. data - data item 3. *next - address of next node. Operations on the Double Linked List: 1. Insertion at the beginning 2. Insertion at the end 3. Insertion in between the nodes 4. Deletion at the beginning 5. Deletion at the end 6. Deletion in between the nodes 7. Traversal",
    "starter_code": "import java.util.Scanner;\n\nclass Node {\n    int data;\n    Node next;\n    Node prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n}\n\nclass DLinkedList {\n    Node head;\n    int ctr;\n\n    DLinkedList() {\n    this.head = null;\n    this.ctr = 0;\n}\n\n    void insertBeg(int data)\n    {\n    # Write Code Here\n    }\n    void insertEnd(int data)\n    {\n    # Write Code Here\n    }\n    void deleteBeg()\n    {\n    # Write Code Here\n    }\n    void deleteEnd()\n    {\n    # Write Code Here\n    }\n    void insertPos(int pos, int data)\n    {\n    # Write Code Here\n    }\n    void deletePos(int pos)\n    {\n    # Write Code Here\n    }\n    void traverseF()\n    {\n    # Write Code Here\n    }\n    void traverseR()\n    {\n    # Write Code Here\n    }\n\n    public class Main {\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
    "testcases": [
      {
        "input": "insertBeg 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeg\ntraverseF",
        "expected_output": "20 30",
        "is_visible": true
      },
      {
        "input": "insertEnd 5\ninsertEnd 15\ninsertPos 1 10\ntraverseF",
        "expected_output": "5 10 15",
        "is_visible": true
      },
      {
        "input": "insertBeg 100\ninsertEnd 200\ninsertEnd 300\ndeleteEnd\ntraverseF",
        "expected_output": "100 200",
        "is_visible": true
      },
      {
        "input": "insertEnd 1\ninsertEnd 2\ninsertEnd 3\ndeletePos 1\ntraverseF",
        "expected_output": "1 3",
        "is_visible": true
      },
      {
        "input": "insertBeg 50\ninsertEnd 100\ninsertPos 1 75\ntraverseF",
        "expected_output": "50 75 100",
        "is_visible": true
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ndeleteBeg\ndeleteEnd\ntraverseF",
        "expected_output": "20 30",
        "is_visible": false
      },
      {
        "input": "insertBeg 5\ninsertEnd 10\ninsertPos 1 7\ninsertEnd 15\ndeletePos 2\ntraverseF",
        "expected_output": "5 7 15",
        "is_visible": false
      },
      {
        "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ninsertEnd 400\ndeleteBeg\ndeletePos 1\ntraverseF",
        "expected_output": "200 400",
        "is_visible": false
      },
      {
        "input": "insertBeg 1\ninsertEnd 2\ninsertEnd 3\ninsertEnd 4\ninsertEnd 5\ndeleteEnd\ndeleteBeg\ninsertPos 1 6\ntraverseF",
        "expected_output": "6 2 3 4",
        "is_visible": false
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ninsertEnd 50\ndeletePos 2\ndeleteBeg\ndeleteEnd\ntraverseR",
        "expected_output": "40 20",
        "is_visible": false
      }
    ]
  },
  {
    "title": "8.3 Sorted Merge of Two Sorted Doubly Circular Linked Lists",
    "description": "Given two sorted Doubly circular Linked List containing n1 and n2 nodes respectively. The problem is to merge the two lists such that resultant list is also in sorted order. Input: List 1 and List 2 head1 1 3 5 8 head2 2 7 9 11 Output: Merged List final 1 2 3 5 7 8 9 11 Procedure for Merging Doubly Linked List: 1. If head1 == NULL, return head2. 2. If head2 == NULL, return head1. 3. Let last1 and last2 be the last nodes of the two lists respectively. They can be obtained with the help of the previous links of the first nodes. 4. Get pointer to the node which will be the last node of the final list. If last1.data < last2.data, then last_node = last2, Else last_node = last1. 5. Update last1.next = last2.next = NULL. 6. Now merge the two lists as two sorted doubly linked list are being merged. Refer merge procedure of this post. Let the first node of the final list be finalHead. 7. Update finalHead.prev = last_node and last_node.next = finalHead. 8. Return finalHead.",
    "starter_code": "class Node {\n    int data;\n    Node next, prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n}\n\npublic class SortedMergeDoublyCircularLinkedList\n    {\n    # Write Code Here\n    }\n\n    static Node mergeUtil(Node head1, Node head2)\n    {\n    # Write Code Here\n    }\n    static void printList(Node head)\n    {\n    # Write Code Here\n    }\n\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
    "testcases": [
      {
        "input": "4\n1 3 5 8\n4\n2 7 9 11",
        "expected_output": "1 2 3 5 7 8 9 11",
        "is_visible": true
      },
      {
        "input": "3\n10 20 30\n2\n5 15",
        "expected_output": "5 10 15 20 30",
        "is_visible": true
      },
      {
        "input": "2\n1 2\n3\n3 4 5",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "1\n100\n3\n50 150 200",
        "expected_output": "50 100 150 200",
        "is_visible": true
      },
      {
        "input": "0\n\n3\n1 2 3",
        "expected_output": "1 2 3",
        "is_visible": true
      },
      {
        "input": "5\n2 4 6 8 10\n4\n1 3 5 7",
        "expected_output": "1 2 3 4 5 6 7 8 10",
        "is_visible": false
      },
      {
        "input": "6\n10 20 30 40 50 60\n5\n5 15 25 35 45",
        "expected_output": "5 10 15 20 25 30 35 40 45 50 60",
        "is_visible": false
      },
      {
        "input": "7\n1 3 5 7 9 11 13\n6\n2 4 6 8 10 12",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13",
        "is_visible": false
      },
      {
        "input": "8\n5 10 15 20 25 30 35 40\n8\n1 2 3 4 6 8 12 16",
        "expected_output": "1 2 3 4 5 6 8 10 12 15 16 20 25 30 35 40",
        "is_visible": false
      },
      {
        "input": "10\n100 200 300 400 500 600 700 800 900 1000\n10\n50 150 250 350 450 550 650 750 850 950",
        "expected_output": "50 100 150 200 250 300 350 400 450 500 550 600 650 700 750 800 850 900 950 1000",
        "is_visible": false
      }
    ]
  },
  {
    "title": "8.4 Delete all occurrences of a given key in a Doubly Linked List",
    "description": "Given a doubly linked list and a key x. The problem is to delete all occurrences of the given key x from the doubly linked list. Input: 2 <-> 2 <-> 10 <-> 8 <-> 4 <-> 2 <-> 5 <-> 2 x = 2 Output: 10 <-> 8 <-> 4 <-> 5 Algorithm: delAllOccurOfGivenKey (head_ref, x) if head_ref == NULL return Initialize current = head_ref Declare next while current != NULL if current->data == x next = current->next deleteNode(head_ref, current) current = next else current = current->next",
    "starter_code": "class Node {\n    int data;\n    Node next, prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n    }\n}\n\npublic class DeleteOccurrenceInDoublyLinkedList\n    {\n    # Write Code Here\n    }\n    static Node deleteAllOccurOfX(Node head, int x)\n    {\n    # Write Code Here\n    }\n    static void printList(Node head)\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
    "testcases": [
      {
        "input": "8\n2 2 10 8 4 2 5 2\n2",
        "expected_output": "10 8 4 5",
        "is_visible": true
      },
      {
        "input": "5\n1 1 1 1 1\n1",
        "expected_output": "",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\n100",
        "expected_output": "10 20 30 40 50 60",
        "is_visible": true
      },
      {
        "input": "7\n5 10 5 15 5 20 5\n5",
        "expected_output": "10 15 20",
        "is_visible": true
      },
      {
        "input": "4\n100 200 300 400\n200",
        "expected_output": "100 300 400",
        "is_visible": true
      },
      {
        "input": "10\n1 2 1 3 1 4 1 5 1 6\n1",
        "expected_output": "2 3 4 5 6",
        "is_visible": false
      },
      {
        "input": "12\n10 20 10 30 10 40 10 50 10 60 10 70\n10",
        "expected_output": "20 30 40 50 60 70",
        "is_visible": false
      },
      {
        "input": "15\n5 1 5 2 5 3 5 4 5 5 5 6 5 7 5\n5",
        "expected_output": "1 2 3 4 6 7",
        "is_visible": false
      },
      {
        "input": "20\n2 4 2 6 2 8 2 10 2 12 2 14 2 16 2 18 2 20 2 22\n2",
        "expected_output": "4 6 8 10 12 14 16 18 20 22",
        "is_visible": false
      },
      {
        "input": "25\n1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13\n1",
        "expected_output": "2 3 4 5 6 7 8 9 10 11 12 13",
        "is_visible": false
      }
    ]
  },
  {
    "title": "8.5 Delete a Doubly Linked List Node at a Given Position",
    "description": "Given a doubly linked list and a position n. The task is to delete the node at the given position n from the beginning. Input: Initial doubly linked list 10 8 4 2 5 Output: Doubly Linked List after deletion of node at position n = 2 10 4 2 5 Procedure: 1. Get the pointer to the node at position n by traversing the doubly linked list up to the nth node from the beginning. 2. Delete the node using the pointer obtained in Step 1.",
    "starter_code": "class Node {\n    int data;\n    Node next, prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n}\n\npublic class DeleteNodeAtGivenPosition\n    {\n    # Write Code Here\n    }\n    static Node deleteNode(Node head, Node del)\n    {\n    # Write Code Here\n    }\n    static Node deleteNodeAtGivenPos(Node head, int n)\n    {\n    # Write Code Here\n    }\n    static void printList(Node head)\n    {\n    # Write Code Here\n    }\n}",
    "testcases": [
      {
        "input": "5\n10 8 4 2 5\n2",
        "expected_output": "10 4 2 5",
        "is_visible": true
      },
      {
        "input": "3\n100 200 300\n1",
        "expected_output": "200 300",
        "is_visible": true
      },
      {
        "input": "4\n1 2 3 4\n4",
        "expected_output": "1 2 3",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\n3",
        "expected_output": "10 20 40 50 60",
        "is_visible": true
      },
      {
        "input": "1\n5\n1",
        "expected_output": "",
        "is_visible": true
      },
      {
        "input": "8\n1 2 3 4 5 6 7 8\n5",
        "expected_output": "1 2 3 4 6 7 8",
        "is_visible": false
      },
      {
        "input": "10\n10 20 30 40 50 60 70 80 90 100\n7",
        "expected_output": "10 20 30 40 50 60 80 90 100",
        "is_visible": false
      },
      {
        "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\n10",
        "expected_output": "5 10 15 20 25 30 35 40 45 55 60",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n12",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 13 14 15",
        "is_visible": false
      },
      {
        "input": "20\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000\n15",
        "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1600 1700 1800 1900 2000",
        "is_visible": false
      }
    ]
  },
  {
    "title": "9.1 Tree Creation and Basic Tree Terminologies",
    "description": "A tree data structure is a hierarchical structure that is used to represent and organize data in a way that is easy to navigate and search. It is a collection of nodes that are connected by edges and has a hierarchical relationship between the nodes. Basic Terminologies in Tree: 1. Parent Node: The node which is a predecessor of a node is called the parent node of that node. (B) is the parent node of (D, E). 2. Child Node: The node which is the immediate successor of a node is called the child node of that node. Examples: (D, E) are the child nodes of (B). 3. Root Node: The topmost node of a tree or the node which does not have any parent node is called the root node. (A) is the root node of the tree. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree. 4. Leaf Node or External Node: The nodes which do not have any child nodes are called leaf nodes. (K, L, M, N, O, P) are the leaf nodes of the tree. 5. Ancestor of a Node: Any predecessor nodes on the path of the root to that node are called Ancestors of that node. (A, B) are the ancestor nodes of the node (E) 6. Descendant: Any successor node on the path from the leaf node to that node. (E, I) are the descendants of the node (B). 7. Sibling: Children of the same parent node are called siblings. (D, E) are called siblings. 8. Level of a node: The count of edges on the path from the root node to that node. The root node has level 0. 9. Internal node: A node with at least one child is called Internal Node. 10. Neighbour of a Node: Parent or child nodes of that node are called neighbors of that node. 11. Subtree: Any node of the tree along with its descendant.",
    "starter_code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeBasicTerminologies\n{\n    # Write Code Here\n    }\nstatic void printChildren(int root, List<List<Integer>> adj)\n{\n    # Write Code Here\n    }\nstatic void printLeafNodes(int root, List<List<Integer>> adj)\n{\n    # Write Code Here\n    }\nstatic void printDegrees(int root, List<List<Integer>> adj)\n{\n    # Write Code Here\n    }\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
    "testcases": [
      {
        "input": "6\n0 1\n0 2\n1 3\n1 4\n2 5\nfindChildren 0",
        "expected_output": "1 2",
        "is_visible": true
      },
      {
        "input": "6\n0 1\n0 2\n1 3\n1 4\n2 5\nfindLeaves",
        "expected_output": "3 4 5",
        "is_visible": true
      },
      {
        "input": "5\n0 1\n0 2\n1 3\n1 4\nfindDegree 1",
        "expected_output": "2",
        "is_visible": true
      },
      {
        "input": "4\n0 1\n0 2\n0 3\nfindChildren 0",
        "expected_output": "1 2 3",
        "is_visible": true
      },
      {
        "input": "7\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\nfindLeaves",
        "expected_output": "3 4 5 6",
        "is_visible": true
      },
      {
        "input": "8\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n3 7\nfindChildren 3",
        "expected_output": "6 7",
        "is_visible": false
      },
      {
        "input": "10\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n4 8\n5 9\nfindLeaves",
        "expected_output": "7 8 9 6",
        "is_visible": false
      },
      {
        "input": "12\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n5 10\n5 11\nfindDegree 5",
        "expected_output": "2",
        "is_visible": false
      },
      {
        "input": "15\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\nfindChildren 4",
        "expected_output": "9 10",
        "is_visible": false
      },
      {
        "input": "20\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\n7 15\n8 16\n9 17\n10 18\n11 19\nfindLeaves",
        "expected_output": "15 16 17 18 19 12 13 14",
        "is_visible": false
      }
    ]
  },
  {
    "title": "9.2 Binary Tree Traversal Techniques",
    "description": "A binary tree data structure can be traversed in following ways: 1. Inorder Traversal 2. Preorder Traversal 3. Postorder Traversal 4. Level Order Traversal Algorithm Inorder (tree) 1. Traverse the left subtree, i.e., call Inorder(left->subtree) 2. Visit the root. 3. Traverse the right subtree, i.e., call Inorder(right->subtree) Algorithm Preorder (tree) 1. Visit the root. 2. Traverse the left subtree, i.e., call Preorder(left->subtree) 3. Traverse the right subtree, i.e., call Preorder(right->subtree) Algorithm Postorder (tree) 1. Traverse the left subtree, i.e., call Postorder(left->subtree) 2. Traverse the right subtree, i.e., call Postorder(right->subtree) 3. Visit the root.",
    "starter_code": "import java.util.Scanner;\nclass Node\n    {\n    # Write Code Here\n    }\nclass BT {\n    Node root;\n    BT() {\n    this.root = null;\n    }\n    void insert(int data)\n    {\n    # Write Code Here\n    }\n    Node insertRec(Node root, int data)\n    {\n    # Write Code Here\n    }\n    void postorder(Node root)\n    {\n    # Write Code Here\n    }\n    void preorder(Node root)\n    {\n    # Write Code Here\n    }\n    }\n    void inorder(Node root)\n    {\n    # Write Code Here\n    }\n}\n\npublic class BinaryTreeTraversal {\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n    }",
    "testcases": [
      {
        "input": "7\n1 2 3 4 5 6 7\ninorder",
        "expected_output": "4 2 5 1 6 3 7",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\npreorder",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "3\n1 2 3\npostorder",
        "expected_output": "3 2 1",
        "is_visible": true
      },
      {
        "input": "6\n1 2 3 4 5 6\ninorder",
        "expected_output": "4 2 5 1 6 3",
        "is_visible": true
      },
      {
        "input": "4\n1 2 3 4\npreorder",
        "expected_output": "1 2 3 4",
        "is_visible": true
      },
      {
        "input": "9\n1 2 3 4 5 6 7 8 9\ninorder",
        "expected_output": "8 4 9 2 5 1 6 3 7",
        "is_visible": false
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10\npreorder",
        "expected_output": "1 2 4 8 9 5 3 6 7 10",
        "is_visible": false
      },
      {
        "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12\npostorder",
        "expected_output": "8 9 4 10 5 2 11 12 6 7 3 1",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ninorder",
        "expected_output": "8 4 9 2 10 5 11 1 12 6 13 3 14 7 15",
        "is_visible": false
      },
      {
        "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\npreorder",
        "expected_output": "1 2 4 8 16 17 9 18 19 5 10 20 11 3 6 12 13 7 14 15",
        "is_visible": false
      }
    ]
  },
  {
    "title": "9.3 Insertion in a Binary Tree in Level Order",
    "description": "Given a binary tree and a key, insert the key into the binary tree at the first position available in level order. The idea is to do an iterative level order traversal of the given tree using queue. If we find a node whose left child is empty, we make a new key as the left child of the node. Else if we find a node whose right child is empty, we make the new key as the right child. We keep traversing the tree until we find a node whose either left or right child is empty.",
    "starter_code": "class Node\n{\n    # Write Code Here\n}\n\npublic class BinaryTreeInsertion\n{\n    # Write Code Here\n    }\n    static Node insert(Node root, int key)\n}\n\n# Write Code Here\n}\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
    "testcases": [
      {
        "input": "4\n1 2 3 4\ninsert 5\nlevelorder",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "3\n10 20 30\ninsert 40\nlevelorder",
        "expected_output": "10 20 30 40",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\ninsert 6\nlevelorder",
        "expected_output": "1 2 3 4 5 6",
        "is_visible": true
      },
      {
        "input": "1\n100\ninsert 200\nlevelorder",
        "expected_output": "100 200",
        "is_visible": true
      },
      {
        "input": "6\n5 3 7 2 4 6\ninsert 8\nlevelorder",
        "expected_output": "5 3 7 2 4 6 8",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7\ninsert 8\ninsert 9\nlevelorder",
        "expected_output": "1 2 3 4 5 6 7 8 9",
        "is_visible": false
      },
      {
        "input": "10\n10 20 30 40 50 60 70 80 90 100\ninsert 110\nlevelorder",
        "expected_output": "10 20 30 40 50 60 70 80 90 100 110",
        "is_visible": false
      },
      {
        "input": "12\n1 3 5 7 9 11 13 15 17 19 21 23\ninsert 24\nlevelorder",
        "expected_output": "1 3 5 7 9 11 13 15 17 19 21 23 24",
        "is_visible": false
      },
      {
        "input": "15\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30\ninsert 32\ninsert 34\nlevelorder",
        "expected_output": "2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34",
        "is_visible": false
      },
      {
        "input": "20\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\ninsert 105\nlevelorder",
        "expected_output": "5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105",
        "is_visible": false
      }
    ]
  },
  {
    "title": "9.4 Finding the Maximum Height or Depth of a Binary Tree",
    "description": "Given a binary tree, the task is to find the height of the tree. The height of the tree is the number of edges in the tree from the root to the deepest node. Note: The height of an empty tree is 0. Recursively calculate the height of the left and the right subtrees of a node and assign height to the node as max of the heights of two children plus 1. maxDepth('1') = max(maxDepth('2'), maxDepth('3')) + 1 = 2 + 1 because recursively maxDepth('2') = max (maxDepth('4'), maxDepth('5')) + 1 = 1 + 1 and (as height of both '4' and '5' are 1) maxDepth('3') = 1 Procedure: Recursively do a Depth-first search. If the tree is empty then return 0 Otherwise, do the following Get the max depth of the left subtree recursively i.e. call maxDepth( tree->left-subtree) Get the max depth of the right subtree recursively i.e. call maxDepth( tree->right-subtree) Get the max of max depths of left and right subtrees and add 1 to it for the current node. max_depth = max(max_depth[left]subtree, max_depth[right]subtree) + 1 Return max_depth.",
    "starter_code": "class Node\n{\n    int data;\n    Node left, right;\n\n    Node(int data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\npublic class MaximumDepthOfTree\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
    "testcases": [
      {
        "input": "3\n1 2 3",
        "expected_output": "2",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "1\n10",
        "expected_output": "1",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "6\n1 2 3 4 5 6",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10",
        "expected_output": "4",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
        "expected_output": "4",
        "is_visible": false
      },
      {
        "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
        "expected_output": "5",
        "is_visible": false
      },
      {
        "input": "31\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31",
        "expected_output": "5",
        "is_visible": false
      },
      {
        "input": "63\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63",
        "expected_output": "6",
        "is_visible": false
      }
    ]
  },
  {
    "title": "9.5 Deletion in a Binary Tree",
    "description": "Given a binary tree, delete a node from it by making sure that the tree shrinks from the bottom (i.e. the deleted node is replaced by the bottom-most and rightmost node). Input: Delete 10 in below tree 10 / \\ 20 30 Output: 30 / \\ 20 Input: Delete 20 in below tree 10 / \\ 20 30 \\ 40 Output: 10 / \\ 40 30 Algorithm: 1. Starting at the root, find the deepest and rightmost node in the binary tree and the node which we want to delete. 2. Replace the deepest rightmost node's data with the node to be deleted. 3. Then delete the deepest rightmost node.",
    "starter_code": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\npublic class BinaryTreeDeletion\n{\n    # Write Code Here\n    }\n    static void deleteDeepest(Node root, Node dNode)\n    # Write Code Here\n}\n    static Node deletion(Node root, int key)\n    # Write Code Here\n}\n    public static void main(String[] args)\n    # Write Code Here\n}",
    "testcases": [
      {
        "input": "3\n10 20 30\ndelete 10\nlevelorder",
        "expected_output": "30 20",
        "is_visible": true
      },
      {
        "input": "4\n10 20 30 40\ndelete 20\nlevelorder",
        "expected_output": "10 40 30",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\ndelete 3\nlevelorder",
        "expected_output": "1 2 5 4",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\ndelete 40\nlevelorder",
        "expected_output": "10 20 30 60 50",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7\ndelete 2\nlevelorder",
        "expected_output": "1 7 3 4 5 6",
        "is_visible": true
      },
      {
        "input": "8\n10 20 30 40 50 60 70 80\ndelete 30\nlevelorder",
        "expected_output": "10 20 80 40 50 60 70",
        "is_visible": false
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10\ndelete 5\nlevelorder",
        "expected_output": "1 2 3 4 10 6 7 8 9",
        "is_visible": false
      },
      {
        "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\ndelete 20\nlevelorder",
        "expected_output": "5 10 15 60 25 30 35 40 45 50 55",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ndelete 8\nlevelorder",
        "expected_output": "1 2 3 4 5 6 7 15 9 10 11 12 13 14",
        "is_visible": false
      },
      {
        "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\ndelete 12\nlevelorder",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 20 13 14 15 16 17 18 19",
        "is_visible": false
      }
    ]
  }
]