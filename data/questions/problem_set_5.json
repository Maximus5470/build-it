[
  {
    "title": "8.1 Circular Linked List",
    "description": "# Circular Linked List\n\nA **circular linked list** is a linked list where all nodes are connected to form a circle. In a circular linked list, the first node and the last node are connected to each other which forms a circle. There is no NULL at the end.\n\nYour task is to implement the following operations on a circular linked list:\n\n1.  **Insertion at the beginning**\n2.  **Insertion at the end**\n3.  **Insertion in between the nodes (after a specific value)**\n4.  **Deletion at the beginning**\n5.  **Deletion at the end**\n6.  **Deletion of a specific key**\n7.  **Traversal**\n\n## Example 1:\n\n```\nInput:\ninsertEnd 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeginning\ntraverse\n\nOutput: 20 30\nExplanation:\n1. insertEnd 10: List = [10]\n2. insertEnd 20: List = [10, 20]\n3. insertEnd 30: List = [10, 20, 30]\n4. deleteBeginning: List = [20, 30]\n5. traverse: Prints \"20 30\"\n```\n\n## Example 2:\n\n```\nInput:\ninsertBeginning 5\ninsertEnd 15\ntraverse\n\nOutput: 5 15\n```\n\n## Constraints:\n\n-   Number of operations <= 1000\n-   Values in the list are integers within the range `[-10^9, 10^9]`.\n",
    "testcases": [
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeginning\ntraverse",
        "expected_output": "20 30",
        "is_visible": true
      },
      {
        "input": "insertBeginning 5\ninsertEnd 15\ntraverse",
        "expected_output": "5 15",
        "is_visible": true
      },
      {
        "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ndeleteEnd\ntraverse",
        "expected_output": "100 200",
        "is_visible": true
      },
      {
        "input": "insertEnd 1\ninsertEnd 2\ninsertEnd 3\ndeleteKey 2\ntraverse",
        "expected_output": "1 3",
        "is_visible": true
      },
      {
        "input": "insertBeginning 50\ninsertEnd 100\ninsertAfter 75 50\ntraverse",
        "expected_output": "50 75 100",
        "is_visible": true
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ndeleteBeginning\ndeleteEnd\ntraverse",
        "expected_output": "20 30",
        "is_visible": false
      },
      {
        "input": "insertBeginning 5\ninsertEnd 10\ninsertAfter 7 5\ninsertEnd 15\ndeleteKey 10\ntraverse",
        "expected_output": "5 7 15",
        "is_visible": false
      },
      {
        "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ninsertEnd 400\ndeleteBeginning\ndeleteKey 300\ntraverse",
        "expected_output": "200 400",
        "is_visible": false
      },
      {
        "input": "insertBeginning 1\ninsertEnd 2\ninsertEnd 3\ninsertEnd 4\ninsertEnd 5\ndeleteEnd\ndeleteBeginning\ninsertAfter 6 3\ntraverse",
        "expected_output": "2 3 6 4",
        "is_visible": false
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ninsertEnd 50\ndeleteKey 30\ndeleteBeginning\ndeleteEnd\ntraverse",
        "expected_output": "20 40",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Node head = null;\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            String[] parts = line.split(\" \");\n            String command = parts[0];\n            \n            // 0=command\n            \n            switch (command) {\n                case \"insertEnd\":\n                    head = insertEnd(head, Integer.parseInt(parts[1]));\n                    break;\n                case \"insertBeginning\":\n                    head = insertBeginning(head, Integer.parseInt(parts[1]));\n                    break;\n                case \"insertAfter\":\n                    head = insertAfter(head, Integer.parseInt(parts[1]), Integer.parseInt(parts[2]));\n                    break;\n                case \"deleteBeginning\":\n                    head = deleteBeginning(head);\n                    break;\n                case \"deleteEnd\":\n                    head = deleteEnd(head);\n                    break;\n                case \"deleteKey\":\n                    head = deleteKey(head, Integer.parseInt(parts[1]));\n                    break;\n                case \"traverse\":\n                    traverse(head);\n                    System.out.println();\n                    break;\n            }\n        }\n        sc.close();\n    }\n// endregion\n    public static Node insertEnd(Node head, int data) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node insertBeginning(Node head, int data) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node insertAfter(Node head, int data, int item) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node deleteBeginning(Node head) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node deleteEnd(Node head) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node deleteKey(Node head, int key) {\n        // Write your code here\n        return head;\n    }\n    \n    public static void traverse(Node head) {\n        // Write your code here\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "8.2 Doubly Linked List",
    "description": "# Doubly Linked List\n\nA **doubly linked list** is a type of linked list in which each node consists of 3 components:\n1.  `prev` - address of the previous node\n2.  `data` - data item\n3.  `next` - address of next node\n\nYour task is to implement the following operations on a Doubly Linked List:\n\n1.  **Insertion at the beginning**\n2.  **Insertion at the end**\n3.  **Insertion in at a specific position**\n4.  **Deletion at the beginning**\n5.  **Deletion at the end**\n6.  **Deletion at a specific position**\n7.  **Traversal (Forward and Reverse)**\n\n## Example 1:\n\n```\nInput:\ninsertBeg 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeg\ntraverseF\n\nOutput: 20 30\n```\n\n## Example 2:\n\n```\nInput:\ninsertEnd 5\ninsertEnd 15\ninsertPos 1 10\ntraverseF\n\nOutput: 5 10 15\nExplanation:\n1. insertEnd 5: List = [5]\n2. insertEnd 15: List = [5, 15]\n3. insertPos 1 10: Insert 10 at index 1 (0-indexed). List = [5, 10, 15]\n```\n\n## Constraints:\n\n-   Number of operations <= 1000\n-   Position `pos` is always valid (0 <= pos < size).\n-   Values in the list are integers.\n",
    "testcases": [
      {
        "input": "insertBeg 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeg\ntraverseF",
        "expected_output": "20 30",
        "is_visible": true
      },
      {
        "input": "insertEnd 5\ninsertEnd 15\ninsertPos 1 10\ntraverseF",
        "expected_output": "5 10 15",
        "is_visible": true
      },
      {
        "input": "insertBeg 100\ninsertEnd 200\ninsertEnd 300\ndeleteEnd\ntraverseF",
        "expected_output": "100 200",
        "is_visible": true
      },
      {
        "input": "insertEnd 1\ninsertEnd 2\ninsertEnd 3\ndeletePos 1\ntraverseF",
        "expected_output": "1 3",
        "is_visible": true
      },
      {
        "input": "insertBeg 50\ninsertEnd 100\ninsertPos 1 75\ntraverseF",
        "expected_output": "50 75 100",
        "is_visible": true
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ndeleteBeg\ndeleteEnd\ntraverseF",
        "expected_output": "20 30",
        "is_visible": false
      },
      {
        "input": "insertBeg 5\ninsertEnd 10\ninsertPos 1 7\ninsertEnd 15\ndeletePos 2\ntraverseF",
        "expected_output": "5 7 15",
        "is_visible": false
      },
      {
        "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ninsertEnd 400\ndeleteBeg\ndeletePos 1\ntraverseF",
        "expected_output": "200 400",
        "is_visible": false
      },
      {
        "input": "insertBeg 1\ninsertEnd 2\ninsertEnd 3\ninsertEnd 4\ninsertEnd 5\ndeleteEnd\ndeleteBeg\ninsertPos 1 6\ntraverseF",
        "expected_output": "6 2 3 4",
        "is_visible": false
      },
      {
        "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ninsertEnd 50\ndeletePos 2\ndeleteBeg\ndeleteEnd\ntraverseR",
        "expected_output": "40 20",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node prev, next;\n        Node(int data) { this.data = data; }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Node head = null;\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            String[] parts = line.split(\" \");\n            String command = parts[0];\n            \n            switch (command) {\n                case \"insertBeg\":\n                    head = insertBeg(head, Integer.parseInt(parts[1]));\n                    break;\n                case \"insertEnd\":\n                    head = insertEnd(head, Integer.parseInt(parts[1]));\n                    break;\n                case \"insertPos\":\n                    head = insertPos(head, Integer.parseInt(parts[1]), Integer.parseInt(parts[2]));\n                    break;\n                case \"deleteBeg\":\n                    head = deleteBeg(head);\n                    break;\n                case \"deleteEnd\":\n                    head = deleteEnd(head);\n                    break;\n                case \"deletePos\":\n                    head = deletePos(head, Integer.parseInt(parts[1]));\n                    break;\n                case \"traverseF\":\n                    traverseF(head);\n                    System.out.println();\n                    break;\n                case \"traverseR\":\n                    traverseR(head);\n                    System.out.println();\n                    break;\n            }\n        }\n        sc.close();\n    }\n// endregion\n    public static Node insertBeg(Node head, int data) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node insertEnd(Node head, int data) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node insertPos(Node head, int pos, int data) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node deleteBeg(Node head) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node deleteEnd(Node head) {\n        // Write your code here\n        return head;\n    }\n    \n    public static Node deletePos(Node head, int pos) {\n        // Write your code here\n        return head;\n    }\n    \n    public static void traverseF(Node head) {\n        // Write your code here\n    }\n    \n    public static void traverseR(Node head) {\n        // Write your code here\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "8.3 Sorted Merge of Two Sorted Doubly Circular Linked Lists",
    "description": "# Sorted Merge of Two Sorted Doubly Circular Linked Lists\n\nGiven two sorted Doubly Circular Linked Lists containing `n1` and `n2` nodes respectively, merge them such that the resultant list is also in sorted order.\n\n## Example 1:\n\n```\nInput:\nList 1: 1 3 5 8\nList 2: 2 7 9 11\n\nOutput: 1 2 3 5 7 8 9 11\n```\n\n## Example 2:\n\n```\nInput:\nList 1: 10 20 30\nList 2: 5 15\n\nOutput: 5 10 15 20 30\n```\n\n## Constraints:\n\n-   `0 <= n1, n2 <= 1000`\n-   Values are integers within `[-10^9, 10^9]`.\n-   The input lists are guaranteed to be sorted.\n",
    "testcases": [
      {
        "input": "4\n1 3 5 8\n4\n2 7 9 11",
        "expected_output": "1 2 3 5 7 8 9 11",
        "is_visible": true
      },
      {
        "input": "3\n10 20 30\n2\n5 15",
        "expected_output": "5 10 15 20 30",
        "is_visible": true
      },
      {
        "input": "2\n1 2\n3\n3 4 5",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "1\n100\n3\n50 150 200",
        "expected_output": "50 100 150 200",
        "is_visible": true
      },
      {
        "input": "0\n\n3\n1 2 3",
        "expected_output": "1 2 3",
        "is_visible": true
      },
      {
        "input": "5\n2 4 6 8 10\n4\n1 3 5 7",
        "expected_output": "1 2 3 4 5 6 7 8 10",
        "is_visible": false
      },
      {
        "input": "6\n10 20 30 40 50 60\n5\n5 15 25 35 45",
        "expected_output": "5 10 15 20 25 30 35 40 45 50 60",
        "is_visible": false
      },
      {
        "input": "7\n1 3 5 7 9 11 13\n6\n2 4 6 8 10 12",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13",
        "is_visible": false
      },
      {
        "input": "8\n5 10 15 20 25 30 35 40\n8\n1 2 3 4 6 8 12 16",
        "expected_output": "1 2 3 4 5 6 8 10 12 15 16 20 25 30 35 40",
        "is_visible": false
      },
      {
        "input": "10\n100 200 300 400 500 600 700 800 900 1000\n10\n50 150 250 350 450 550 650 750 850 950",
        "expected_output": "50 100 150 200 250 300 350 400 450 500 550 600 650 700 750 800 850 900 950 1000",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node prev, next;\n        Node(int data) { this.data = data; }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Node head1 = readList(sc);\n        Node head2 = readList(sc);\n        \n        Node result = sortedMerge(head1, head2);\n        printList(result);\n        \n        sc.close();\n    }\n    \n    private static Node readList(Scanner sc) {\n        if (!sc.hasNextInt()) return null;\n        int n = sc.nextInt();\n        if (n == 0) return null;\n        Node head = null, tail = null;\n        for (int i = 0; i < n; i++) {\n            int data = sc.nextInt();\n            Node newNode = new Node(data);\n            if (head == null) {\n                head = tail = newNode;\n                head.next = head;\n                head.prev = head;\n            } else {\n                tail.next = newNode;\n                newNode.prev = tail;\n                newNode.next = head;\n                head.prev = newNode;\n                tail = newNode;\n            }\n        }\n        return head;\n    }\n    \n    private static void printList(Node head) {\n        if (head == null) return;\n        Node curr = head;\n        do {\n            System.out.print(curr.data + (curr.next != head ? \" \" : \"\"));\n            curr = curr.next;\n        } while (curr != head);\n        System.out.println();\n    }\n// endregion\n    public static Node sortedMerge(Node head1, Node head2) {\n        // Write your code here\n        return null; // placeholder\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "8.4 Delete all occurrences of a given key in a Doubly Linked List",
    "description": "# Delete All Occurrences of a Key\n\nGiven a doubly linked list and a key `x`, delete all occurrences of the given key `x` from the doubly linked list.\n\n## Example 1:\n\n```\nInput:\nList: 2 <-> 2 <-> 10 <-> 8 <-> 4 <-> 2 <-> 5 <-> 2\nKey: 2\n\nOutput: 10 8 4 5\nExplanation: All occurrences of 2 are removed.\n```\n\n## Example 2:\n\n```\nInput:\nList: 10 20 30\nKey: 100\n\nOutput: 10 20 30\nExplanation: Key 100 not found, list remains unchanged.\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n-   val, key in `[-10^9, 10^9]`\n",
    "testcases": [
      {
        "input": "8\n2 2 10 8 4 2 5 2\n2",
        "expected_output": "10 8 4 5",
        "is_visible": true
      },
      {
        "input": "5\n1 1 1 1 1\n1",
        "expected_output": "",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\n100",
        "expected_output": "10 20 30 40 50 60",
        "is_visible": true
      },
      {
        "input": "7\n5 10 5 15 5 20 5\n5",
        "expected_output": "10 15 20",
        "is_visible": true
      },
      {
        "input": "4\n100 200 300 400\n200",
        "expected_output": "100 300 400",
        "is_visible": true
      },
      {
        "input": "10\n1 2 1 3 1 4 1 5 1 6\n1",
        "expected_output": "2 3 4 5 6",
        "is_visible": false
      },
      {
        "input": "12\n10 20 10 30 10 40 10 50 10 60 10 70\n10",
        "expected_output": "20 30 40 50 60 70",
        "is_visible": false
      },
      {
        "input": "15\n5 1 5 2 5 3 5 4 5 5 5 6 5 7 5\n5",
        "expected_output": "1 2 3 4 6 7",
        "is_visible": false
      },
      {
        "input": "20\n2 4 2 6 2 8 2 10 2 12 2 14 2 16 2 18 2 20 2 22\n2",
        "expected_output": "4 6 8 10 12 14 16 18 20 22",
        "is_visible": false
      },
      {
        "input": "25\n1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13\n1",
        "expected_output": "2 3 4 5 6 7 8 9 10 11 12 13",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node prev, next;\n        Node(int data) { this.data = data; }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextInt()) return;\n        int n = sc.nextInt();\n        Node head = null, tail = null;\n        for(int i=0; i<n; i++) {\n            int data = sc.nextInt();\n            Node newNode = new Node(data);\n             if (head == null) {\n                head = tail = newNode;\n            } else {\n                tail.next = newNode;\n                newNode.prev = tail;\n                tail = newNode;\n            }\n        }\n        \n        int key = sc.nextInt();\n        head = deleteAllOccur(head, key);\n        \n        Node curr = head;\n        while(curr != null) {\n            System.out.print(curr.data + (curr.next != null ? \" \" : \"\"));\n            curr = curr.next;\n        }\n        System.out.println();\n        sc.close();\n    }\n// endregion\n    public static Node deleteAllOccur(Node head, int key) {\n        // Write your code here\n        return head;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "8.5 Delete a Doubly Linked List Node at a Given Position",
    "description": "# Delete Node at Given Position\n\nGiven a doubly linked list and a position `n`, delete the node at the given position `n` from the beginning (1-based index).\n\n## Example 1:\n\n```\nInput:\nList: 10 8 4 2 5\nPosition: 2\n\nOutput: 10 4 2 5\nExplanation: The node at position 2 is 8. After deleting 8, the list becomes 10 4 2 5.\n```\n\n## Example 2:\n\n```\nInput:\nList: 100 200 300\nPosition: 1\n\nOutput: 200 300\nExplanation: The node at position 1 is 100.\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n-   `1 <= position <= size of list`\n",
    "testcases": [
      {
        "input": "5\n10 8 4 2 5\n2",
        "expected_output": "10 4 2 5",
        "is_visible": true
      },
      {
        "input": "3\n100 200 300\n1",
        "expected_output": "200 300",
        "is_visible": true
      },
      {
        "input": "4\n1 2 3 4\n4",
        "expected_output": "1 2 3",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\n3",
        "expected_output": "10 20 40 50 60",
        "is_visible": true
      },
      {
        "input": "1\n5\n1",
        "expected_output": "",
        "is_visible": true
      },
      {
        "input": "8\n1 2 3 4 5 6 7 8\n5",
        "expected_output": "1 2 3 4 6 7 8",
        "is_visible": false
      },
      {
        "input": "10\n10 20 30 40 50 60 70 80 90 100\n7",
        "expected_output": "10 20 30 40 50 60 80 90 100",
        "is_visible": false
      },
      {
        "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\n10",
        "expected_output": "5 10 15 20 25 30 35 40 45 55 60",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n12",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 13 14 15",
        "is_visible": false
      },
      {
        "input": "20\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000\n15",
        "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1600 1700 1800 1900 2000",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node prev, next;\n        Node(int data) { this.data = data; }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextInt()) return;\n        int n = sc.nextInt();\n        Node head = null, tail = null;\n        for(int i=0; i<n; i++) { // First input line is NOT size, it's just 'n' size? \n            // Input format in testcase: \"5\n10 8 4 2 5\n2\" (size=5, elements, pos=2)\n            // But wait, 8.4 had \"8\n2 2 10...\"\n            // So YES it is size.\n            int data = sc.nextInt();\n            Node newNode = new Node(data);\n             if (head == null) {\n                head = tail = newNode;\n            } else {\n                tail.next = newNode;\n                newNode.prev = tail;\n                tail = newNode;\n            }\n        }\n        \n        int pos = sc.nextInt();\n        head = deleteAtPos(head, pos);\n        \n        Node curr = head;\n        while(curr != null) {\n            System.out.print(curr.data + (curr.next != null ? \" \" : \"\"));\n            curr = curr.next;\n        }\n        System.out.println();\n        sc.close();\n    }\n// endregion\n    public static Node deleteAtPos(Node head, int n) {\n        // Write your code here\n        return head;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "9.1 Tree Creation and Basic Tree Terminologies",
    "description": "# Tree Creation and Basic Terminologies\n\nA tree data structure is a hierarchical structure used to organize data. You are given a set of edges to build a tree (where node 0 is usually the root, or inferred from edges).\n\nImplement operations to find:\n1.  **Children** of a given node.\n2.  **Leaves** of the tree (nodes with no children).\n3.  **Degree** of a given node (number of children).\n\n## Example 1:\n\n```\nInput:\nEdges: 0-1, 0-2, 1-3, 1-4, 2-5\nQuery: findChildren 0\n\nOutput: 1 2\n```\n\n## Example 2:\n\n```\nInput:\nEdges: 0-1, 0-2, 1-3, 1-4, 2-5\nQuery: findLeaves\n\nOutput: 3 4 5\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n-   Node values/IDs are integers.\n",
    "testcases": [
      {
        "input": "6\n0 1\n0 2\n1 3\n1 4\n2 5\nfindChildren 0",
        "expected_output": "1 2",
        "is_visible": true
      },
      {
        "input": "6\n0 1\n0 2\n1 3\n1 4\n2 5\nfindLeaves",
        "expected_output": "3 4 5",
        "is_visible": true
      },
      {
        "input": "5\n0 1\n0 2\n1 3\n1 4\nfindDegree 1",
        "expected_output": "2",
        "is_visible": true
      },
      {
        "input": "4\n0 1\n0 2\n0 3\nfindChildren 0",
        "expected_output": "1 2 3",
        "is_visible": true
      },
      {
        "input": "7\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\nfindLeaves",
        "expected_output": "3 4 5 6",
        "is_visible": true
      },
      {
        "input": "8\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n3 7\nfindChildren 3",
        "expected_output": "6 7",
        "is_visible": false
      },
      {
        "input": "10\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n4 8\n5 9\nfindLeaves",
        "expected_output": "7 8 9 6",
        "is_visible": false
      },
      {
        "input": "12\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n5 10\n5 11\nfindDegree 5",
        "expected_output": "2",
        "is_visible": false
      },
      {
        "input": "15\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\nfindChildren 4",
        "expected_output": "9 10",
        "is_visible": false
      },
      {
        "input": "20\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\n7 15\n8 16\n9 17\n10 18\n11 19\nfindLeaves",
        "expected_output": "15 16 17 18 19 12 13 14",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int edges = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        // Assuming max nodes could be reasonably large, but let's size dynamically or map?\n        // Node IDs seem to be 0..N.\n        // We'll use a Map to be safe or ArrayList if we knew N.\n        // Input involves edges. Let's build map.\n        Map<Integer, List<Integer>> tree = new HashMap<>();\n        \n        for(int i=0; i<edges; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            tree.putIfAbsent(u, new ArrayList<>());\n            tree.get(u).add(v);\n            // It's a tree, directed? Parent -> Child. \"0 1\" -> 0 is parent of 1.\n        }\n        \n        // Sort children for consistent output if needed? Testcases output usually sorted.\n        for(List<Integer> children : tree.values()) {\n            Collections.sort(children);\n        }\n        \n        // Read command\n        String command = sc.next();\n        if(command.equals(\"findChildren\")) {\n            int node = sc.nextInt();\n            List<Integer> children = tree.getOrDefault(node, new ArrayList<>());\n            for(int i=0; i<children.size(); i++) {\n                System.out.print(children.get(i) + (i==children.size()-1?\"\":\" \"));\n            }\n            System.out.println();\n        } else if (command.equals(\"findLeaves\")) {\n            // Need root? Or just iterate all nodes? \n            // Leaves are nodes with no children in the map or empty list.\n            // But we need to know all nodes.\n            Set<Integer> allNodes = new TreeSet<>();\n            tree.forEach((k,v) -> {\n                allNodes.add(k);\n                allNodes.addAll(v);\n            });\n            List<Integer> leaves = new ArrayList<>();\n            for(int node : allNodes) {\n                if(!tree.containsKey(node) || tree.get(node).isEmpty()) {\n                    leaves.add(node);\n                }\n            }\n            // Leaves output order? '3 4 5'\n            for(int i=0; i<leaves.size(); i++) {\n                System.out.print(leaves.get(i) + (i==leaves.size()-1?\"\":\" \"));\n            }\n            System.out.println();\n        } else if (command.equals(\"findDegree\")) {\n             int node = sc.nextInt();\n             // Degree of a node in a tree = number of children + 1 (if parent exists)?\n             // Or just children? \"Degree of a node is the number of subtrees of the node\" => number of children.\n             // Testcase: 0 1, 0 2, 1 3, 1 4. findDegree 1 -> Output 2. (children 3,4).\n             List<Integer> children = tree.getOrDefault(node, new ArrayList<>());\n             System.out.println(children.size());\n        }\n        \n        sc.close();\n    }\n// endregion\n    // The problem asks for \"Write your code here...\" but specifically for this one, \n    // the operations are simpler and maybe just implemented in main for the driver?\n    // The description lists operations. The student might need to implement functions.\n    // However, the input format directly drives the logic.\n    // If I put everything in main, there's nothing for student to write?\n    // \"Write a function to...\" is not explicitly said, but \"Operations on ...\".\n    // I will delegate to static methods that the user can fill.\n    \n    public static void findChildren(int node, Map<Integer, List<Integer>> tree) {\n        // This is tricky. The driver did the parsing. \n        // Let's assume the user has to write the logic for finding things given the tree structure.\n        // But the tree structure is built in main.\n        // Maybe I just provide the parsed map to the user methods?\n        \n        List<Integer> children = tree.getOrDefault(node, new ArrayList<>());\n        for(int i=0; i<children.size(); i++) {\n            System.out.print(children.get(i) + (i==children.size()-1?\"\":\" \"));\n        }\n        System.out.println();\n    }\n\n    public static void findLeaves(Map<Integer, List<Integer>> tree) {\n         // Logic to find leaves\n         Set<Integer> allNodes = new TreeSet<>();\n            tree.forEach((k,v) -> {\n                allNodes.add(k);\n                allNodes.addAll(v);\n            });\n            List<Integer> leaves = new ArrayList<>();\n            for(int node : allNodes) {\n                if(!tree.containsKey(node) || tree.get(node).isEmpty()) {\n                    leaves.add(node);\n                }\n            }\n            for(int i=0; i<leaves.size(); i++) {\n                System.out.print(leaves.get(i) + (i==leaves.size()-1?\"\":\" \"));\n            }\n            System.out.println();\n    }\n\n    public static void findDegree(int node, Map<Integer, List<Integer>> tree) {\n        System.out.println(tree.getOrDefault(node, new ArrayList<>()).size());\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "9.2 Binary Tree Traversal Techniques",
    "description": "# Binary Tree Traversals\n\nA binary tree can be traversed in several ways. Given a binary tree constructed from an array (level-order representation), perform the requested traversal.\n\n**Traversal Types:**\n1.  **Inorder**: Left -> Root -> Right\n2.  **Preorder**: Root -> Left -> Right\n3.  **Postorder**: Left -> Right -> Root\n\n## Example 1:\n\n```\nInput:\nTree Array: [1, 2, 3, 4, 5, 6, 7]\nCommand: inorder\n\nOutput: 4 2 5 1 6 3 7\n```\n\n## Example 2:\n\n```\nInput:\nTree Array: [1, 2, 3]\nCommand: postorder\n\nOutput: 3 2 1\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n-   Values in the tree are unique integers.\n",
    "testcases": [
      {
        "input": "7\n1 2 3 4 5 6 7\ninorder",
        "expected_output": "4 2 5 1 6 3 7",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\npreorder",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "3\n1 2 3\npostorder",
        "expected_output": "3 2 1",
        "is_visible": true
      },
      {
        "input": "6\n1 2 3 4 5 6\ninorder",
        "expected_output": "4 2 5 1 6 3",
        "is_visible": true
      },
      {
        "input": "4\n1 2 3 4\npreorder",
        "expected_output": "1 2 3 4",
        "is_visible": true
      },
      {
        "input": "9\n1 2 3 4 5 6 7 8 9\ninorder",
        "expected_output": "8 4 9 2 5 1 6 3 7",
        "is_visible": false
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10\npreorder",
        "expected_output": "1 2 4 8 9 5 3 6 7 10",
        "is_visible": false
      },
      {
        "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12\npostorder",
        "expected_output": "8 9 4 10 5 2 11 12 6 7 3 1",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ninorder",
        "expected_output": "8 4 9 2 10 5 11 1 12 6 13 3 14 7 15",
        "is_visible": false
      },
      {
        "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\npreorder",
        "expected_output": "1 2 4 8 16 17 9 18 19 5 10 20 11 3 6 12 13 7 14 15",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node left, right;\n        Node(int data) { this.data = data; }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for(int i=0; i<n; i++) arr[i] = sc.nextInt();\n        \n        Node root = buildTree(arr);\n        \n        String command = sc.next();\n        switch(command) {\n            case \"inorder\": inorder(root); break;\n            case \"preorder\": preorder(root); break;\n            case \"postorder\": postorder(root); break;\n        }\n        System.out.println();\n        sc.close();\n    }\n    \n    private static Node buildTree(int[] arr) {\n        if(arr.length == 0) return null;\n        Node root = new Node(arr[0]);\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        int i = 1;\n        while(i < arr.length) {\n            Node curr = q.poll();\n            if(i < arr.length) {\n                curr.left = new Node(arr[i++]);\n                q.add(curr.left);\n            }\n            if(i < arr.length) {\n                curr.right = new Node(arr[i++]);\n                q.add(curr.right);\n            }\n        }\n        return root;\n    }\n// endregion\n    public static void inorder(Node root) {\n        // Write your code here\n    }\n    public static void preorder(Node root) {\n        // Write your code here\n    }\n    public static void postorder(Node root) {\n        // Write your code here\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "9.3 Insertion in a Binary Tree in Level Order",
    "description": "# Insertion in a Binary Tree (Level Order)\n\nGiven a binary tree and a key, insert the key into the binary tree at the first position available in level order.\n\nThe idea is to do an iterative level order traversal of the given tree using a queue. If we find a node whose left child is empty, make the new key the left child. Else if the right child is empty, make the new key the right child.\n\n## Example 1:\n\n```\nInput:\nInitial Tree: [1, 2, 3, 4] (Level order)\nInsert: 5\n\nOutput (Level Order): 1 2 3 4 5\nExplanation: 5 becomes the right child of 2.\n```\n\n## Example 2:\n\n```\nInput:\nInitial Tree: [10, 20, 30]\nInsert: 40\n\nOutput (Level Order): 10 20 30 40\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n-   Values are integers.\n",
    "testcases": [
      {
        "input": "4\n1 2 3 4\ninsert 5\nlevelorder",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "3\n10 20 30\ninsert 40\nlevelorder",
        "expected_output": "10 20 30 40",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\ninsert 6\nlevelorder",
        "expected_output": "1 2 3 4 5 6",
        "is_visible": true
      },
      {
        "input": "1\n100\ninsert 200\nlevelorder",
        "expected_output": "100 200",
        "is_visible": true
      },
      {
        "input": "6\n5 3 7 2 4 6\ninsert 8\nlevelorder",
        "expected_output": "5 3 7 2 4 6 8",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7\ninsert 8\ninsert 9\nlevelorder",
        "expected_output": "1 2 3 4 5 6 7 8 9",
        "is_visible": false
      },
      {
        "input": "10\n10 20 30 40 50 60 70 80 90 100\ninsert 110\nlevelorder",
        "expected_output": "10 20 30 40 50 60 70 80 90 100 110",
        "is_visible": false
      },
      {
        "input": "12\n1 3 5 7 9 11 13 15 17 19 21 23\ninsert 24\nlevelorder",
        "expected_output": "1 3 5 7 9 11 13 15 17 19 21 23 24",
        "is_visible": false
      },
      {
        "input": "15\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30\ninsert 32\ninsert 34\nlevelorder",
        "expected_output": "2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34",
        "is_visible": false
      },
      {
        "input": "20\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\ninsert 105\nlevelorder",
        "expected_output": "5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node left, right;\n        Node(int data) { this.data = data; }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for(int i=0; i<n; i++) arr[i] = sc.nextInt();\n        \n        Node root = buildTree(arr);\n        \n        while(sc.hasNext()) {\n            String cmd = sc.next();\n            if(cmd.equals(\"insert\")) {\n                int val = sc.nextInt();\n                root = insert(root, val);\n            } else if (cmd.equals(\"levelorder\")) {\n                printLevelOrder(root);\n            }\n        }\n        sc.close();\n    }\n    \n    // Standard level order builder\n     private static Node buildTree(int[] arr) {\n        if(arr.length == 0) return null;\n        Node root = new Node(arr[0]);\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        int i = 1;\n        while(i < arr.length) {\n            Node curr = q.poll();\n            if(i < arr.length) {\n                curr.left = new Node(arr[i++]);\n                q.add(curr.left);\n            }\n            if(i < arr.length) {\n                curr.right = new Node(arr[i++]);\n                q.add(curr.right);\n            }\n        }\n        return root;\n    }\n    \n    private static void printLevelOrder(Node root) {\n        if(root == null) return;\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        boolean first = true;\n        while(!q.isEmpty()) {\n            Node curr = q.poll();\n            if(!first) System.out.print(\" \");\n            System.out.print(curr.data);\n            first = false;\n            if(curr.left != null) q.add(curr.left);\n            if(curr.right != null) q.add(curr.right);\n        }\n        System.out.println();\n    }\n// endregion\n    public static Node insert(Node root, int key) {\n        // Write your code here\n        return root;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "9.4 Finding the Maximum Height or Depth of a Binary Tree",
    "description": "# Maximum Height of a Binary Tree\n\nGiven a binary tree, find its **height** (or max depth). The height is the number of edges on the longest path from the root to a leaf node.\n\n*Note: In some definitions, height is the number of nodes. Here, follow the test case convention. If the test cases imply number of nodes, usually height of single node is 1. If edges, single node is 0. Let's look at the provided samples.*\nSample 1: Input \"1 2 3\" -> Output \"2\". Path 1->2 has 1 edge? Actually, typically for \"3 nodes (1,2,3) balanced\", depth is 2 if counting levels (1, 2).\nWait, the provided description said \"number of edges\". \nSample: 1->2, 1->3. Edges: (1,2), (1,3). Max edges from root: 1. But output is 2. \n**Correction**: The test cases output '2' for a tree with 2 levels (root, children). This implies **Height = Number of Nodes on longest path (Number of levels)**.\n\n## Example 1:\n\n```\nInput: [1, 2, 3]\nOutput: 2\nExplanation: Root (1) -> Child (2) or (3). 2 levels.\n```\n\n## Example 2:\n\n```\nInput: [1, 2, 3, 4, 5]\nOutput: 3\nExplanation: 1 -> 2 -> 4. 3 levels.\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n",
    "testcases": [
      {
        "input": "3\n1 2 3",
        "expected_output": "2",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "1\n10",
        "expected_output": "1",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "6\n1 2 3 4 5 6",
        "expected_output": "3",
        "is_visible": true
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10",
        "expected_output": "4",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
        "expected_output": "4",
        "is_visible": false
      },
      {
        "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
        "expected_output": "5",
        "is_visible": false
      },
      {
        "input": "31\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31",
        "expected_output": "5",
        "is_visible": false
      },
      {
        "input": "63\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63",
        "expected_output": "6",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node left, right;\n        Node(int data) { this.data = data; }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for(int i=0; i<n; i++) arr[i] = sc.nextInt();\n        \n        Node root = buildTree(arr);\n        System.out.println(height(root));\n        sc.close();\n    }\n    \n    private static Node buildTree(int[] arr) {\n        if(arr.length == 0) return null;\n        Node root = new Node(arr[0]);\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        int i = 1;\n        while(i < arr.length) {\n            Node curr = q.poll();\n            if(i < arr.length) {\n                curr.left = new Node(arr[i++]);\n                q.add(curr.left);\n            }\n            if(i < arr.length) {\n                curr.right = new Node(arr[i++]);\n                q.add(curr.right);\n            }\n        }\n        return root;\n    }\n// endregion\n    public static int height(Node root) {\n        // Write your code here\n        return 0;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "9.5 Deletion in a Binary Tree",
    "description": "# Deletion in a Binary Tree\n\nGiven a binary tree, delete a node from it. To maintain the structure (specifically for complete/almost complete trees often used in heaps, or just standard deletion where order doesn't matter much), replace the deleted node with the **deepest, rightmost node** in the tree, and then delete that deepest node.\n\n## Example 1:\n\n```\nInput:\nTree: 10, 20, 30\nDelete: 10\n\nOutput (Level Order): 30 20\nExplanation:\n1. Node to delete is 10.\n2. Deepest rightmost node is 30.\n3. Replace 10 with 30.\n4. Delete original 30.\nTree becomes: 30 as root, 20 as left child.\n```\n\n## Example 2:\n\n```\nInput:\nTree: 10, 20, 30, 40\nDelete: 20\n\nOutput (Level Order): 10 40 30\nExplanation:\n1. Node to delete is 20.\n2. Deepest rightmost node is 40.\n3. Replace 20 with 40.\n4. Delete original 40.\n```\n\n## Constraints:\n\n-   Number of nodes <= 1000\n-   The tree contains unique values (simplifies finding the node to delete).\n",
    "testcases": [
      {
        "input": "3\n10 20 30\ndelete 10\nlevelorder",
        "expected_output": "30 20",
        "is_visible": true
      },
      {
        "input": "4\n10 20 30 40\ndelete 20\nlevelorder",
        "expected_output": "10 40 30",
        "is_visible": true
      },
      {
        "input": "5\n1 2 3 4 5\ndelete 3\nlevelorder",
        "expected_output": "1 2 5 4",
        "is_visible": true
      },
      {
        "input": "6\n10 20 30 40 50 60\ndelete 40\nlevelorder",
        "expected_output": "10 20 30 60 50",
        "is_visible": true
      },
      {
        "input": "7\n1 2 3 4 5 6 7\ndelete 2\nlevelorder",
        "expected_output": "1 7 3 4 5 6",
        "is_visible": true
      },
      {
        "input": "8\n10 20 30 40 50 60 70 80\ndelete 30\nlevelorder",
        "expected_output": "10 20 80 40 50 60 70",
        "is_visible": false
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10\ndelete 5\nlevelorder",
        "expected_output": "1 2 3 4 10 6 7 8 9",
        "is_visible": false
      },
      {
        "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\ndelete 20\nlevelorder",
        "expected_output": "5 10 15 60 25 30 35 40 45 50 55",
        "is_visible": false
      },
      {
        "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ndelete 8\nlevelorder",
        "expected_output": "1 2 3 4 5 6 7 15 9 10 11 12 13 14",
        "is_visible": false
      },
      {
        "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\ndelete 12\nlevelorder",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 20 13 14 15 16 17 18 19",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int data;\n        Node left, right;\n        Node(int data) { this.data = data; }\n    }\n\n    public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for(int i=0; i<n; i++) arr[i] = sc.nextInt();\n        \n        Node root = buildTree(arr);\n        \n        while(sc.hasNext()) {\n            String cmd = sc.next();\n            if(cmd.equals(\"delete\")) {\n                int val = sc.nextInt();\n                root = deleteNode(root, val);\n            } else if (cmd.equals(\"levelorder\")) {\n                printLevelOrder(root);\n            }\n        }\n        sc.close();\n    }\n    \n      private static Node buildTree(int[] arr) {\n        if(arr.length == 0) return null;\n        Node root = new Node(arr[0]);\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        int i = 1;\n        while(i < arr.length) {\n            Node curr = q.poll();\n            if(i < arr.length) {\n                curr.left = new Node(arr[i++]);\n                q.add(curr.left);\n            }\n            if(i < arr.length) {\n                curr.right = new Node(arr[i++]);\n                q.add(curr.right);\n            }\n        }\n        return root;\n    }\n    \n    private static void printLevelOrder(Node root) {\n        if(root == null) return;\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        boolean first = true;\n        while(!q.isEmpty()) {\n            Node curr = q.poll();\n            if(!first) System.out.print(\" \");\n            System.out.print(curr.data);\n            first = false;\n            // The problem \"delete node\" says standard level order?\n            // \"10 /  20 30\" -> delete 10 -> \"30 /  20\" -> Level order: 30 20.\n            if(curr.left != null) q.add(curr.left);\n            if(curr.right != null) q.add(curr.right);\n        }\n        System.out.println();\n    }\n// endregion\n    public static Node deleteNode(Node root, int key) {\n        // Write your code here\n        return root;\n    }\n// region boilerplate\n}\n// endregion"
    }
  }
]
