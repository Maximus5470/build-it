[
  {
    "title": "4.3 Heap Sort",
    "description": "# 4.3 Heap Sort\n\nHeap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements. Heap Sort Procedure: First convert the array into heap data structure using heapify, then one by one delete the root node of the Max-heap and replace it with the last node in the heap and then heapify the root of the heap. Repeat this process until size of heap is greater than 1. Build a heap from the given input array. Repeat the following steps until the heap contains only one element: - Swap the root element of the heap (which is the largest element) with the last element of the heap. - Remove the last element of the heap (which is now in the correct position). - Heapify the remaining elements of the heap. - The sorted array is obtained by reversing the order of the elements in the input array.\n\n## Example 1:\n\n```\n\n## Example 1:\n\n```\nInput: 6 12 11 13 5 6 7\nOutput: 5 6 7 11 12 13\n```\n\n## Example 2:\n\n```\nInput: 8 4 10 3 5 1 2 8 7\nOutput: 1 2 3 4 5 7 8 10\n```\n\n## Example 3:\n\n```\nInput: 5 20 10 30 5 15\nOutput: 5 10 15 20 30\n```\n\n## Constraints:\n\n- `1 <= arr.length <= 10^5`\n- `-10^9 <= arr[i] <= 10^9`\n",
    "testcases": [
      {
        "input": "6\n12 11 13 5 6 7",
        "expected_output": "5 6 7 11 12 13",
        "is_visible": true
      },
      {
        "input": "8\n4 10 3 5 1 2 8 7",
        "expected_output": "1 2 3 4 5 7 8 10",
        "is_visible": true
      },
      {
        "input": "5\n20 10 30 5 15",
        "expected_output": "5 10 15 20 30",
        "is_visible": true
      },
      {
        "input": "7\n100 50 25 75 125 150 100",
        "expected_output": "25 50 75 100 100 125 150",
        "is_visible": true
      },
      {
        "input": "9\n9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9",
        "is_visible": true
      },
      {
        "input": "10\n45 23 67 12 89 34 78 56 90 11",
        "expected_output": "11 12 23 34 45 56 67 78 89 90",
        "is_visible": false
      },
      {
        "input": "12\n33 11 55 22 77 44 99 66 88 110 121 132",
        "expected_output": "11 22 33 44 55 66 77 88 99 110 121 132",
        "is_visible": false
      },
      {
        "input": "15\n5 1 9 2 8 3 7 4 6 10 15 12 13 11 14",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
        "is_visible": false
      },
      {
        "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
        "is_visible": false
      },
      {
        "input": "25\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
        "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (sc.hasNextInt()) {\n                    arr[i] = sc.nextInt();\n                }\n            }\n            sort(arr);\n            for (int i = 0; i < n; i++) {\n                System.out.print(arr[i] + (i < n - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static void sort(int[] arr) {\n        // Write your code here...\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "4.4 Radix Sort",
    "description": "# 4.4 Radix Sort\n\nRadix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. Rather than comparing elements directly, Radix Sort distributes the elements into buckets based on each digit's value. By repeatedly sorting the elements by their significant digits, from the least significant to the most significant, Radix Sort achieves the final sorted order. Radix Sort Procedure: The key idea behind Radix Sort is to exploit the concept of place value. 1. It assumes that sorting numbers digit by digit will eventually result in a fully sorted list. 2. Radix Sort can be performed using different variations, such as Least Significant Digit (LSD) Radix Sort or Most Significant Digit (MSD) Radix Sort. To perform radix sort on the array [170, 45, 75, 90, 802, 24, 2, 66], we follow these steps: Step 1: Find the largest element in the array, which is 802. It has three digits, so we will iterate three times, once for each significant place. Step 2: Sort the elements based on the unit place digits (X=0). We use a stable sorting technique, such as counting sort, to sort the digits at each significant place. Sorting based on the unit place: Perform counting sort on the array based on the unit place digits. The sorted array based on the unit place is [170, 90, 802, 2, 24, 45, 75, 66] Sorting based on unit digit Unsorted Sorted For Unit Digit Step 3: Sort the elements based on the tens place digits. Sorting based on the tens place: Perform counting sort on the array based on the tens place digits. The sorted array based on the tens place is [802, 2, 24, 45, 66, 170, 75, 90] Sorting based on 10's digit Unsorted Sorted Till 10'S Digit Step 4: Sort the elements based on the hundreds place digits. Sorting based on the hundreds place: Perform counting sort on the array based on the hundreds place digits. The sorted array based on the hundreds place is [2, 24, 45, 66, 75, 90, 170, 802] Step 5: The array is now sorted in ascending order. The final sorted array using radix sort is [2, 24, 45, 66, 75, 90, 170, 802]\n\n## Example 1:\n\n```\nInput: 8 170 45 75 90 802 24 2 66\nOutput: 2 24 45 66 75 90 170 802\n```\n\n## Example 2:\n\n```\nInput: 6 329 457 657 839 436 720\nOutput: 329 436 457 657 720 839\n```\n\n## Example 3:\n\n```\nInput: 5 50 3 12 45 100\nOutput: 3 12 45 50 100\n```\n\n## Constraints:\n\n- `1 <= arr.length <= 10^5`\n- `-10^9 <= arr[i] <= 10^9`\n",
    "testcases": [
      {
        "input": "8\n170 45 75 90 802 24 2 66",
        "expected_output": "2 24 45 66 75 90 170 802",
        "is_visible": true
      },
      {
        "input": "6\n329 457 657 839 436 720",
        "expected_output": "329 436 457 657 720 839",
        "is_visible": true
      },
      {
        "input": "5\n50 3 12 45 100",
        "expected_output": "3 12 45 50 100",
        "is_visible": true
      },
      {
        "input": "7\n1000 100 10 1 10000 100000 1000000",
        "expected_output": "1 10 100 1000 10000 100000 1000000",
        "is_visible": true
      },
      {
        "input": "9\n9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9",
        "is_visible": true
      },
      {
        "input": "10\n45 23 67 12 89 34 78 56 90 11",
        "expected_output": "11 12 23 34 45 56 67 78 89 90",
        "is_visible": false
      },
      {
        "input": "12\n333 111 555 222 777 444 999 666 888 110 121 132",
        "expected_output": "110 111 121 132 222 333 444 555 666 777 888 999",
        "is_visible": false
      },
      {
        "input": "15\n500 100 900 200 800 300 700 400 600 1000 1500 1200 1300 1100 1400",
        "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500",
        "is_visible": false
      },
      {
        "input": "20\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200",
        "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200",
        "is_visible": false
      },
      {
        "input": "25\n1000 900 800 700 600 500 400 300 200 100 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400 2500",
        "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400 2500",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (sc.hasNextInt()) {\n                    arr[i] = sc.nextInt();\n                }\n            }\n            sort(arr);\n            for (int i = 0; i < n; i++) {\n                System.out.print(arr[i] + (i < n - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static void sort(int[] arr) {\n        // Write your code here...\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "4.5 Shell Sort",
    "description": "# 4.5 Shell Sort\n\nShell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h'th element are sorted. Shell Sort Procedure: 1. Initialize the value of gap size h 2. Divide the list into smaller sub-part. Each must have equal intervals to h 3. Sort these sub-lists using insertion sort 4. Repeat this step 1 until the list is sorted. 5. Print a sorted list.\n\n## Example 1:\n\n```\nInput: 8 23 12 1 5 9 8 10 2\nOutput: 1 2 5 8 9 10 12 23\n```\n\n## Example 2:\n\n```\nInput: 6 64 34 25 12 22 11\nOutput: 11 12 22 25 34 64\n```\n\n## Example 3:\n\n```\nInput: 5 5 1 4 2 3\nOutput: 1 2 3 4 5\n```\n\n## Constraints:\n\n- `1 <= arr.length <= 10^5`\n- `-10^9 <= arr[i] <= 10^9`\n",
    "testcases": [
      {
        "input": "8\n23 12 1 5 9 8 10 2",
        "expected_output": "1 2 5 8 9 10 12 23",
        "is_visible": true
      },
      {
        "input": "6\n64 34 25 12 22 11",
        "expected_output": "11 12 22 25 34 64",
        "is_visible": true
      },
      {
        "input": "5\n5 1 4 2 3",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "7\n100 50 25 75 125 150 100",
        "expected_output": "25 50 75 100 100 125 150",
        "is_visible": true
      },
      {
        "input": "9\n9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9",
        "is_visible": true
      },
      {
        "input": "10\n45 23 67 12 89 34 78 56 90 11",
        "expected_output": "11 12 23 34 45 56 67 78 89 90",
        "is_visible": false
      },
      {
        "input": "12\n33 11 55 22 77 44 99 66 88 110 121 132",
        "expected_output": "11 22 33 44 55 66 77 88 99 110 121 132",
        "is_visible": false
      },
      {
        "input": "15\n5 1 9 2 8 3 7 4 6 10 15 12 13 11 14",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
        "is_visible": false
      },
      {
        "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
        "is_visible": false
      },
      {
        "input": "25\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
        "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (sc.hasNextInt()) {\n                    arr[i] = sc.nextInt();\n                }\n            }\n            sort(arr);\n            for (int i = 0; i < n; i++) {\n                System.out.print(arr[i] + (i < n - 1 ? \" \" : \"\"));\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n// endregion\n    public static void sort(int[] arr) {\n        // Write your code here...\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "5.1 Implementation of Stack",
    "description": "# 5.1 Implementation of Stack\n\nA stack is a linear data structure that stores items in a Last-In/First-Out (LIFO) or First-In/Last-Out (FILO) manner. In stack, a new element is added at one end and an element is removed from that end only. The insert and delete operations are often called push and pop. The functions associated with stack are: empty() - Returns whether the stack is empty size() - Returns the size of the stack top() / peek() - Returns a reference to the topmost element of the stack push(a) - Inserts the element 'a' at the top of the stack pop() - Deletes the topmost element of the stack\n\n## Example 1:\n\n```\nInput: 5 push 10 push 20 push 30 pop peek push 40 push 50 push 60\nOutput: 20\n```\n\n## Example 2:\n\n```\nInput: 3 push 5 push 10 pop\nOutput: 10\n```\n\n## Example 3:\n\n```\nInput: 4 push 100 push 200 pop peek\nOutput: 100\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "5\npush 10\npush 20\npush 30\npop\npeek\npush 40\npush 50\npush 60",
        "expected_output": "20",
        "is_visible": true
      },
      {
        "input": "3\npush 5\npush 10\npop",
        "expected_output": "10",
        "is_visible": true
      },
      {
        "input": "4\npush 100\npush 200\npop\npeek",
        "expected_output": "100",
        "is_visible": true
      },
      {
        "input": "6\npush 1\npush 2\npush 3\npop\npop\npeek",
        "expected_output": "1",
        "is_visible": true
      },
      {
        "input": "5\npush 99\npop\npush 88\npeek\npop",
        "expected_output": "88",
        "is_visible": true
      },
      {
        "input": "8\npush 10\npush 20\npush 30\npop\npush 40\npop\npeek\npush 50",
        "expected_output": "20",
        "is_visible": false
      },
      {
        "input": "10\npush 5\npush 10\npush 15\npop\npush 20\npop\npeek\npush 25\npush 30\npop",
        "expected_output": "15",
        "is_visible": false
      },
      {
        "input": "12\npush 100\npush 200\npush 300\npop\npush 400\npop\npeek\npush 500\npush 600\npop\npeek\npop",
        "expected_output": "200",
        "is_visible": false
      },
      {
        "input": "15\npush 1\npush 2\npush 3\npush 4\npush 5\npop\npop\npop\npeek\npush 6\npush 7\npop\npeek\npush 8\npop",
        "expected_output": "2",
        "is_visible": false
      },
      {
        "input": "20\npush 10\npush 20\npush 30\npush 40\npush 50\npop\npop\npush 60\npush 70\npop\npeek\npush 80\npush 90\npop\npop\npeek\npush 100\npop\npeek\npop",
        "expected_output": "40",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            MyStack stack = new MyStack();\n            for (int i = 0; i < n; i++) {\n                String command = sc.next();\n                switch (command) {\n                    case \"push\":\n                        stack.push(sc.nextInt());\n                        break;\n                    case \"pop\":\n                        stack.pop();\n                        break;\n                    case \"peek\":\n                        System.out.println(stack.peek());\n                        break;\n                    case \"empty\":\n                        System.out.println(stack.empty());\n                        break;\n                    case \"size\":\n                        System.out.println(stack.size());\n                        break;\n                }\n            }\n        }\n        sc.close();\n    }\n// endregion\n}\n\nclass MyStack {\n    // Write your code here...\n    public void push(int a) {}\n    public void pop() {}\n    public int peek() { return -1; }\n    public boolean empty() { return true; }\n    public int size() { return 0; }\n}\n// region boilerplate\n// endregion"
    }
  },
  {
    "title": "5.2 Balanced Parenthesis Checking",
    "description": "# 5.2 Balanced Parenthesis Checking\n\nGiven an expression string, write a java program to find whether a given string has balanced parentheses or not.\n\n## Example 1:\n\n```\n\n## Example 1:\n\n```\nInput: (a+b)*(c-d)\nOutput: true\n```\n\n## Example 2:\n\n```\nInput: {{a+b}}*(c-d)}\nOutput: false\n```\n\n## Example 3:\n\n```\nInput: ((a+b)*[c-d])\nOutput: true\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "(a+b)*(c-d)",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "{{a+b}}*(c-d)}",
        "expected_output": "false",
        "is_visible": true
      },
      {
        "input": "((a+b)*[c-d])",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "([{a+b}]*{c-d})",
        "expected_output": "true",
        "is_visible": true
      },
      {
        "input": "(a+b)*[c-d)",
        "expected_output": "false",
        "is_visible": true
      },
      {
        "input": "{[()()]}",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "[(])",
        "expected_output": "false",
        "is_visible": false
      },
      {
        "input": "{[(a+b)*(c-d)]/(e+f)}",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "(((((())))))",
        "expected_output": "true",
        "is_visible": false
      },
      {
        "input": "(()()()()",
        "expected_output": "false",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNext()) {\n            String expr = sc.next();\n            System.out.println(isBalanced(expr));\n        }\n        sc.close();\n    }\n// endregion\n    public static boolean isBalanced(String s) {\n        // Write your code here...\n        return false;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "5.3 Evaluation of Postfix Expression",
    "description": "# 5.3 Evaluation of Postfix Expression\n\nGiven a postfix expression, the task is to evaluate the postfix expression. Postfix expression: The expression of the form \"a b operator\" (ab+) i.e., when a pair of operands is followed by an operator.\n\n## Example 1:\n\n```\n\n## Example 1:\n\n```\nInput: 2 3 1 * + 9 -\nOutput: -4\n```\n\n## Example 2:\n\n```\nInput: 100 200 + 2 / 5 * 7 +\nOutput: 757\n```\n\n## Example 3:\n\n```\nInput: 5 1 2 + 4 * + 3 -\nOutput: 14\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "2 3 1 * + 9 -",
        "expected_output": "-4",
        "is_visible": true
      },
      {
        "input": "100 200 + 2 / 5 * 7 +",
        "expected_output": "757",
        "is_visible": true
      },
      {
        "input": "5 1 2 + 4 * + 3 -",
        "expected_output": "14",
        "is_visible": true
      },
      {
        "input": "10 2 * 3 +",
        "expected_output": "23",
        "is_visible": true
      },
      {
        "input": "4 5 6 * +",
        "expected_output": "34",
        "is_visible": true
      },
      {
        "input": "3 4 + 2 * 7 /",
        "expected_output": "2",
        "is_visible": false
      },
      {
        "input": "5 1 2 + 4 * 3 - +",
        "expected_output": "14",
        "is_visible": false
      },
      {
        "input": "2 3 ^ 4 5 + +",
        "expected_output": "17",
        "is_visible": false
      },
      {
        "input": "15 7 1 1 + - / 3 * 2 1 1 + + -",
        "expected_output": "5",
        "is_visible": false
      },
      {
        "input": "3 4 2 * 1 5 - 2 ^ / +",
        "expected_output": "11",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextLine()) {\n            String expr = sc.nextLine();\n            System.out.println(evaluatePostfix(expr));\n        }\n        sc.close();\n    }\n// endregion\n    public static int evaluatePostfix(String exp) {\n        // Write your code here...\n        return 0;\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "5.4 Infix to Postfix Expression Conversion",
    "description": "# 5.4 Infix to Postfix Expression Conversion\n\nFor a given Infix expression, convert it into Postfix form. Infix expression: The expression of the form \"a operator b\" (a + b) i.e., when an operator is in-between every pair of operands. Postfix expression: The expression of the form \"a b operator\" (ab+) i.e., When every pair of operands is followed by an operator. Infix to postfix expression conversion procedure: 1. Scan the infix expression from left to right. 2. If the scanned character is an operand, put it in the postfix expression. 3. Otherwise, do the following - If the precedence and associativity of the scanned operator are greater than the precedence and associativity of the operator in the stack [or the stack is empty or the stack contains a '('], then push it in the stack. I'^' operator is right associative and other operators like '+',--',*' and '/' are left-associative]. - Check especially for a condition when the operator at the top of the stack and the scanned operator both are '^'. In this condition, the precedence of the scanned operator is higher due to its right associativity. So it will be pushed into the operator stack. - In all the other cases when the top of the operator stack is the same as the scanned operator, then pop the operator from the stack because of left associativity due to which the scanned operator has less precedence. - Else, Pop all the operators from the stack which are greater than or equal to in precedence than that of the scanned operator. - After doing that Push the scanned operator to the stack. (If you encounter parenthesis while popping then stop there and push the scanned operator in the stack.) 4. If the scanned character is a '(', push it to the stack. 5. If the scanned character is a ')', pop the stack and output it until a '(' is encountered, and discard both the parenthesis. 6. Repeat steps 2-5 until the infix expression is scanned. 7. Once the scanning is over, Pop the stack and add the operators in the postfix expression until it is not empty. 8. Finally, print the postfix expression.\n\n## Example 1:\n\n```\n\n## Example 1:\n\n```\nInput: A+B*C+D\nOutput: ABC*+D+\n```\n\n## Example 2:\n\n```\nInput: ((A+B)-C*(D/E))+F\nOutput: AB+CD/E/*-F+\n```\n\n## Example 3:\n\n```\nInput: a+b*c-d/e\nOutput: abc*+de/-\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "A+B*C+D",
        "expected_output": "ABC*+D+",
        "is_visible": true
      },
      {
        "input": "((A+B)-C*(D/E))+F",
        "expected_output": "AB+CD/E/*-F+",
        "is_visible": true
      },
      {
        "input": "a+b*c-d/e",
        "expected_output": "abc*+de/-",
        "is_visible": true
      },
      {
        "input": "(a+b)*(c-d)",
        "expected_output": "ab+cd-*",
        "is_visible": true
      },
      {
        "input": "a^b^c",
        "expected_output": "abc^^",
        "is_visible": true
      },
      {
        "input": "a+b*c/d-e",
        "expected_output": "abc*d/+e-",
        "is_visible": false
      },
      {
        "input": "(a+b)*(c/d-e)",
        "expected_output": "ab+cd/e-*",
        "is_visible": false
      },
      {
        "input": "a+b*(c^d-e)^(f+g*h)-i",
        "expected_output": "abcd^e-fgh*+^*+i-",
        "is_visible": false
      },
      {
        "input": "((a+b)*c-(d-e))/(f+g)",
        "expected_output": "ab+c*de--fg+/",
        "is_visible": false
      },
      {
        "input": "a+b*c-d/e^f*g",
        "expected_output": "abc*+def^/g*-",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNext()) {\n            String expr = sc.next();\n            System.out.println(infixToPostfix(expr));\n        }\n        sc.close();\n    }\n// endregion\n    public static String infixToPostfix(String exp) {\n        // Write your code here...\n        return \"\";\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "5.5 Reverse a Stack",
    "description": "# 5.5 Reverse a Stack\n\nThe stack is a linear data structure which works on the LIFO concept. LIFO stands for last in first out. In the stack, the insertion and deletion are possible at one end the end is called the top of the stack. Define two recursive functions BottomInsertion() and Reverse() to reverse a stack using Python. Define some basic function of the stack like push(), pop(), show(), empty(), for basic operation like respectively append an item in stack, remove an item in stack, display the stack, check the given stack is empty or not. BottomInsertion(): this method append element at the bottom of the stack and BottomInsertion accept two values as an argument first is stack and the second is elements, this is a recursive method. Reverse(): the method is reverse elements of the stack, this method accept stack as an argument Reverse() is also a Recursive() function. Reverse() is invoked BottomInsertion() method for completing the reverse operation on the stack.\n\n## Example 1:\n\n```\n\n## Example 1:\n\n```\nInput: 5 1 2 3 4 5\nOutput: 1 2 3 4 5\n```\n\n## Example 2:\n\n```\nInput: 3 10 20 30\nOutput: 10 20 30\n```\n\n## Example 3:\n\n```\nInput: 6 6 5 4 3 2 1\nOutput: 1 2 3 4 5 6\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "5\n1 2 3 4 5",
        "expected_output": "1 2 3 4 5",
        "is_visible": true
      },
      {
        "input": "3\n10 20 30",
        "expected_output": "10 20 30",
        "is_visible": true
      },
      {
        "input": "6\n6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6",
        "is_visible": true
      },
      {
        "input": "4\n100 200 300 400",
        "expected_output": "400 300 200 100",
        "is_visible": true
      },
      {
        "input": "7\n7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7",
        "is_visible": true
      },
      {
        "input": "8\n1 3 5 7 9 11 13 15",
        "expected_output": "15 13 11 9 7 5 3 1",
        "is_visible": false
      },
      {
        "input": "10\n10 9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9 10",
        "is_visible": false
      },
      {
        "input": "12\n12 11 10 9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12",
        "is_visible": false
      },
      {
        "input": "15\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
        "is_visible": false
      },
      {
        "input": "20\n20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1",
        "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            Stack<Integer> stack = new Stack<>();\n            for (int i = 0; i < n; i++) {\n                stack.push(sc.nextInt());\n            }\n            reverse(stack);\n            StringBuilder sb = new StringBuilder();\n            for (Integer x : stack) {\n                sb.append(x).append(\" \");\n            }\n            System.out.println(sb.toString().trim());\n        }\n        sc.close();\n    }\n// endregion\n    public static void reverse(Stack<Integer> s) {\n        // Write your code here...\n    }\n// region boilerplate\n}\n// endregion"
    }
  },
  {
    "title": "6.1 Linear Queue",
    "description": "# 6.1 Linear Queue\n\nLinear queue is a linear data structure that stores items in First in First out (FIFO) manner. With a queue the least recently added item is removed first. A good example of queue is any queue of consumers for a resource where the consumer that came first is served first.\n\n## Example 1:\n\n```\nInput: 5 enqueue 10 enqueue 20 enqueue 30 dequeue enqueue 40 dequeue display\nOutput: 30 40\n```\n\n## Example 2:\n\n```\nInput: 3 enqueue 5 enqueue 10 dequeue\nOutput: 10\n```\n\n## Example 3:\n\n```\nInput: 4 enqueue 100 enqueue 200 dequeue dequeue\nOutput: Queue is empty\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "5\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\ndisplay",
        "expected_output": "30 40",
        "is_visible": true
      },
      {
        "input": "3\nenqueue 5\nenqueue 10\ndequeue",
        "expected_output": "10",
        "is_visible": true
      },
      {
        "input": "4\nenqueue 100\nenqueue 200\ndequeue\ndequeue",
        "expected_output": "Queue is empty",
        "is_visible": true
      },
      {
        "input": "6\nenqueue 1\nenqueue 2\nenqueue 3\ndequeue\nenqueue 4\ndisplay",
        "expected_output": "2 3 4",
        "is_visible": true
      },
      {
        "input": "5\nenqueue 99\ndequeue\nenqueue 88\ndequeue\ndequeue",
        "expected_output": "Queue is empty",
        "is_visible": true
      },
      {
        "input": "8\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\nenqueue 50\ndisplay",
        "expected_output": "30 40 50",
        "is_visible": false
      },
      {
        "input": "10\nenqueue 5\nenqueue 10\nenqueue 15\ndequeue\nenqueue 20\ndequeue\nenqueue 25\nenqueue 30\ndequeue\ndisplay",
        "expected_output": "20 25 30",
        "is_visible": false
      },
      {
        "input": "12\nenqueue 100\nenqueue 200\nenqueue 300\ndequeue\nenqueue 400\ndequeue\nenqueue 500\nenqueue 600\ndequeue\ndequeue\ndequeue\ndisplay",
        "expected_output": "600",
        "is_visible": false
      },
      {
        "input": "15\nenqueue 1\nenqueue 2\nenqueue 3\nenqueue 4\nenqueue 5\ndequeue\ndequeue\ndequeue\nenqueue 6\nenqueue 7\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
        "expected_output": "7",
        "is_visible": false
      },
      {
        "input": "20\nenqueue 10\nenqueue 20\nenqueue 30\nenqueue 40\nenqueue 50\ndequeue\ndequeue\nenqueue 60\nenqueue 70\ndequeue\nenqueue 80\nenqueue 90\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
        "expected_output": "Queue is empty",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            MyQueue queue = new MyQueue();\n            for (int i = 0; i < n; i++) {\n                String command = sc.next();\n                switch (command) {\n                    case \"enqueue\":\n                        queue.enqueue(sc.nextInt());\n                        break;\n                    case \"dequeue\":\n                        queue.dequeue(); \n                        break;\n                    case \"display\":\n                        queue.display();\n                        break;\n                }\n            }\n        }\n        sc.close();\n    }\n// endregion\n}\n\nclass MyQueue {\n    // Write your code here...\n    public void enqueue(int item) {}\n    public void dequeue() {}\n    public void display() {}\n}\n// region boilerplate\n// endregion"
    }
  },
  {
    "title": "6.2 Stack using Queues",
    "description": "# 6.2 Stack using Queues\n\nImplement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). - void push(int x) Pushes element x to the top of the stack. - int pop() Removes the element on the top of the stack and returns it. - int top() Returns the element on the top of the stack. - boolean empty() Returns true if the stack is empty, false otherwise.\n\n## Example 1:\n\n```\n\n## Example 1:\n\n```\nInput: push 1 push 2 top pop empty\nOutput: 2 2 false\n```\n\n## Example 2:\n\n```\nInput: push 10 push 20 pop top\nOutput: 20 10\n```\n\n## Example 3:\n\n```\nInput: push 5 pop empty\nOutput: 5 true\n```\n\n## Constraints:\n\n- `1 <= n <= 10^5`\n- Time Limit: 1.0 second\n",
    "testcases": [
      {
        "input": "push 1\npush 2\ntop\npop\nempty",
        "expected_output": "2\n2\nfalse",
        "is_visible": true
      },
      {
        "input": "push 10\npush 20\npop\ntop",
        "expected_output": "20\n10",
        "is_visible": true
      },
      {
        "input": "push 5\npop\nempty",
        "expected_output": "5\ntrue",
        "is_visible": true
      },
      {
        "input": "push 100\npush 200\npush 300\npop\npop\ntop",
        "expected_output": "300\n200\n100",
        "is_visible": true
      },
      {
        "input": "empty\npush 50\nempty",
        "expected_output": "true\nfalse",
        "is_visible": true
      },
      {
        "input": "push 1\npush 2\npush 3\npop\npush 4\npop\ntop",
        "expected_output": "3\n4\n2",
        "is_visible": false
      },
      {
        "input": "push 10\npush 20\npush 30\npop\npop\npush 40\npop\ntop",
        "expected_output": "30\n20\n40\n10",
        "is_visible": false
      },
      {
        "input": "empty\npush 5\npush 10\npop\nempty\npush 15\npop\ntop",
        "expected_output": "true\n10\nfalse\n15\n5",
        "is_visible": false
      },
      {
        "input": "push 1\npush 2\npush 3\npush 4\npush 5\npop\npop\npop\npop\npop\nempty",
        "expected_output": "5\n4\n3\n2\n1\ntrue",
        "is_visible": false
      },
      {
        "input": "push 100\npush 200\npop\npush 300\npush 400\npop\npop\ntop\nempty",
        "expected_output": "200\n400\n300\n100\nfalse",
        "is_visible": false
      }
    ],
    "driverCode": {
      "java": "// region boilerplate\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); // Parse commands like \"push\", \"pop\"\n        StackUsingQueues s = new StackUsingQueues();\n        while(sc.hasNext()) {\n             String cmd = sc.next();\n             if(cmd.equals(\"push\")) s.push(sc.nextInt());\n             else if(cmd.equals(\"pop\")) System.out.println(s.pop());\n             else if(cmd.equals(\"top\")) System.out.println(s.top());\n             else if(cmd.equals(\"empty\")) System.out.println(s.empty());\n        }\n        sc.close();\n    }\n// endregion\n}\nclass StackUsingQueues {\n    public void push(int x) {}\n    public int pop() { return -1; }\n    public int top() { return -1; }\n    public boolean empty() { return false; }\n}\n// region boilerplate\n// endregion"
    }
  }
]