[
    {
        "title": "1.1 Sum of last digits of two given numbers",
        "description": "Rohit wants to add the last digits of two given numbers. For example, if the given numbers are 267 and 154, the output should be 11. Below is the explanation - Last digit of the 267 is 7 Last digit of the 154 is 4 Sum of 7 and 4 = 11 Write a program to help Rohit achieve this for any given two numbers. The prototype of the method should be - int addLastDigits(int input1, int input2); where input1 and input2 denote the two numbers whose last digits are to be added. Note: The sign of the input numbers should be ignored. If the input numbers are 267 and 154, the sum of last two digits should be 11 if the input numbers are 267 and -154, the sum of last two digits should be 11 if the input numbers are -267 and 154, the sum of last two digits should be 11 if the input numbers are -267 and -154, the sum of last two digits should be 11 Input: 267 154 Output: 11 Input: 267 -154 Output: 11 Input: -267 154 Output: 11 Input: -267 -154 Output: 11",
        "starter_code": "import java.util.Scanner;\n\nclass AddLastDigitsFunction\n{\n    int addLastDigits(int n1, int n2)\n    {\n    # Write code here\n    }\n\n    public static void main(String args[])\n    {\n    AddLastDigitsFunction obj = new AddLastDigitsFunction();\n    # Write code here\n    System.out.println(obj.addLastDigits(n1,n2));",
        "testcases": [
            {
                "input": "267 154",
                "expected_output": "11",
                "is_visible": true
            },
            {
                "input": "267 -154",
                "expected_output": "11",
                "is_visible": true
            },
            {
                "input": "-267 154",
                "expected_output": "11",
                "is_visible": true
            },
            {
                "input": "0 5",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "123 456",
                "expected_output": "9",
                "is_visible": true
            },
            {
                "input": "9999 8888",
                "expected_output": "17",
                "is_visible": false
            },
            {
                "input": "-732 419",
                "expected_output": "11",
                "is_visible": false
            },
            {
                "input": "1000 -7",
                "expected_output": "7",
                "is_visible": false
            },
            {
                "input": "55 -66",
                "expected_output": "11",
                "is_visible": false
            },
            {
                "input": "-999 -1",
                "expected_output": "10",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.2 Is N an exact multiple of M?",
        "description": "Write a function that accepts two parameters and finds whether the first parameter is an exact multiple of the second parameter. If the first parameter is an exact multiple of the second parameter, the function should return 2 else it should return 1. If either of the parameters are zero, the function should return 3. Assumption: Within the scope of this question, assume that - the first parameter can be positive, negative or zero the second parameter will always be >=0 Input: num1 = 10, num2 = 5 Output: 2 Input: num1 = -10, num2 = 5 Output: 2 Input: num1 = 0, num2 = 5 Output: 3 Input: num1 = 10, num2 = 3 Output: 1",
        "starter_code": "public class MultipleChecker\n{\n    public static int checkMultiple(int num1, int num2)\n    {\n    # Write code here\n    }\n    public static void main(String[] args)\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "10 5",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "-10 5",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "0 5",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "10 3",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "-15 3",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "0 0",
                "expected_output": "3",
                "is_visible": false
            },
            {
                "input": "100 20",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "17 0",
                "expected_output": "3",
                "is_visible": false
            },
            {
                "input": "-24 6",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "13 5",
                "expected_output": "1",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.3 Combine Strings",
        "description": "Given 2 strings, a and b, return a new string of the form short+long+short, with the shorter string on the outside and the longer string in the inside. The strings will not be the same length, but they may be empty (length 0). If input is \"hi\" and \"hello\", then output will be \"hihellohi\" Input: Enter the first string: \"hi\" Enter the second string: \"hello\" Output: \"hihellohi\" Input: Enter the first string: \"iare\" Enter the second string: \"college\" Output: \"iarecollegelare\"",
        "starter_code": "public class StringCombine\n{\n    public static void main(String[] args)\n    {\n    # Write code here\n    }\n    public static String combineStrings(String a, String b)\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "hi hello",
                "expected_output": "hihellohi",
                "is_visible": true
            },
            {
                "input": "iare college",
                "expected_output": "iarecollegeiare",
                "is_visible": true
            },
            {
                "input": "a programming",
                "expected_output": "aprogramminga",
                "is_visible": true
            },
            {
                "input": "test longer",
                "expected_output": "testlongertest",
                "is_visible": true
            },
            {
                "input": " data ",
                "expected_output": " data data ",
                "is_visible": true
            },
            {
                "input": "xyz abcdefg",
                "expected_output": "xyzabcdefgxyz",
                "is_visible": false
            },
            {
                "input": " structure ",
                "expected_output": " structure structure ",
                "is_visible": false
            },
            {
                "input": "java python",
                "expected_output": "javapythonjava",
                "is_visible": false
            },
            {
                "input": "micro macro",
                "expected_output": "micromacromicro",
                "is_visible": false
            },
            {
                "input": "c++ javascript",
                "expected_output": "c++javascriptc++",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.4 Even or Odd",
        "description": "Write a function that accepts 6 input parameters. The first 5 input parameters are of type int. The sixth input parameter is of type string. If the sixth parameter contains the value \"even\", the function is supposed to return the count of how many of the first five input parameters are even. If the sixth parameter contains the value \"odd\", the function is supposed to return the count of how many of the first five input parameters are odd. Example: If the five input parameters are 12, 17, 19, 14, and 115, and the sixth parameter is \"odd\", the function must return 3, because there are three odd numbers 17, 19 and 115. If the five input parameters are 12, 17, 19, 14, and 115, and the sixth parameter is \"even\", the function must return 2, because there are two even numbers 12 and 14. Note that zero is considered an even number. Input: num1 = 12; num2 = 17; num3 = 19; num4 = 14; num5 = 115; type = \"odd\" Output: 3 Input: num1 = 12; num2 = 17; num3 = 19; num4 = 14; num5 = 115; type = \"even\" Output: 2",
        "starter_code": "public class NumberCounter\n{\n    public static int countNumbers(int num1, int num2, int num3, int num4, int num5, String type)\n    {\n    # Write code here\n    }\n    public static void main(String[] args)\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "12 17 19 14 115 odd",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "12 17 19 14 115 even",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "0 2 4 6 8 even",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "1 3 5 7 9 odd",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "0 1 2 3 4 even",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "10 20 30 40 50 odd",
                "expected_output": "0",
                "is_visible": false
            },
            {
                "input": "11 22 33 44 55 even",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "100 101 102 103 104 odd",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "-5 -4 -3 -2 -1 even",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "0 0 0 0 0 odd",
                "expected_output": "0",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.5 Second last digit of a given number",
        "description": "Write a function that returns the second last digit of the given number. Second last digit is being referred to the digit in the tens place in the given number. Example: if the given number is 197, the second last digit is 9. Note 1: The second last digit should be returned as a positive number. i.e. if the given number is -197, the second last digit is 9. Note 2: If the given number is a single digit number, then the second last digit does not exist. In such cases, the function should return -1. i.e. if the given number is 5, the second last digit should be returned as -1. Input: 197 Output: 9 Input: 5 Output: -1 Input: -197 Output: 9",
        "starter_code": "public class SecondLastDigit\n{\n    public static int getSecondLastDigit(int number)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "197",
                "expected_output": "9",
                "is_visible": true
            },
            {
                "input": "5",
                "expected_output": "-1",
                "is_visible": true
            },
            {
                "input": "-197",
                "expected_output": "9",
                "is_visible": true
            },
            {
                "input": "1234",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "-50",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "9999",
                "expected_output": "9",
                "is_visible": false
            },
            {
                "input": "-1",
                "expected_output": "-1",
                "is_visible": false
            },
            {
                "input": "100",
                "expected_output": "0",
                "is_visible": false
            },
            {
                "input": "-8765",
                "expected_output": "6",
                "is_visible": false
            },
            {
                "input": "0",
                "expected_output": "-1",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.6 Alternate String Combiner",
        "description": "Given two strings, a and b, print a new string which is made of the following combination-first character of a, the first character of b, second character of a, second character of b and so on. Any characters left, will go to the end of the result. Hello,World HWeolrllod Input: \"Hello,World\" Output: \"HWeolrllod\" Input: \"Iare,College\" Output: \"Caorlelege\"",
        "starter_code": "public class AlternateStringCombiner\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static String combineStrings(String a, String b)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "Hello World",
                "expected_output": "HWeolrllod",
                "is_visible": true
            },
            {
                "input": "Iare College",
                "expected_output": "Caorlelege",
                "is_visible": true
            },
            {
                "input": "ab xyz",
                "expected_output": "axbyz",
                "is_visible": true
            },
            {
                "input": "python java",
                "expected_output": "pjyatvhaon",
                "is_visible": true
            },
            {
                "input": "A BCD",
                "expected_output": "ABCD",
                "is_visible": true
            },
            {
                "input": "data structures",
                "expected_output": "dstaartaucetures",
                "is_visible": false
            },
            {
                "input": "algorithm design",
                "expected_output": "aldgeosrigtohrithmn",
                "is_visible": false
            },
            {
                "input": "abcdef 123",
                "expected_output": "a1b2c3def",
                "is_visible": false
            },
            {
                "input": "xyz ABCD",
                "expected_output": "xA yB zC D",
                "is_visible": false
            },
            {
                "input": "short longer",
                "expected_output": "slhoonrgteer",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.7 Padovan Sequence",
        "description": "The Padovan sequence is a sequence of numbers named after Richard Padovan, who attributed its discovery to Dutch architect Hans van der Laan. The sequence was described by Ian Stewart in his Scientific American column Mathematical Recreations in June 1996. The Padovan sequence is defined by the following recurrence relation: P(n) = P(n-2) + P(n-3) with the initial conditions P(0) = P(1) = P(2) = 1. In this sequence, each term is the sum of the two preceding terms, similar to the Fibonacci sequence. However, the Padovan sequence has different initial conditions and exhibits different growth patterns. The first few terms of the Padovan sequence are: 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, ... Input: num = 10 Output: Padovan Sequence up to 10: 1 1 2 2 3 4 5 7 9 12 Input: num = 20 Output: Padovan Sequence up to 20: 1 1 2 2 3 4 5 7 9 12 16 21 28 37 49 65 86 114 151 200",
        "starter_code": "public class PadovanSequence\n{\n    public static int padovan(int n)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "5",
                "expected_output": "1 1 1 2 2",
                "is_visible": true
            },
            {
                "input": "10",
                "expected_output": "1 1 1 2 2 3 4 5 7 9",
                "is_visible": true
            },
            {
                "input": "3",
                "expected_output": "1 1 1",
                "is_visible": true
            },
            {
                "input": "7",
                "expected_output": "1 1 1 2 2 3 4",
                "is_visible": true
            },
            {
                "input": "1",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "15",
                "expected_output": "1 1 1 2 2 3 4 5 7 9 12 16 21 28 37",
                "is_visible": false
            },
            {
                "input": "20",
                "expected_output": "1 1 1 2 2 3 4 5 7 9 12 16 21 28 37 49 65 86 114 151",
                "is_visible": false
            },
            {
                "input": "8",
                "expected_output": "1 1 1 2 2 3 4 5",
                "is_visible": false
            },
            {
                "input": "12",
                "expected_output": "1 1 1 2 2 3 4 5 7 9 12 16",
                "is_visible": false
            },
            {
                "input": "25",
                "expected_output": "1 1 1 2 2 3 4 5 7 9 12 16 21 28 37 49 65 86 114 151 200 265 351 465 616",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.8 Leaders in an array",
        "description": "Given an array arr of n positive integers, your task is to find all the leaders in the array. An element of the array is considered a leader if it is greater than all the elements on its right side or if it is equal to the maximum element on its right side. The rightmost element is always a leader. Input: n = 6, arr[] = {16, 17, 4, 3, 5, 2} Output: 17 5 2 Input: n = 5, arr[] = {10, 4, 2, 4, 1} Output: 10 4 4 1 Input: n = 4, arr[] = {5, 10, 20, 40} Output: 40 Input: n = 4, arr[] = {30, 10, 10, 5} Output: 30 10 10 5",
        "starter_code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ArrayLeaders\n{\n    public static List<Integer> findArrayListeaders(int[] arr)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "6\n16 17 4 3 5 2",
                "expected_output": "17 5 2",
                "is_visible": true
            },
            {
                "input": "5\n10 4 2 4 1",
                "expected_output": "10 4 4 1",
                "is_visible": true
            },
            {
                "input": "4\n5 10 20 40",
                "expected_output": "40",
                "is_visible": true
            },
            {
                "input": "4\n30 10 10 5",
                "expected_output": "30 10 10 5",
                "is_visible": true
            },
            {
                "input": "3\n1 2 3",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "7\n7 10 4 3 20 15 2",
                "expected_output": "20 15 2",
                "is_visible": false
            },
            {
                "input": "5\n5 4 3 2 1",
                "expected_output": "5 4 3 2 1",
                "is_visible": false
            },
            {
                "input": "6\n1 1 1 1 1 1",
                "expected_output": "1 1 1 1 1 1",
                "is_visible": false
            },
            {
                "input": "8\n34 23 12 34 45 56 34 20",
                "expected_output": "56 34 20",
                "is_visible": false
            },
            {
                "input": "10\n10 9 8 7 6 5 4 3 2 1",
                "expected_output": "10 9 8 7 6 5 4 3 2 1",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.9 Find the Value of a Number Raised to its Reverse",
        "description": "Given a number N and its reverse R. The task is to find the number obtained when the number is raised to the power of its own reverse Input: N = 2, R = 2 Output: 4 Explanation: Number 2 raised to the power of its reverse 2 gives 4 which gives 4 as a result after performing modulo 10^9+7 Input: N = 57, R = 75 Output: 262042770 Explanation: 57^75 modulo 10^9+7 gives us the result as 262042770",
        "starter_code": "public class NumberPower\n{\n    public static long powerOfReverse(int N, int R)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "2 2",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "57 75",
                "expected_output": "262042770",
                "is_visible": true
            },
            {
                "input": "3 3",
                "expected_output": "27",
                "is_visible": true
            },
            {
                "input": "10 1",
                "expected_output": "10",
                "is_visible": true
            },
            {
                "input": "5 5",
                "expected_output": "3125",
                "is_visible": true
            },
            {
                "input": "12 21",
                "expected_output": "119664366",
                "is_visible": false
            },
            {
                "input": "7 7",
                "expected_output": "823543",
                "is_visible": false
            },
            {
                "input": "100 1",
                "expected_output": "100",
                "is_visible": false
            },
            {
                "input": "9 9",
                "expected_output": "387420489",
                "is_visible": false
            },
            {
                "input": "123 321",
                "expected_output": "599576739",
                "is_visible": false
            }
        ]
    },
    {
        "title": "1.10 Mean of Array using Recursion",
        "description": "Find the mean of the elements of the array. Mean = (Sum of elements of the Array) / (Total no of elements in Array) Input: 1 2 3 4 5 Output: 3.0 Input: 1 2 3 Output: 2.0 To find the mean using recursion assume that the problem is already solved for N-1 i.e. you have to find for n Sum of first N-1 elements = (Mean of N-1 elements) * (N-1) Mean of N elements = (Sum of first N-1 elements + N-th elements) / (N)",
        "starter_code": "public class ArrayMean\n{\n    public static double findArrayMean(int[] arr)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "1 2 3 4 5",
                "expected_output": "3.0",
                "is_visible": true
            },
            {
                "input": "1 2 3",
                "expected_output": "2.0",
                "is_visible": true
            },
            {
                "input": "10 20 30",
                "expected_output": "20.0",
                "is_visible": true
            },
            {
                "input": "5 5 5 5",
                "expected_output": "5.0",
                "is_visible": true
            },
            {
                "input": "100 200 300 400",
                "expected_output": "250.0",
                "is_visible": true
            },
            {
                "input": "2 4 6 8 10 12",
                "expected_output": "7.0",
                "is_visible": false
            },
            {
                "input": "1 3 5 7 9 11 13",
                "expected_output": "7.0",
                "is_visible": false
            },
            {
                "input": "0 0 0 0 0",
                "expected_output": "0.0",
                "is_visible": false
            },
            {
                "input": "-5 -3 -1 1 3 5",
                "expected_output": "0.0",
                "is_visible": false
            },
            {
                "input": "1 2 3 4 5 6 7 8 9 10",
                "expected_output": "5.5",
                "is_visible": false
            }
        ]
    },
    {
        "title": "2.1 Linear / Sequential Search",
        "description": "Linear search is defined as the searching algorithm where the list or data set is traversed from one end to find the desired value. Given an array arr[] of n elements, write a recursive function to search a given element x in arr[]. Find '6' 0 1 2 3 4 5 6 7 8 9 Index Note: We find '6' at index '5' through linear search Linear search procedure: 1. Start from the leftmost element of arr[] and one by one compare x with each element of arr[] 2. If x matches with an element, return the index. 3. If x doesn't match with any of the elements, return -1. Input: arr[] = {10, 20, 80, 30, 60, 50, 110, 100, 130, 170} x = 110; Output: 6 Element x is present at index 6 Input: arr[] = {10, 20, 80, 30, 60, 50, 110, 100, 130, 170} x = 175; Output: -1 Element x is not present in arr[].",
        "starter_code": "public class RecursiveLinearSearch\n{\n    public static int recursiveLinearSearch(int[] arr, int key, int index)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "10\n10 20 80 30 60 50 110 100 130 170\n110",
                "expected_output": "6",
                "is_visible": true
            },
            {
                "input": "10\n10 20 80 30 60 50 110 100 130 170\n175",
                "expected_output": "-1",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5\n3",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "7\n7 14 21 28 35 42 49\n42",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "4\n100 200 300 400\n500",
                "expected_output": "-1",
                "is_visible": true
            },
            {
                "input": "8\n5 10 15 20 25 30 35 40\n25",
                "expected_output": "4",
                "is_visible": false
            },
            {
                "input": "6\n2 4 6 8 10 12\n7",
                "expected_output": "-1",
                "is_visible": false
            },
            {
                "input": "9\n11 22 33 44 55 66 77 88 99\n88",
                "expected_output": "7",
                "is_visible": false
            },
            {
                "input": "12\n1 3 5 7 9 11 13 15 17 19 21 23\n19",
                "expected_output": "9",
                "is_visible": false
            },
            {
                "input": "15\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150\n145",
                "expected_output": "-1",
                "is_visible": false
            }
        ]
    },
    {
        "title": "2.2 Binary Search",
        "description": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Conditions for Binary Search algorithm: 1. The data structure must be sorted. 2. Access to any element of the data structure takes constant time. Binary Search Procedure: 1. Divide the search space into two halves by finding the middle index \"mid\". 2. Compare the middle element of the search space with the key. 3. If the key is found at middle element, the process is terminated. 4. If the key is not found at middle element, choose which half will be used as the next search space. a. If the key is smaller than the middle element, then the left side is used for next search. b. If the key is larger than the middle element, then the right side is used for next search. 5. This process is continued until the key is found or the total search space is exhausted. Input: arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91] Output: target = 23 Element 23 is present at index 5",
        "starter_code": "public class RecursiveBinarySearch\n{\n    public static int recursiveBinarySearch(int[] arr, int key, int left, int right)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "10\n2 5 8 12 16 23 38 56 72 91\n23",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "5\n1 3 5 7 9\n5",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "8\n10 20 30 40 50 60 70 80\n35",
                "expected_output": "-1",
                "is_visible": true
            },
            {
                "input": "7\n2 4 6 8 10 12 14\n8",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "6\n1 2 3 4 5 6\n1",
                "expected_output": "0",
                "is_visible": true
            },
            {
                "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\n45",
                "expected_output": "8",
                "is_visible": false
            },
            {
                "input": "15\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500\n1250",
                "expected_output": "-1",
                "is_visible": false
            },
            {
                "input": "20\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n28",
                "expected_output": "13",
                "is_visible": false
            },
            {
                "input": "25\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n25",
                "expected_output": "24",
                "is_visible": false
            },
            {
                "input": "30\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300\n155",
                "expected_output": "-1",
                "is_visible": false
            }
        ]
    },
    {
        "title": "2.3 Uniform Binary Search",
        "description": "Uniform Binary Search is an optimization of Binary Search algorithm when many searches are made on same array or many arrays of same size. In normal binary search, we do arithmetic operations to find the mid points. Here we precompute mid points and fills them in lookup table. The array look-up generally works faster than arithmetic done (addition and shift) to find the mid-point. Input: array = {1, 3, 5, 6, 7, 8, 9}, v=3 Output: Position of 3 in array = 2 Input: array = {1, 3, 5, 6, 7, 8, 9}, v=7 Output: Position of 7 in array = 5 The algorithm is very similar to Binary Search algorithm, the only difference is a lookup table is created for an array and the lookup table is used to modify the index of the pointer in the array which makes the search faster. Instead of maintaining lower and upper bound the algorithm maintains an index and the index is modified using the lookup table.",
        "starter_code": "public class RecursiveUniformBinarySearch\n{\n    public static int recursiveUniformBinarySearch(int[] arr, int key, int[] lookupTable, int left, int right)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "7\n1 3 5 6 7 8 9\n3",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "7\n1 3 5 6 7 8 9\n7",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "5\n10 20 30 40 50\n40",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "8\n2 4 6 8 10 12 14 16\n2",
                "expected_output": "0",
                "is_visible": true
            },
            {
                "input": "6\n5 10 15 20 25 30\n25",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12\n9",
                "expected_output": "8",
                "is_visible": false
            },
            {
                "input": "15\n100 150 200 250 300 350 400 450 500 550 600 650 700 750 800\n550",
                "expected_output": "9",
                "is_visible": false
            },
            {
                "input": "20\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n85",
                "expected_output": "16",
                "is_visible": false
            },
            {
                "input": "25\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50\n32",
                "expected_output": "15",
                "is_visible": false
            },
            {
                "input": "30\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n29",
                "expected_output": "28",
                "is_visible": false
            }
        ]
    },
    {
        "title": "2.4 Interpolation Search",
        "description": "Interpolation search works better than Binary Search for a Sorted and Uniformly Distributed array. Binary search goes to the middle element to check irrespective of search-key. On the other hand, Interpolation search may go to different locations according to search-key. If the value of the search-key is close to the last element, Interpolation Search is likely to start search toward the end side. Interpolation search is more efficient than binary search when the elements in the list are uniformly distributed, while binary search is more efficient when the elements in the list are not uniformly distributed. Interpolation search can take longer to implement than binary search, as it requires the use of additional calculations to estimate the position of the target element. Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] Output: target = 5",
        "starter_code": "public class InterpolationSearch\n{\n    public static int interpolationSearch(int[] arr, int key)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "9\n1 2 3 4 5 6 7 8 9\n5",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "5\n10 20 30 40 50\n30",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "7\n100 200 300 400 500 600 700\n400",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "8\n5 10 15 20 25 30 35 40\n25",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "6\n2 4 6 8 10 12\n12",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12\n9",
                "expected_output": "8",
                "is_visible": false
            },
            {
                "input": "15\n100 150 200 250 300 350 400 450 500 550 600 650 700 750 800\n550",
                "expected_output": "9",
                "is_visible": false
            },
            {
                "input": "20\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200\n180",
                "expected_output": "17",
                "is_visible": false
            },
            {
                "input": "25\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125\n100",
                "expected_output": "19",
                "is_visible": false
            },
            {
                "input": "30\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n22",
                "expected_output": "21",
                "is_visible": false
            }
        ]
    },
    {
        "title": "2.5 Fibonacci Search",
        "description": "Given a sorted array arr[] of size n and an element x to be searched in it. Return index of x if it is present in array else return -1. Input: arr[] = {2, 3, 4, 10, 40}, x = 10 Output: 3 Element x is present at index 3. Input: arr[] = {2, 3, 4, 10, 40}, x = 11 Output: -1 Element x is not present. Fibonacci Search is a comparison-based technique that uses Fibonacci numbers to search an element in a sorted array. Fibonacci Numbers are recursively defined as F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1. First few Fibonacci Numbers are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ... Fibonacci Search Procedure: Let the searched element be x. The idea is to first find the smallest Fibonacci number that is greater than or equal to the length of the given array. Let the found Fibonacci number be fib (m'th Fibonacci number). We use (m-2)'th Fibonacci number as the index (if it is a valid index). Let (m-2)'th Fibonacci Number be i, we compare arr[i] with x, if x is same, we return i. Else if x is greater, we recur for subarray after i, else we recur for subarray before i. Let arr[0..n-1] be the input array and the element to be searched be x. 1. Find the smallest Fibonacci number greater than or equal to n. Let this number be fibM [m'th Fibonacci number]. Let the two Fibonacci numbers preceding it be fibMm1 [(m-1)'th Fibonacci Number] and fibMm2 [(m-2)'th Fibonacci Number]. 2. While the array has elements to be inspected: i. Compare x with the last element of the range covered by fibMm2 ii. If x matches, return index iii. Else If x is less than the element, move the three Fibonacci variables two Fibonacci down, indicating elimination of approximately rear two-third of the remaining array. iv. Else x is greater than the element, move the three Fibonacci variables one Fibonacci down. Reset offset to index. Together these indicate the elimination of approximately front one-third of the remaining array. 3. Since there might be a single element remaining for comparison, check if fibMm1 is 1. If Yes, compare x with that remaining element. If match, return index.",
        "starter_code": "public class FibonacciSearch\n{\n    public static int fibonacciSearch(int[] arr, int key)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "5\n2 3 4 10 40\n10",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "5\n2 3 4 10 40\n11",
                "expected_output": "-1",
                "is_visible": true
            },
            {
                "input": "7\n1 2 3 5 8 13 21\n8",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "10\n10 20 30 40 50 60 70 80 90 100\n70",
                "expected_output": "6",
                "is_visible": true
            },
            {
                "input": "6\n5 15 25 35 45 55\n45",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "12\n1 3 5 7 9 11 13 15 17 19 21 23\n15",
                "expected_output": "7",
                "is_visible": false
            },
            {
                "input": "15\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30\n24",
                "expected_output": "11",
                "is_visible": false
            },
            {
                "input": "20\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n85",
                "expected_output": "16",
                "is_visible": false
            },
            {
                "input": "25\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250\n200",
                "expected_output": "19",
                "is_visible": false
            },
            {
                "input": "30\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n27",
                "expected_output": "26",
                "is_visible": false
            }
        ]
    },
    {
        "title": "3.1 Bubble Sort",
        "description": "Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high. Bubble Sort Procedure: 1. Traverse from left and compare adjacent elements and the higher one is placed at right side. 2. In this way, the largest element is moved to the rightmost end at first. 3. This process is then continued to find the second largest and place it and so on until the data is sorted. Input: arr = [6, 3, 0, 5] Output: First Pass: Second Pass: Third Pass:",
        "starter_code": "import java.util.Scanner;\n\nclass BubbleSortExample\n{\n public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void bubbleSort(int[] arr)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "4\n6 3 0 5",
                "expected_output": "0 3 5 6",
                "is_visible": true
            },
            {
                "input": "5\n5 4 3 2 1",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "3\n10 5 8",
                "expected_output": "5 8 10",
                "is_visible": true
            },
            {
                "input": "6\n1 2 3 4 5 6",
                "expected_output": "1 2 3 4 5 6",
                "is_visible": true
            },
            {
                "input": "5\n100 50 75 25 0",
                "expected_output": "0 25 50 75 100",
                "is_visible": true
            },
            {
                "input": "8\n64 34 25 12 22 11 90 88",
                "expected_output": "11 12 22 25 34 64 88 90",
                "is_visible": false
            },
            {
                "input": "7\n3 1 4 1 5 9 2",
                "expected_output": "1 1 2 3 4 5 9",
                "is_visible": false
            },
            {
                "input": "10\n10 9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9 10",
                "is_visible": false
            },
            {
                "input": "12\n45 23 78 12 56 89 34 67 90 11 99 22",
                "expected_output": "11 12 22 23 34 45 56 67 78 89 90 99",
                "is_visible": false
            },
            {
                "input": "15\n5 2 8 1 9 3 7 4 6 10 15 12 13 11 14",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            }
        ]
    },
    {
        "title": "3.2 Selection Sort",
        "description": "Selection sort is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. The algorithm repeatedly selects the smallest (or largest) element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted. Input: arr = [64, 25, 12, 22, 11] Output: arr = [11, 12, 22, 25, 64]",
        "starter_code": "import java.util.Scanner;\n\nclass SelectionSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void selectionSort(int[] arr)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "5\n64 25 12 22 11",
                "expected_output": "11 12 22 25 64",
                "is_visible": true
            },
            {
                "input": "6\n34 7 23 32 5 62",
                "expected_output": "5 7 23 32 34 62",
                "is_visible": true
            },
            {
                "input": "4\n10 30 20 40",
                "expected_output": "10 20 30 40",
                "is_visible": true
            },
            {
                "input": "7\n100 200 150 50 75 25 300",
                "expected_output": "25 50 75 100 150 200 300",
                "is_visible": true
            },
            {
                "input": "5\n5 1 4 2 3",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "8\n90 80 70 60 50 40 30 20",
                "expected_output": "20 30 40 50 60 70 80 90",
                "is_visible": false
            },
            {
                "input": "9\n45 12 89 34 67 23 78 56 90",
                "expected_output": "12 23 34 45 56 67 78 89 90",
                "is_visible": false
            },
            {
                "input": "10\n3 7 1 9 4 6 8 2 5 10",
                "expected_output": "1 2 3 4 5 6 7 8 9 10",
                "is_visible": false
            },
            {
                "input": "12\n55 33 77 11 99 22 88 44 66 0 110 121",
                "expected_output": "0 11 22 33 44 55 66 77 88 99 110 121",
                "is_visible": false
            },
            {
                "input": "15\n14 13 12 11 10 9 8 7 6 5 4 3 2 1 0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14",
                "is_visible": false
            }
        ]
    },
    {
        "title": "3.3 Insertion Sort",
        "description": "Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part. Insertion Sort Procedure: 1. To sort an array of size N in ascending order iterate over the array and compare the current element (key) to its predecessor, if the key element is smaller than its predecessor, compare it to the elements before. 2. Move the greater elements one position up to make space for the swapped element. Input: arr = [4, 3, 2, 10, 12, 1, 5, 6] Output: arr = [1, 2, 3, 4, 5, 6, 10, 12]",
        "starter_code": "import java.util.Scanner;\n\nclass InsertionSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void insertionSort(int[] arr)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "8\n4 3 2 10 12 1 5 6",
                "expected_output": "1 2 3 4 5 6 10 12",
                "is_visible": true
            },
            {
                "input": "5\n12 11 13 5 6",
                "expected_output": "5 6 11 12 13",
                "is_visible": true
            },
            {
                "input": "6\n3 7 4 9 2 6",
                "expected_output": "2 3 4 6 7 9",
                "is_visible": true
            },
            {
                "input": "7\n100 50 25 75 125 150 100",
                "expected_output": "25 50 75 100 100 125 150",
                "is_visible": true
            },
            {
                "input": "4\n9 8 7 6",
                "expected_output": "6 7 8 9",
                "is_visible": true
            },
            {
                "input": "10\n10 20 15 25 5 30 35 40 45 50",
                "expected_output": "5 10 15 20 25 30 35 40 45 50",
                "is_visible": false
            },
            {
                "input": "9\n99 55 77 33 88 22 66 44 11",
                "expected_output": "11 22 33 44 55 66 77 88 99",
                "is_visible": false
            },
            {
                "input": "12\n5 1 9 2 8 3 7 4 6 10 12 11",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12",
                "is_visible": false
            },
            {
                "input": "15\n45 23 67 12 89 34 78 56 90 11 99 22 33 44 55",
                "expected_output": "11 12 22 23 33 34 44 45 55 56 67 78 89 90 99",
                "is_visible": false
            },
            {
                "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "is_visible": false
            }
        ]
    },
    {
        "title": "4.1 Quick Sort",
        "description": "QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array. The key process in quickSort is a partition(). The target of partitions is to place the pivot (any element can be chosen to be a pivot) at its correct position in the sorted array and put all smaller elements to the left of the pivot, and all greater elements to the right of the pivot. Partition is done recursively on each side of the pivot after the pivot is placed in its correct position and this finally sorts the array. The quick sort method can be summarized in three steps: 1. Pick: Select a pivot element. 2. Divide: Split the problem set, move smaller parts to the left of the pivot and larger items to the right. 3. Repeat and combine: Repeat the steps and combine the arrays that have previously been sorted. Algorithm for Quick Sort Function: //start --> Starting index, end --> Ending index Quicksort(array, start, end) { if (start < end) { pIndex = Partition(A, start, end) Quicksort(A,start,pIndex-1) Quicksort(A,pIndex+1, end) } } Algorithm for Partition Function: partition (array, start, end) { // Setting rightmost Index as pivot pivot = arr[end]; i = (start - 1) // Index of smaller element and indicates the // right position of pivot found so far for (j = start; j <= end- 1; j++) { // If current element is smaller than the pivot if (arr[j] < pivot) { i++; // increment index of smaller element swap arr[i] and arr[j] } } swap arr[i + 1] and arr[end]) return (i + 1) } Input: arr = [10, 80, 30, 90, 40, 50, 70] Output: arr = [10, 30, 40, 50, 70, 80, 90]",
        "starter_code": "import java.util.Scanner;\n\nclass QuickSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void quickSort(int[] arr, int low, int high)\n    {\n    # write code here\n    }\n    public static int partition(int[] arr, int low, int high)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "7\n10 80 30 90 40 50 70",
                "expected_output": "10 30 40 50 70 80 90",
                "is_visible": true
            },
            {
                "input": "6\n38 27 43 3 9 82",
                "expected_output": "3 9 27 38 43 82",
                "is_visible": true
            },
            {
                "input": "8\n5 2 9 1 7 6 3 4",
                "expected_output": "1 2 3 4 5 6 7 9",
                "is_visible": true
            },
            {
                "input": "5\n100 50 150 75 125",
                "expected_output": "50 75 100 125 150",
                "is_visible": true
            },
            {
                "input": "9\n12 7 18 3 25 10 22 15 30",
                "expected_output": "3 7 10 12 15 18 22 25 30",
                "is_visible": true
            },
            {
                "input": "10\n45 23 67 12 89 34 78 56 90 11",
                "expected_output": "11 12 23 34 45 56 67 78 89 90",
                "is_visible": false
            },
            {
                "input": "12\n33 11 55 22 77 44 99 66 88 110 121 132",
                "expected_output": "11 22 33 44 55 66 77 88 99 110 121 132",
                "is_visible": false
            },
            {
                "input": "15\n5 1 9 2 8 3 7 4 6 10 15 12 13 11 14",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            },
            {
                "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "is_visible": false
            },
            {
                "input": "25\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "is_visible": false
            }
        ]
    },
    {
        "title": "4.2 Merge Sort",
        "description": "Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array. In simple terms, we can say that the process of merge sort is to divide the array into two halves, sort each half, and then merge the sorted halves back together. This process is repeated until the entire array is sorted. Input: arr = [12, 11, 13, 5, 6, 7] Output: arr = [5, 6, 7, 11, 12, 13]",
        "starter_code": "import java.util.Scanner;\n\nclass MergeSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void mergeSort(int[] arr, int low, int high)\n    {\n    # write code here\n    }\n    public static void merge(int[] arr, int low, int mid, int high)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "6\n12 11 13 5 6 7",
                "expected_output": "5 6 7 11 12 13",
                "is_visible": true
            },
            {
                "input": "8\n38 27 43 3 9 82 10 15",
                "expected_output": "3 9 10 15 27 38 43 82",
                "is_visible": true
            },
            {
                "input": "5\n50 30 40 20 10",
                "expected_output": "10 20 30 40 50",
                "is_visible": true
            },
            {
                "input": "7\n100 200 150 50 75 25 300",
                "expected_output": "25 50 75 100 150 200 300",
                "is_visible": true
            },
            {
                "input": "9\n9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9",
                "is_visible": true
            },
            {
                "input": "10\n45 23 67 12 89 34 78 56 90 11",
                "expected_output": "11 12 23 34 45 56 67 78 89 90",
                "is_visible": false
            },
            {
                "input": "12\n33 11 55 22 77 44 99 66 88 110 121 132",
                "expected_output": "11 22 33 44 55 66 77 88 99 110 121 132",
                "is_visible": false
            },
            {
                "input": "15\n5 1 9 2 8 3 7 4 6 10 15 12 13 11 14",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            },
            {
                "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "is_visible": false
            },
            {
                "input": "25\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "is_visible": false
            }
        ]
    },
    {
        "title": "4.3 Heap Sort",
        "description": "Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements. Heap Sort Procedure: First convert the array into heap data structure using heapify, then one by one delete the root node of the Max-heap and replace it with the last node in the heap and then heapify the root of the heap. Repeat this process until size of heap is greater than 1. Build a heap from the given input array. Repeat the following steps until the heap contains only one element: - Swap the root element of the heap (which is the largest element) with the last element of the heap. - Remove the last element of the heap (which is now in the correct position). - Heapify the remaining elements of the heap. - The sorted array is obtained by reversing the order of the elements in the input array. Input: arr = [12, 11, 13, 5, 6, 7] Output: Sorted array is 5 6 7 11 12 13",
        "starter_code": "import java.util.Scanner;\n\nclass HeapSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void heapSort(int[] arr)\n    {\n    # write code here\n    }\n    public static void heapify(int[] arr, int n, int i)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "6\n12 11 13 5 6 7",
                "expected_output": "5 6 7 11 12 13",
                "is_visible": true
            },
            {
                "input": "8\n4 10 3 5 1 2 8 7",
                "expected_output": "1 2 3 4 5 7 8 10",
                "is_visible": true
            },
            {
                "input": "5\n20 10 30 5 15",
                "expected_output": "5 10 15 20 30",
                "is_visible": true
            },
            {
                "input": "7\n100 50 25 75 125 150 100",
                "expected_output": "25 50 75 100 100 125 150",
                "is_visible": true
            },
            {
                "input": "9\n9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9",
                "is_visible": true
            },
            {
                "input": "10\n45 23 67 12 89 34 78 56 90 11",
                "expected_output": "11 12 23 34 45 56 67 78 89 90",
                "is_visible": false
            },
            {
                "input": "12\n33 11 55 22 77 44 99 66 88 110 121 132",
                "expected_output": "11 22 33 44 55 66 77 88 99 110 121 132",
                "is_visible": false
            },
            {
                "input": "15\n5 1 9 2 8 3 7 4 6 10 15 12 13 11 14",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            },
            {
                "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "is_visible": false
            },
            {
                "input": "25\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "is_visible": false
            }
        ]
    },
    {
        "title": "4.4 Radix Sort",
        "description": "Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. Rather than comparing elements directly, Radix Sort distributes the elements into buckets based on each digit's value. By repeatedly sorting the elements by their significant digits, from the least significant to the most significant, Radix Sort achieves the final sorted order. Radix Sort Procedure: The key idea behind Radix Sort is to exploit the concept of place value. 1. It assumes that sorting numbers digit by digit will eventually result in a fully sorted list. 2. Radix Sort can be performed using different variations, such as Least Significant Digit (LSD) Radix Sort or Most Significant Digit (MSD) Radix Sort. To perform radix sort on the array [170, 45, 75, 90, 802, 24, 2, 66], we follow these steps: Step 1: Find the largest element in the array, which is 802. It has three digits, so we will iterate three times, once for each significant place. Step 2: Sort the elements based on the unit place digits (X=0). We use a stable sorting technique, such as counting sort, to sort the digits at each significant place. Sorting based on the unit place: Perform counting sort on the array based on the unit place digits. The sorted array based on the unit place is [170, 90, 802, 2, 24, 45, 75, 66] Sorting based on unit digit Unsorted Sorted For Unit Digit Step 3: Sort the elements based on the tens place digits. Sorting based on the tens place: Perform counting sort on the array based on the tens place digits. The sorted array based on the tens place is [802, 2, 24, 45, 66, 170, 75, 90] Sorting based on 10's digit Unsorted Sorted Till 10'S Digit Step 4: Sort the elements based on the hundreds place digits. Sorting based on the hundreds place: Perform counting sort on the array based on the hundreds place digits. The sorted array based on the hundreds place is [2, 24, 45, 66, 75, 90, 170, 802] Step 5: The array is now sorted in ascending order. The final sorted array using radix sort is [2, 24, 45, 66, 75, 90, 170, 802]",
        "starter_code": "import java.util.Arrays;\n\nclass RadixSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void radixSort(int[] arr)\n    {\n    # write code here\n    }\n    public static int getMax(int[] arr)\n    {\n    # write code here\n    }\n    public static void countSort(int[] arr, int exp)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "8\n170 45 75 90 802 24 2 66",
                "expected_output": "2 24 45 66 75 90 170 802",
                "is_visible": true
            },
            {
                "input": "6\n329 457 657 839 436 720",
                "expected_output": "329 436 457 657 720 839",
                "is_visible": true
            },
            {
                "input": "5\n50 3 12 45 100",
                "expected_output": "3 12 45 50 100",
                "is_visible": true
            },
            {
                "input": "7\n1000 100 10 1 10000 100000 1000000",
                "expected_output": "1 10 100 1000 10000 100000 1000000",
                "is_visible": true
            },
            {
                "input": "9\n9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9",
                "is_visible": true
            },
            {
                "input": "10\n45 23 67 12 89 34 78 56 90 11",
                "expected_output": "11 12 23 34 45 56 67 78 89 90",
                "is_visible": false
            },
            {
                "input": "12\n333 111 555 222 777 444 999 666 888 110 121 132",
                "expected_output": "110 111 121 132 222 333 444 555 666 777 888 999",
                "is_visible": false
            },
            {
                "input": "15\n500 100 900 200 800 300 700 400 600 1000 1500 1200 1300 1100 1400",
                "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500",
                "is_visible": false
            },
            {
                "input": "20\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200",
                "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200",
                "is_visible": false
            },
            {
                "input": "25\n1000 900 800 700 600 500 400 300 200 100 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400 2500",
                "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400 2500",
                "is_visible": false
            }
        ]
    },
    {
        "title": "4.5 Shell Sort",
        "description": "Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h'th element are sorted. Shell Sort Procedure: 1. Initialize the value of gap size h 2. Divide the list into smaller sub-part. Each must have equal intervals to h 3. Sort these sub-lists using insertion sort 4. Repeat this step 1 until the list is sorted. 5. Print a sorted list.",
        "starter_code": "import java.util.Scanner;\n\nclass ShellSortExample\n{\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n    public static void shellSort(int[] arr)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "8\n23 12 1 5 9 8 10 2",
                "expected_output": "1 2 5 8 9 10 12 23",
                "is_visible": true
            },
            {
                "input": "6\n64 34 25 12 22 11",
                "expected_output": "11 12 22 25 34 64",
                "is_visible": true
            },
            {
                "input": "5\n5 1 4 2 3",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "7\n100 50 25 75 125 150 100",
                "expected_output": "25 50 75 100 100 125 150",
                "is_visible": true
            },
            {
                "input": "9\n9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9",
                "is_visible": true
            },
            {
                "input": "10\n45 23 67 12 89 34 78 56 90 11",
                "expected_output": "11 12 23 34 45 56 67 78 89 90",
                "is_visible": false
            },
            {
                "input": "12\n33 11 55 22 77 44 99 66 88 110 121 132",
                "expected_output": "11 22 33 44 55 66 77 88 99 110 121 132",
                "is_visible": false
            },
            {
                "input": "15\n5 1 9 2 8 3 7 4 6 10 15 12 13 11 14",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            },
            {
                "input": "20\n10 9 8 7 6 5 4 3 2 1 20 19 18 17 16 15 14 13 12 11",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "is_visible": false
            },
            {
                "input": "25\n100 90 80 70 60 50 40 30 20 10 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "expected_output": "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250",
                "is_visible": false
            }
        ]
    },
    {
        "title": "5.1 Implementation of Stack",
        "description": "A stack is a linear data structure that stores items in a Last-In/First-Out (LIFO) or First-In/Last-Out (FILO) manner. In stack, a new element is added at one end and an element is removed from that end only. The insert and delete operations are often called push and pop. The functions associated with stack are: empty() - Returns whether the stack is empty size() - Returns the size of the stack top() / peek() - Returns a reference to the topmost element of the stack push(a) - Inserts the element 'a' at the top of the stack pop() - Deletes the topmost element of the stack",
        "starter_code": "class Stack\n{\n    private int maxSize;\n    private int top;\n    private int[] stackArray;\n\n    public Stack(int size)\n    {\n    # write code here\n    }\n\n    public void push(int value)\n    {\n    # write code here\n    }\n\n    public int pop()\n    {\n    # write code here\n    }\n\n    public int peek()\n    {\n    # write code here\n    }\n\n    public boolean isEmpty()\n    {\n    # write code here\n    }\n    public boolean isFull()\n    {\n    # write code here\n    }\n}\n\nclass StackExample\n{\n    public static void main(String[] args)\n    {\n    Stack stack = new Stack(5);\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n    stack.pop();\n    stack.peek();\n    stack.push(40);\n    stack.push(50);\n    stack.push(60);\n    }\n}",
        "testcases": [
            {
                "input": "5\npush 10\npush 20\npush 30\npop\npeek\npush 40\npush 50\npush 60",
                "expected_output": "20",
                "is_visible": true
            },
            {
                "input": "3\npush 5\npush 10\npop",
                "expected_output": "10",
                "is_visible": true
            },
            {
                "input": "4\npush 100\npush 200\npop\npeek",
                "expected_output": "100",
                "is_visible": true
            },
            {
                "input": "6\npush 1\npush 2\npush 3\npop\npop\npeek",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "5\npush 99\npop\npush 88\npeek\npop",
                "expected_output": "88",
                "is_visible": true
            },
            {
                "input": "8\npush 10\npush 20\npush 30\npop\npush 40\npop\npeek\npush 50",
                "expected_output": "20",
                "is_visible": false
            },
            {
                "input": "10\npush 5\npush 10\npush 15\npop\npush 20\npop\npeek\npush 25\npush 30\npop",
                "expected_output": "15",
                "is_visible": false
            },
            {
                "input": "12\npush 100\npush 200\npush 300\npop\npush 400\npop\npeek\npush 500\npush 600\npop\npeek\npop",
                "expected_output": "200",
                "is_visible": false
            },
            {
                "input": "15\npush 1\npush 2\npush 3\npush 4\npush 5\npop\npop\npop\npeek\npush 6\npush 7\npop\npeek\npush 8\npop",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "20\npush 10\npush 20\npush 30\npush 40\npush 50\npop\npop\npush 60\npush 70\npop\npeek\npush 80\npush 90\npop\npop\npeek\npush 100\npop\npeek\npop",
                "expected_output": "40",
                "is_visible": false
            }
        ]
    },
    {
        "title": "5.2 Balanced Parenthesis Checking",
        "description": "Given an expression string, write a java program to find whether a given string has balanced parentheses or not. Input: \"(a+b)*(c-d)\" Output: true Input: \"(a+b)*(c-d)\" Output: false One approach to check balanced parentheses is to use stack. Each time, when an open parentheses is encountered push it in the stack, and when closed parenthesis is encountered, match it with the top of stack and pop it. If stack is empty at the end, return true otherwise, false",
        "starter_code": "import java.util.Stack;\n\nclass BalancedParenthesisChecker\n{\n    public static boolean isBalanced(String expression)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    String expression1 = \"{{a+b}}*(c-d)};\n    String expression2 = \"{{a+b}}*[c-d)};\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "(a+b)*(c-d)",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "{{a+b}}*(c-d)}",
                "expected_output": "false",
                "is_visible": true
            },
            {
                "input": "((a+b)*[c-d])",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "([{a+b}]*{c-d})",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "(a+b)*[c-d)",
                "expected_output": "false",
                "is_visible": true
            },
            {
                "input": "{[()()]}",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "[(])",
                "expected_output": "false",
                "is_visible": false
            },
            {
                "input": "{[(a+b)*(c-d)]/(e+f)}",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "(((((())))))",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "(()()()()",
                "expected_output": "false",
                "is_visible": false
            }
        ]
    },
    {
        "title": "5.3 Evaluation of Postfix Expression",
        "description": "Given a postfix expression, the task is to evaluate the postfix expression. Postfix expression: The expression of the form \"a b operator\" (ab+) i.e., when a pair of operands is followed by an operator. Input: str = \"2 3 1 * + 9 -\" Output: -4 Explanation: If the expression is converted into an infix expression, it will be 2 + (3 * 1) - 9 = 5 - 9 = -4. Input: str = \"100 200 + 2 / 5 * 7 +\" Output: 757 Procedure for evaluation postfix expression using stack: - Create a stack to store operands (or values). - Scan the given expression from left to right and do the following for every scanned element. - if the element is a number, push it into the stack. - if the element is an operator, pop operands for the operator from the stack. Evaluate the operator and push the result back to the stack. - When the expression is ended, the number in the stack is the final answer.",
        "starter_code": "import java.util.Stack;\n\nclass PostfixEvaluator\n{\n    public static int evaluatePostfix(String expression)\n    {\n    # write code here\n    }\n    public static int performOperation(char operator, int operand1, int operand2)\n    {\n    # write code here\n    }\n    public static void main(String[] args)\n    {\n    # write code here\n    }\n}",
        "testcases": [
            {
                "input": "2 3 1 * + 9 -",
                "expected_output": "-4",
                "is_visible": true
            },
            {
                "input": "100 200 + 2 / 5 * 7 +",
                "expected_output": "757",
                "is_visible": true
            },
            {
                "input": "5 1 2 + 4 * + 3 -",
                "expected_output": "14",
                "is_visible": true
            },
            {
                "input": "10 2 * 3 +",
                "expected_output": "23",
                "is_visible": true
            },
            {
                "input": "4 5 6 * +",
                "expected_output": "34",
                "is_visible": true
            },
            {
                "input": "3 4 + 2 * 7 /",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "5 1 2 + 4 * 3 - +",
                "expected_output": "14",
                "is_visible": false
            },
            {
                "input": "2 3 ^ 4 5 + +",
                "expected_output": "17",
                "is_visible": false
            },
            {
                "input": "15 7 1 1 + - / 3 * 2 1 1 + + -",
                "expected_output": "5",
                "is_visible": false
            },
            {
                "input": "3 4 2 * 1 5 - 2 ^ / +",
                "expected_output": "11",
                "is_visible": false
            }
        ]
    },
    {
        "title": "5.4 Infix to Postfix Expression Conversion",
        "description": "For a given Infix expression, convert it into Postfix form. Infix expression: The expression of the form \"a operator b\" (a + b) i.e., when an operator is in-between every pair of operands. Postfix expression: The expression of the form \"a b operator\" (ab+) i.e., When every pair of operands is followed by an operator. Infix to postfix expression conversion procedure: 1. Scan the infix expression from left to right. 2. If the scanned character is an operand, put it in the postfix expression. 3. Otherwise, do the following - If the precedence and associativity of the scanned operator are greater than the precedence and associativity of the operator in the stack [or the stack is empty or the stack contains a '('], then push it in the stack. I'^' operator is right associative and other operators like '+',--',*' and '/' are left-associative]. - Check especially for a condition when the operator at the top of the stack and the scanned operator both are '^'. In this condition, the precedence of the scanned operator is higher due to its right associativity. So it will be pushed into the operator stack. - In all the other cases when the top of the operator stack is the same as the scanned operator, then pop the operator from the stack because of left associativity due to which the scanned operator has less precedence. - Else, Pop all the operators from the stack which are greater than or equal to in precedence than that of the scanned operator. - After doing that Push the scanned operator to the stack. (If you encounter parenthesis while popping then stop there and push the scanned operator in the stack.) 4. If the scanned character is a '(', push it to the stack. 5. If the scanned character is a ')', pop the stack and output it until a '(' is encountered, and discard both the parenthesis. 6. Repeat steps 2-5 until the infix expression is scanned. 7. Once the scanning is over, Pop the stack and add the operators in the postfix expression until it is not empty. 8. Finally, print the postfix expression. Input: A + B * C + D Output: A B C * + D + Input: ((A + B) - C * (D / E)) + F Output: A B + C D E / * - F +",
        "starter_code": "import java.util.Stack;\n\nclass Conversion\n{\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "A+B*C+D",
                "expected_output": "ABC*+D+",
                "is_visible": true
            },
            {
                "input": "((A+B)-C*(D/E))+F",
                "expected_output": "AB+CD/E/*-F+",
                "is_visible": true
            },
            {
                "input": "a+b*c-d/e",
                "expected_output": "abc*+de/-",
                "is_visible": true
            },
            {
                "input": "(a+b)*(c-d)",
                "expected_output": "ab+cd-*",
                "is_visible": true
            },
            {
                "input": "a^b^c",
                "expected_output": "abc^^",
                "is_visible": true
            },
            {
                "input": "a+b*c/d-e",
                "expected_output": "abc*d/+e-",
                "is_visible": false
            },
            {
                "input": "(a+b)*(c/d-e)",
                "expected_output": "ab+cd/e-*",
                "is_visible": false
            },
            {
                "input": "a+b*(c^d-e)^(f+g*h)-i",
                "expected_output": "abcd^e-fgh*+^*+i-",
                "is_visible": false
            },
            {
                "input": "((a+b)*c-(d-e))/(f+g)",
                "expected_output": "ab+c*de--fg+/",
                "is_visible": false
            },
            {
                "input": "a+b*c-d/e^f*g",
                "expected_output": "abc*+def^/g*-",
                "is_visible": false
            }
        ]
    },
    {
        "title": "5.5 Reverse a Stack",
        "description": "The stack is a linear data structure which works on the LIFO concept. LIFO stands for last in first out. In the stack, the insertion and deletion are possible at one end the end is called the top of the stack. Define two recursive functions BottomInsertion() and Reverse() to reverse a stack using Python. Define some basic function of the stack like push(), pop(), show(), empty(), for basic operation like respectively append an item in stack, remove an item in stack, display the stack, check the given stack is empty or not. BottomInsertion(): this method append element at the bottom of the stack and BottomInsertion accept two values as an argument first is stack and the second is elements, this is a recursive method. Reverse(): the method is reverse elements of the stack, this method accept stack as an argument Reverse() is also a Recursive() function. Reverse() is invoked BottomInsertion() method for completing the reverse operation on the stack. Input: Elements = [1, 2, 3, 4, 5] Output: Original Stack 5 4 3 2 1 Stack after Reversing 1 2 3 4 5",
        "starter_code": "import java.util.Stack;\nclass StackClass {\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "5\n1 2 3 4 5",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "3\n10 20 30",
                "expected_output": "10 20 30",
                "is_visible": true
            },
            {
                "input": "6\n6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6",
                "is_visible": true
            },
            {
                "input": "4\n100 200 300 400",
                "expected_output": "400 300 200 100",
                "is_visible": true
            },
            {
                "input": "7\n7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7",
                "is_visible": true
            },
            {
                "input": "8\n1 3 5 7 9 11 13 15",
                "expected_output": "15 13 11 9 7 5 3 1",
                "is_visible": false
            },
            {
                "input": "10\n10 9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9 10",
                "is_visible": false
            },
            {
                "input": "12\n12 11 10 9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12",
                "is_visible": false
            },
            {
                "input": "15\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            },
            {
                "input": "20\n20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "is_visible": false
            }
        ]
    },
    {
        "title": "6.1 Linear Queue",
        "description": "Linear queue is a linear data structure that stores items in First in First out (FIFO) manner. With a queue the least recently added item is removed first. A good example of queue is any queue of consumers for a resource where the consumer that came first is served first.",
        "starter_code": "import java.util.Scanner;\n\npublic class LinearQueue\n{\n    # Write Code Here\n}\n\npublic static boolean isEmpty() {\n    return front == rear;\n}\n\npublic static boolean isFull() {\n    return rear == MAX;\n}\n\npublic static void enqueue(int item)\n{\n    # Write Code Here\n}\n\npublic static void dequeue()\n{\n    # Write Code Here\n}\n\npublic static void display()\n{\n    # Write Code Here\n}\n\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "5\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\ndisplay",
                "expected_output": "30 40",
                "is_visible": true
            },
            {
                "input": "3\nenqueue 5\nenqueue 10\ndequeue",
                "expected_output": "10",
                "is_visible": true
            },
            {
                "input": "4\nenqueue 100\nenqueue 200\ndequeue\ndequeue",
                "expected_output": "Queue is empty",
                "is_visible": true
            },
            {
                "input": "6\nenqueue 1\nenqueue 2\nenqueue 3\ndequeue\nenqueue 4\ndisplay",
                "expected_output": "2 3 4",
                "is_visible": true
            },
            {
                "input": "5\nenqueue 99\ndequeue\nenqueue 88\ndequeue\ndequeue",
                "expected_output": "Queue is empty",
                "is_visible": true
            },
            {
                "input": "8\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\nenqueue 50\ndisplay",
                "expected_output": "30 40 50",
                "is_visible": false
            },
            {
                "input": "10\nenqueue 5\nenqueue 10\nenqueue 15\ndequeue\nenqueue 20\ndequeue\nenqueue 25\nenqueue 30\ndequeue\ndisplay",
                "expected_output": "20 25 30",
                "is_visible": false
            },
            {
                "input": "12\nenqueue 100\nenqueue 200\nenqueue 300\ndequeue\nenqueue 400\ndequeue\nenqueue 500\nenqueue 600\ndequeue\ndequeue\ndequeue\ndisplay",
                "expected_output": "600",
                "is_visible": false
            },
            {
                "input": "15\nenqueue 1\nenqueue 2\nenqueue 3\nenqueue 4\nenqueue 5\ndequeue\ndequeue\ndequeue\nenqueue 6\nenqueue 7\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
                "expected_output": "7",
                "is_visible": false
            },
            {
                "input": "20\nenqueue 10\nenqueue 20\nenqueue 30\nenqueue 40\nenqueue 50\ndequeue\ndequeue\nenqueue 60\nenqueue 70\ndequeue\nenqueue 80\nenqueue 90\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
                "expected_output": "Queue is empty",
                "is_visible": false
            }
        ]
    },
    {
        "title": "6.2 Stack using Queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). - void push(int x) Pushes element x to the top of the stack. - int pop() Removes the element on the top of the stack and returns it. - int top() Returns the element on the top of the stack. - boolean empty() Returns true if the stack is empty, false otherwise. Input: [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], []], []] Output: [null, null, null, 2, 2, false]",
        "starter_code": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass MyStack\n{\n    # Write Code Here\n    }\npublic void push(int x)\n{\n    # Write Code Here\n    }\n}\n\npublic int pop()\n{\n    return queue.remove();\n}\n\npublic int top()\n{\n    return queue.peek();\n}\n\npublic boolean empty()\n{\n    return queue.isEmpty();\n}\n\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "push 1\npush 2\ntop\npop\nempty",
                "expected_output": "2\n2\nfalse",
                "is_visible": true
            },
            {
                "input": "push 10\npush 20\npop\ntop",
                "expected_output": "20\n10",
                "is_visible": true
            },
            {
                "input": "push 5\npop\nempty",
                "expected_output": "5\ntrue",
                "is_visible": true
            },
            {
                "input": "push 100\npush 200\npush 300\npop\npop\ntop",
                "expected_output": "300\n200\n100",
                "is_visible": true
            },
            {
                "input": "empty\npush 50\nempty",
                "expected_output": "true\nfalse",
                "is_visible": true
            },
            {
                "input": "push 1\npush 2\npush 3\npop\npush 4\npop\ntop",
                "expected_output": "3\n4\n2",
                "is_visible": false
            },
            {
                "input": "push 10\npush 20\npush 30\npop\npop\npush 40\npop\ntop",
                "expected_output": "30\n20\n40\n10",
                "is_visible": false
            },
            {
                "input": "empty\npush 5\npush 10\npop\nempty\npush 15\npop\ntop",
                "expected_output": "true\n10\nfalse\n15\n5",
                "is_visible": false
            },
            {
                "input": "push 1\npush 2\npush 3\npush 4\npush 5\npop\npop\npop\npop\npop\nempty",
                "expected_output": "5\n4\n3\n2\n1\ntrue",
                "is_visible": false
            },
            {
                "input": "push 100\npush 200\npop\npush 300\npush 400\npop\npop\ntop\nempty",
                "expected_output": "200\n400\n300\n100\nfalse",
                "is_visible": false
            }
        ]
    },
    {
        "title": "6.3 Queue using Stacks",
        "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). - void push(int x) Pushes element x to the back of the queue. - int pop() Removes the element from the front of the queue and returns it. - int peek() Returns the element at the front of the queue. - boolean empty() Returns true if the queue is empty, false otherwise. Input: [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], []], []] Output: [null, null, null, 1, 1, false]",
        "starter_code": "import java.util.Stack;\n\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    public MyQueue() {\n    stack1 = new Stack>();\n    stack2 = new Stack>();\n    }\n    public void push(int x) {\n    stack1.push(x);\n    }\n    public int pop()\n    {\n    # Write Code Here\n    }\n    public int peek()\n    {\n    # Write Code Here\n    }\n    public boolean empty() {\n    return stack1.isEmpty() && stack2.isEmpty();\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "push 1\npush 2\npeek\npop\nempty",
                "expected_output": "1\n1\nfalse",
                "is_visible": true
            },
            {
                "input": "push 10\npush 20\npop\npeek",
                "expected_output": "10\n20",
                "is_visible": true
            },
            {
                "input": "push 5\npop\nempty",
                "expected_output": "5\ntrue",
                "is_visible": true
            },
            {
                "input": "push 100\npush 200\npush 300\npop\npop\npeek",
                "expected_output": "100\n200\n300",
                "is_visible": true
            },
            {
                "input": "empty\npush 50\nempty",
                "expected_output": "true\nfalse",
                "is_visible": true
            },
            {
                "input": "push 1\npush 2\npush 3\npop\npush 4\npop\npeek",
                "expected_output": "1\n2\n3",
                "is_visible": false
            },
            {
                "input": "push 10\npush 20\npush 30\npop\npop\npush 40\npop\npeek",
                "expected_output": "10\n20\n30\n40",
                "is_visible": false
            },
            {
                "input": "empty\npush 5\npush 10\npop\nempty\npush 15\npop\npeek",
                "expected_output": "true\n5\nfalse\n10\n15",
                "is_visible": false
            },
            {
                "input": "push 1\npush 2\npush 3\npush 4\npush 5\npop\npop\npop\npop\npop\nempty",
                "expected_output": "1\n2\n3\n4\n5\ntrue",
                "is_visible": false
            },
            {
                "input": "push 100\npush 200\npop\npush 300\npush 400\npop\npop\npeek\nempty",
                "expected_output": "100\n200\n300\n400\nfalse",
                "is_visible": false
            }
        ]
    },
    {
        "title": "6.4 Circular Queue",
        "description": "A Circular Queue is an extended version of a normal queue where the last element of the queue is connected to the first element of the queue forming a circle. The operations are performed based on FIFO (First In First Out) principle. It is also called 'Ring Buffer'. Operations on Circular Queue: - Front: Get the front item from the queue. - Rear: Get the last item from the queue. - enQueue(value) This function is used to insert an element into the circular queue. In a circular queue, the new element is always inserted at the rear position. - Check whether the queue is full - [i.e., the rear end is in just before the front end in a circular manner]. - If it is full then display Queue is full. - If the queue is not full then, insert an element at the end of the queue. deQueue() This function is used to delete an element from the circular queue. In a circular queue, the element is always deleted from the front position. - Check whether the queue is Empty. - If it is empty then display Queue is empty. - If the queue is not empty, then get the last element and remove it from the queue. Implement Circular Queue using Array: 1. Initialize an array queue of size n, where n is the maximum number of elements that the queue can hold. 2. Initialize two variables front and rear to -1. 3. Enqueue: To enqueue an element x into the queue, do the following: - Increment rear by 1. - If rear is equal to n, set rear to 0. - If front is -1, set front to 0. - Set queue[rear] to x. 4. Dequeue: To dequeue an element from the queue, do the following: - Check if the queue is empty by checking if front is -1. - If it is, return an error message indicating that the queue is empty. - Set x to queue [front]. - If front is equal to rear, set front and rear to -1. - Otherwise, increment front by 1 and if front is equal to n, set front to 0. - Return x.",
        "starter_code": "class CircularQueue {\n    private int size;\n    private int front, rear;\n    private int[] queue;\n\n    public CircularQueue(int size) {\n    this.size = size;\n    this.queue = new int[size];\n    this.front = this.rear = -1;\n}\n\n    public void enqueue(int data)\n    {\n    # Write Code Here\n    }\n    public int dequeue()\n    {\n    # Write Code Here\n    }\n    public void display()\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "5\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\ndisplay",
                "expected_output": "30 40",
                "is_visible": true
            },
            {
                "input": "3\nenqueue 5\nenqueue 10\ndequeue",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "4\nenqueue 100\nenqueue 200\ndequeue\ndequeue",
                "expected_output": "Queue is empty",
                "is_visible": true
            },
            {
                "input": "6\nenqueue 1\nenqueue 2\nenqueue 3\ndequeue\nenqueue 4\ndisplay",
                "expected_output": "2 3 4",
                "is_visible": true
            },
            {
                "input": "5\nenqueue 99\ndequeue\nenqueue 88\ndequeue\ndequeue",
                "expected_output": "Queue is empty",
                "is_visible": true
            },
            {
                "input": "8\nenqueue 10\nenqueue 20\nenqueue 30\ndequeue\nenqueue 40\ndequeue\nenqueue 50\nenqueue 60\nenqueue 70\ndisplay",
                "expected_output": "30 40 50 60 70",
                "is_visible": false
            },
            {
                "input": "10\nenqueue 5\nenqueue 10\nenqueue 15\ndequeue\nenqueue 20\ndequeue\nenqueue 25\nenqueue 30\ndequeue\ndequeue\ndisplay",
                "expected_output": "20 25 30",
                "is_visible": false
            },
            {
                "input": "12\nenqueue 100\nenqueue 200\nenqueue 300\ndequeue\nenqueue 400\ndequeue\nenqueue 500\nenqueue 600\ndequeue\ndequeue\ndequeue\ndisplay",
                "expected_output": "600",
                "is_visible": false
            },
            {
                "input": "15\nenqueue 1\nenqueue 2\nenqueue 3\nenqueue 4\nenqueue 5\ndequeue\ndequeue\ndequeue\nenqueue 6\nenqueue 7\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
                "expected_output": "6 7",
                "is_visible": false
            },
            {
                "input": "20\nenqueue 10\nenqueue 20\nenqueue 30\nenqueue 40\nenqueue 50\ndequeue\ndequeue\nenqueue 60\nenqueue 70\ndequeue\nenqueue 80\nenqueue 90\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndequeue\ndisplay",
                "expected_output": "Queue is empty",
                "is_visible": false
            }
        ]
    },
    {
        "title": "6.5 Deque (Doubly Ended Queue)",
        "description": "In a Deque (Doubly Ended Queue), one can perform insert (append) and delete (pop) operations from both the ends of the container. There are two types of Deque: 1. Input Restricted Deque: Input is limited at one end while deletion is permitted at both ends. 2. Output Restricted Deque: Output is limited at one end but insertion is permitted at both ends. Operations on Deque: 1. append(): This function is used to insert the value in its argument to the right end of the deque. 2. appendleft(): This function is used to insert the value in its argument to the left end of the deque. 3. pop(): This function is used to delete an argument from the right end of the deque. 4. popleft(): This function is used to delete an argument from the left end of the deque. 5. index(ele, beg, end): This function returns the first index of the value mentioned in arguments, starting searching from beg till end index. 6. insert(i, a): This function inserts the value mentioned in arguments(a) at index(i) specified in arguments. 7. remove(): This function removes the first occurrence of the value mentioned in arguments. 8. count(): This function counts the number of occurrences of value mentioned in arguments. 9. len(dequeue): Return the current size of the dequeue. 10. Deque[0]: We can access the front element of the deque using indexing with de[0]. 11. Deque[-1]: We can access the back element of the deque using indexing with de[-1]. 12. extend(tterable): This function is used to add multiple values at the right end of the deque. The argument passed is iterable. 13. extendleft(tterable): This function is used to add multiple values at the left end of the deque. The argument passed is iterable. Order is reversed as a result of left appends. 14. reverse(): This function is used to reverse the order of deque elements. 15. rotate(): This function rotates the deque by the number specified in arguments. If the number specified is negative, rotation occurs to the left. Else rotation is to right.",
        "starter_code": "import java.util.ArrayList;\nimport java.util.Deque;\n\npublic class DequeOperations\n{\n    # White Code Here\n}",
        "testcases": [
            {
                "input": "append 10\nappend 20\nappend 30\npopleft\npop\ndisplay",
                "expected_output": "20",
                "is_visible": true
            },
            {
                "input": "appendleft 5\nappend 10\nappend 15\npopleft\nappend 20\ndisplay",
                "expected_output": "10 15 20",
                "is_visible": true
            },
            {
                "input": "append 100\nappend 200\npopleft\npop\ndisplay",
                "expected_output": "Deque is empty",
                "is_visible": true
            },
            {
                "input": "append 1\nappend 2\nappendleft 0\npop\ndisplay",
                "expected_output": "0 1",
                "is_visible": true
            },
            {
                "input": "append 50\nappendleft 40\nappend 60\npopleft\nappendleft 30\ndisplay",
                "expected_output": "30 50 60",
                "is_visible": true
            },
            {
                "input": "append 10\nappend 20\nappend 30\nappendleft 5\nappendleft 1\npop\npopleft\ndisplay",
                "expected_output": "5 10 20",
                "is_visible": false
            },
            {
                "input": "append 100\nappend 200\nappend 300\npopleft\nappendleft 50\nappend 400\npop\ndisplay",
                "expected_output": "50 200 300",
                "is_visible": false
            },
            {
                "input": "append 1\nappend 2\nappend 3\nappendleft 0\nappend 4\npopleft\npop\nappendleft -1\ndisplay",
                "expected_output": "-1 1 2 3",
                "is_visible": false
            },
            {
                "input": "append 10\nappend 20\nappend 30\nappend 40\nappend 50\npopleft\npopleft\nappendleft 5\nappend 60\npop\ndisplay",
                "expected_output": "5 30 40 50",
                "is_visible": false
            },
            {
                "input": "append 100\nappend 200\nappendleft 50\nappend 300\nappendleft 25\npopleft\npop\nappend 400\nappendleft 75\ndisplay",
                "expected_output": "75 50 100 200 300",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.1 Singly Linked List",
        "description": "A singly linked list is a linear data structure in which the elements are not stored in contiguous memory locations and each element is connected only to its next element using a pointer. Creating a linked list involves the following operations: 1. Creating a Node class: 2. Insertion at beginning: 3. Insertion at end 4. Insertion at middle 5. Update the node 6. Deletion at beginning 7. Deletion at end 8. Deletion at middle 9. Remove last node 10. Linked list traversal 11. Get length",
        "starter_code": "class Node {\n    String data;\n    Node next;\n\n    Node(String data) {\n    this.data = data;\n    this.next = null;\n}\n\nclass LinkedList {\n    # Write Code Here\n    }\n\n    public void insertAtEnd(String data)\n    {\n    # Write Code Here\n    }\n\n    public void updateNode(String val, int index)\n    {\n    # Write Code Here\n    }\n\n    public void remove_first_node() {\n    # Write Code Here\n    }\n    public void remove_last_node()\n    {\n    # Write Code Here\n    }\n    public void remove_at_index(int index)\n    {\n    # Write Code Here\n    }\n    public void remove_node(String data)\n    {\n    # Write Code Here\n    }\n    public int sizeOfLL()\n    {\n    # Write Code Here\n    }\n    public void println()\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "insertAtEnd A\ninsertAtEnd B\ninsertAtEnd C\nremove_first_node\nprintln",
                "expected_output": "B C",
                "is_visible": true
            },
            {
                "input": "insertAtEnd 10\ninsertAtEnd 20\ninsertAtEnd 30\nremove_last_node\nprintln",
                "expected_output": "10 20",
                "is_visible": true
            },
            {
                "input": "insertAtEnd X\ninsertAtEnd Y\ninsertAtEnd Z\nremove_at_index 1\nprintln",
                "expected_output": "X Z",
                "is_visible": true
            },
            {
                "input": "insertAtEnd apple\ninsertAtEnd banana\ninsertAtEnd cherry\nremove_node banana\nprintln",
                "expected_output": "apple cherry",
                "is_visible": true
            },
            {
                "input": "insertAtEnd 1\ninsertAtEnd 2\ninsertAtEnd 3\nsizeOfLL",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "insertAtEnd A\ninsertAtEnd B\ninsertAtEnd C\ninsertAtEnd D\nremove_at_index 2\nremove_first_node\nprintln",
                "expected_output": "B D",
                "is_visible": false
            },
            {
                "input": "insertAtEnd 10\ninsertAtEnd 20\ninsertAtEnd 30\ninsertAtEnd 40\nupdateNode 25 2\nremove_last_node\nprintln",
                "expected_output": "10 20 25",
                "is_visible": false
            },
            {
                "input": "insertAtEnd red\ninsertAtEnd green\ninsertAtEnd blue\ninsertAtEnd yellow\nremove_node green\nremove_at_index 0\nprintln",
                "expected_output": "blue yellow",
                "is_visible": false
            },
            {
                "input": "insertAtEnd 1\ninsertAtEnd 2\ninsertAtEnd 3\ninsertAtEnd 4\ninsertAtEnd 5\nremove_first_node\nremove_last_node\nremove_at_index 1\nprintln",
                "expected_output": "2 4",
                "is_visible": false
            },
            {
                "input": "insertAtEnd A\ninsertAtEnd B\ninsertAtEnd C\ninsertAtEnd D\ninsertAtEnd E\nremove_node C\nupdateNode X 1\nremove_first_node\nsizeOfLL",
                "expected_output": "3",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.2 Linked List Cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Input: head = [3, 2, 0, -4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Input: head = [1, 2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.",
        "starter_code": "class ListNode {\n    # Write Code Here\n    }\n\npublic class Solution\n    {\n    # Write Code Here\n    }",
        "testcases": [
            {
                "input": "4\n3 2 0 -4\n1",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "2\n1 2\n0",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "1\n1\n-1",
                "expected_output": "false",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5\n-1",
                "expected_output": "false",
                "is_visible": true
            },
            {
                "input": "3\n1 2 3\n0",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "6\n10 20 30 40 50 60\n3",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "7\n1 2 3 4 5 6 7\n6",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "8\n5 4 3 2 1 0 -1 -2\n-1",
                "expected_output": "false",
                "is_visible": false
            },
            {
                "input": "10\n1 2 3 4 5 6 7 8 9 10\n9",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "12\n100 200 300 400 500 600 700 800 900 1000 1100 1200\n-1",
                "expected_output": "false",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.3 Remove Linked List Elements",
        "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. Input: head = [1, 2, 6, 3, 4, 5, 6], val = 6 Output: [1, 2, 3, 4, 5] Input: head = [ ], val = 1 Output: [] Input: head = [7, 7, 7, 7], val = 7 Output: []",
        "starter_code": "class ListNode {\n    # Write Code Here\n    }\n}\n\npublic class Solution {\n    public boolean hasCycle(ListNode head)\n    {\n    # Write Code Here\n    }\n\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "7\n1 2 6 3 4 5 6\n6",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "0\n\n1",
                "expected_output": "",
                "is_visible": true
            },
            {
                "input": "4\n7 7 7 7\n7",
                "expected_output": "",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5\n10",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "6\n10 20 10 30 10 40\n10",
                "expected_output": "20 30 40",
                "is_visible": true
            },
            {
                "input": "8\n5 1 5 2 5 3 5 4\n5",
                "expected_output": "1 2 3 4",
                "is_visible": false
            },
            {
                "input": "10\n1 1 2 2 3 3 4 4 5 5\n3",
                "expected_output": "1 1 2 2 4 4 5 5",
                "is_visible": false
            },
            {
                "input": "12\n100 200 300 100 200 300 100 200 300 100 200 300\n100",
                "expected_output": "200 300 200 300 200 300 200 300",
                "is_visible": false
            },
            {
                "input": "15\n0 1 0 2 0 3 0 4 0 5 0 6 0 7 0\n0",
                "expected_output": "1 2 3 4 5 6 7",
                "is_visible": false
            },
            {
                "input": "20\n5 10 5 15 5 20 5 25 5 30 5 35 5 40 5 45 5 50 5 55\n5",
                "expected_output": "10 15 20 25 30 35 40 45 50 55",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.4 Reverse Linked List",
        "description": "Given the head of a singly linked list, reverse the list, and return the reversed list. Input: head = [1, 2, 3, 4, 5] Output: [5, 4, 3, 2, 1] Input: head = [1, 2] Output: [2, 1]",
        "starter_code": "class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int val) {\n    this.val = val;\n    this.next = null;\n    }\n}\n\npublic class Solution {\n    public ListNode reverselist(ListNode head)\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "5\n1 2 3 4 5",
                "expected_output": "5 4 3 2 1",
                "is_visible": true
            },
            {
                "input": "2\n1 2",
                "expected_output": "2 1",
                "is_visible": true
            },
            {
                "input": "1\n10",
                "expected_output": "10",
                "is_visible": true
            },
            {
                "input": "4\n4 3 2 1",
                "expected_output": "1 2 3 4",
                "is_visible": true
            },
            {
                "input": "3\n100 200 300",
                "expected_output": "300 200 100",
                "is_visible": true
            },
            {
                "input": "6\n1 3 5 7 9 11",
                "expected_output": "11 9 7 5 3 1",
                "is_visible": false
            },
            {
                "input": "8\n10 20 30 40 50 60 70 80",
                "expected_output": "80 70 60 50 40 30 20 10",
                "is_visible": false
            },
            {
                "input": "10\n5 10 15 20 25 30 35 40 45 50",
                "expected_output": "50 45 40 35 30 25 20 15 10 5",
                "is_visible": false
            },
            {
                "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12",
                "expected_output": "12 11 10 9 8 7 6 5 4 3 2 1",
                "is_visible": false
            },
            {
                "input": "15\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500",
                "expected_output": "1500 1400 1300 1200 1100 1000 900 800 700 600 500 400 300 200 100",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.5 Palindrome Linked List",
        "description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise. Input: head = [1, 2, 2, 1] Output: true Input: head = [1, 2] Output: false",
        "starter_code": "class ListNode\n{\n    # Write Code Here\n}\npublic class Solution {\n    public boolean isPalindrome(ListNode head)\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "4\n1 2 2 1",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "2\n1 2",
                "expected_output": "false",
                "is_visible": true
            },
            {
                "input": "3\n1 2 1",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "1\n5",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 2 1",
                "expected_output": "true",
                "is_visible": true
            },
            {
                "input": "6\n1 2 3 3 2 1",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "7\n1 2 3 4 3 2 1",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "8\n1 2 3 4 4 3 2 1",
                "expected_output": "true",
                "is_visible": false
            },
            {
                "input": "5\n1 2 3 4 5",
                "expected_output": "false",
                "is_visible": false
            },
            {
                "input": "10\n1 2 3 4 5 5 4 3 2 1",
                "expected_output": "true",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.6 Middle of the Linked List",
        "description": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. Input: head = [1, 2, 3, 4, 5] Output: [3, 4, 5] Explanation: The middle node of the list is node 3. Input: head = [1, 2, 3, 4, 5, 6] Output: [4, 5, 6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.",
        "starter_code": "class ListNode\n{\n    # Write Code Here\n}\n\npublic class Solution\n{\n    # Write Code Here\n}\n\npublic static void main(String[] args) {\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "5\n1 2 3 4 5",
                "expected_output": "3 4 5",
                "is_visible": true
            },
            {
                "input": "6\n1 2 3 4 5 6",
                "expected_output": "4 5 6",
                "is_visible": true
            },
            {
                "input": "1\n10",
                "expected_output": "10",
                "is_visible": true
            },
            {
                "input": "3\n100 200 300",
                "expected_output": "200 300",
                "is_visible": true
            },
            {
                "input": "2\n5 10",
                "expected_output": "10",
                "is_visible": true
            },
            {
                "input": "7\n1 2 3 4 5 6 7",
                "expected_output": "4 5 6 7",
                "is_visible": false
            },
            {
                "input": "8\n10 20 30 40 50 60 70 80",
                "expected_output": "50 60 70 80",
                "is_visible": false
            },
            {
                "input": "9\n1 3 5 7 9 11 13 15 17",
                "expected_output": "9 11 13 15 17",
                "is_visible": false
            },
            {
                "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12",
                "expected_output": "7 8 9 10 11 12",
                "is_visible": false
            },
            {
                "input": "15\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500",
                "expected_output": "800 900 1000 1100 1200 1300 1400 1500",
                "is_visible": false
            }
        ]
    },
    {
        "title": "7.7 Convert Binary Number in a Linked List to Integer",
        "description": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list. Input: head = [1, 0, 1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 Input: head = [0] Output: 0",
        "starter_code": "class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int val) {\n    this.val = val;\n    this.next = null;\n    }\n}\n\npublic class Solution\n{\n    # White Code Here\n}\n\npublic static void main(String[] args)\n{\n    # White Code Here\n}",
        "testcases": [
            {
                "input": "3\n1 0 1",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "1\n0",
                "expected_output": "0",
                "is_visible": true
            },
            {
                "input": "4\n1 1 1 1",
                "expected_output": "15",
                "is_visible": true
            },
            {
                "input": "5\n1 0 1 0 1",
                "expected_output": "21",
                "is_visible": true
            },
            {
                "input": "2\n1 0",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "6\n1 0 0 1 1 0",
                "expected_output": "38",
                "is_visible": false
            },
            {
                "input": "8\n1 1 0 0 1 1 0 1",
                "expected_output": "205",
                "is_visible": false
            },
            {
                "input": "10\n1 0 1 0 1 0 1 0 1 0",
                "expected_output": "682",
                "is_visible": false
            },
            {
                "input": "12\n1 1 1 1 0 0 0 0 1 1 1 1",
                "expected_output": "3855",
                "is_visible": false
            },
            {
                "input": "15\n1 0 0 0 0 0 0 0 0 0 0 0 0 0 1",
                "expected_output": "16385",
                "is_visible": false
            }
        ]
    },
    {
        "title": "8.1 Circular Linked List",
        "description": "The circular linked list is a linked list where all nodes are connected to form a circle. In a circular linked list, the first node and the last node are connected to each other which forms a circle. There is no NULL at the end. Operations on the circular linked list: 1. Insertion at the beginning 2. Insertion at the end 3. Insertion in between the nodes 4. Deletion at the beginning 5. Deletion at the end 6. Deletion in between the nodes 7. Traversal",
        "starter_code": "import java.util.ArrayList;\npublic class Main{\n    static class Node{\n    int data;\n    Node next;\n    Node(int data){\n    this.data = data;\n    this.next = null;\n    }\n}\nstatic class CircularLinkedList\n{\n# Write Code Here\n}\nNode addAfter(int data, int item)\n{\n# Write Code Here\n}\nvoid deleteNode(Node last, int key)\n{\n# Write Code Here\n}\nSystem.",
        "testcases": [
            {
                "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeginning\ntraverse",
                "expected_output": "20 30",
                "is_visible": true
            },
            {
                "input": "insertBeginning 5\ninsertEnd 15\ntraverse",
                "expected_output": "5 15",
                "is_visible": true
            },
            {
                "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ndeleteEnd\ntraverse",
                "expected_output": "100 200",
                "is_visible": true
            },
            {
                "input": "insertEnd 1\ninsertEnd 2\ninsertEnd 3\ndeleteKey 2\ntraverse",
                "expected_output": "1 3",
                "is_visible": true
            },
            {
                "input": "insertBeginning 50\ninsertEnd 100\ninsertAfter 75 50\ntraverse",
                "expected_output": "50 75 100",
                "is_visible": true
            },
            {
                "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ndeleteBeginning\ndeleteEnd\ntraverse",
                "expected_output": "20 30",
                "is_visible": false
            },
            {
                "input": "insertBeginning 5\ninsertEnd 10\ninsertAfter 7 5\ninsertEnd 15\ndeleteKey 10\ntraverse",
                "expected_output": "5 7 15",
                "is_visible": false
            },
            {
                "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ninsertEnd 400\ndeleteBeginning\ndeleteKey 300\ntraverse",
                "expected_output": "200 400",
                "is_visible": false
            },
            {
                "input": "insertBeginning 1\ninsertEnd 2\ninsertEnd 3\ninsertEnd 4\ninsertEnd 5\ndeleteEnd\ndeleteBeginning\ninsertAfter 6 3\ntraverse",
                "expected_output": "2 3 6 4",
                "is_visible": false
            },
            {
                "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ninsertEnd 50\ndeleteKey 30\ndeleteBeginning\ndeleteEnd\ntraverse",
                "expected_output": "20 40",
                "is_visible": false
            }
        ]
    },
    {
        "title": "8.2 Doubly Linked List",
        "description": "The A doubly linked list is a type of linked list in which each node consists of 3 components: 1. *prev - address of the previous node 2. data - data item 3. *next - address of next node. Operations on the Double Linked List: 1. Insertion at the beginning 2. Insertion at the end 3. Insertion in between the nodes 4. Deletion at the beginning 5. Deletion at the end 6. Deletion in between the nodes 7. Traversal",
        "starter_code": "import java.util.Scanner;\n\nclass Node {\n    int data;\n    Node next;\n    Node prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n}\n\nclass DLinkedList {\n    Node head;\n    int ctr;\n\n    DLinkedList() {\n    this.head = null;\n    this.ctr = 0;\n}\n\n    void insertBeg(int data)\n    {\n    # Write Code Here\n    }\n    void insertEnd(int data)\n    {\n    # Write Code Here\n    }\n    void deleteBeg()\n    {\n    # Write Code Here\n    }\n    void deleteEnd()\n    {\n    # Write Code Here\n    }\n    void insertPos(int pos, int data)\n    {\n    # Write Code Here\n    }\n    void deletePos(int pos)\n    {\n    # Write Code Here\n    }\n    void traverseF()\n    {\n    # Write Code Here\n    }\n    void traverseR()\n    {\n    # Write Code Here\n    }\n\n    public class Main {\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "insertBeg 10\ninsertEnd 20\ninsertEnd 30\ndeleteBeg\ntraverseF",
                "expected_output": "20 30",
                "is_visible": true
            },
            {
                "input": "insertEnd 5\ninsertEnd 15\ninsertPos 1 10\ntraverseF",
                "expected_output": "5 10 15",
                "is_visible": true
            },
            {
                "input": "insertBeg 100\ninsertEnd 200\ninsertEnd 300\ndeleteEnd\ntraverseF",
                "expected_output": "100 200",
                "is_visible": true
            },
            {
                "input": "insertEnd 1\ninsertEnd 2\ninsertEnd 3\ndeletePos 1\ntraverseF",
                "expected_output": "1 3",
                "is_visible": true
            },
            {
                "input": "insertBeg 50\ninsertEnd 100\ninsertPos 1 75\ntraverseF",
                "expected_output": "50 75 100",
                "is_visible": true
            },
            {
                "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ndeleteBeg\ndeleteEnd\ntraverseF",
                "expected_output": "20 30",
                "is_visible": false
            },
            {
                "input": "insertBeg 5\ninsertEnd 10\ninsertPos 1 7\ninsertEnd 15\ndeletePos 2\ntraverseF",
                "expected_output": "5 7 15",
                "is_visible": false
            },
            {
                "input": "insertEnd 100\ninsertEnd 200\ninsertEnd 300\ninsertEnd 400\ndeleteBeg\ndeletePos 1\ntraverseF",
                "expected_output": "200 400",
                "is_visible": false
            },
            {
                "input": "insertBeg 1\ninsertEnd 2\ninsertEnd 3\ninsertEnd 4\ninsertEnd 5\ndeleteEnd\ndeleteBeg\ninsertPos 1 6\ntraverseF",
                "expected_output": "6 2 3 4",
                "is_visible": false
            },
            {
                "input": "insertEnd 10\ninsertEnd 20\ninsertEnd 30\ninsertEnd 40\ninsertEnd 50\ndeletePos 2\ndeleteBeg\ndeleteEnd\ntraverseR",
                "expected_output": "40 20",
                "is_visible": false
            }
        ]
    },
    {
        "title": "8.3 Sorted Merge of Two Sorted Doubly Circular Linked Lists",
        "description": "Given two sorted Doubly circular Linked List containing n1 and n2 nodes respectively. The problem is to merge the two lists such that resultant list is also in sorted order. Input: List 1 and List 2 head1 1 3 5 8 head2 2 7 9 11 Output: Merged List final 1 2 3 5 7 8 9 11 Procedure for Merging Doubly Linked List: 1. If head1 == NULL, return head2. 2. If head2 == NULL, return head1. 3. Let last1 and last2 be the last nodes of the two lists respectively. They can be obtained with the help of the previous links of the first nodes. 4. Get pointer to the node which will be the last node of the final list. If last1.data < last2.data, then last_node = last2, Else last_node = last1. 5. Update last1.next = last2.next = NULL. 6. Now merge the two lists as two sorted doubly linked list are being merged. Refer merge procedure of this post. Let the first node of the final list be finalHead. 7. Update finalHead.prev = last_node and last_node.next = finalHead. 8. Return finalHead.",
        "starter_code": "class Node {\n    int data;\n    Node next, prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n}\n\npublic class SortedMergeDoublyCircularLinkedList\n    {\n    # Write Code Here\n    }\n\n    static Node mergeUtil(Node head1, Node head2)\n    {\n    # Write Code Here\n    }\n    static void printList(Node head)\n    {\n    # Write Code Here\n    }\n\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "4\n1 3 5 8\n4\n2 7 9 11",
                "expected_output": "1 2 3 5 7 8 9 11",
                "is_visible": true
            },
            {
                "input": "3\n10 20 30\n2\n5 15",
                "expected_output": "5 10 15 20 30",
                "is_visible": true
            },
            {
                "input": "2\n1 2\n3\n3 4 5",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "1\n100\n3\n50 150 200",
                "expected_output": "50 100 150 200",
                "is_visible": true
            },
            {
                "input": "0\n\n3\n1 2 3",
                "expected_output": "1 2 3",
                "is_visible": true
            },
            {
                "input": "5\n2 4 6 8 10\n4\n1 3 5 7",
                "expected_output": "1 2 3 4 5 6 7 8 10",
                "is_visible": false
            },
            {
                "input": "6\n10 20 30 40 50 60\n5\n5 15 25 35 45",
                "expected_output": "5 10 15 20 25 30 35 40 45 50 60",
                "is_visible": false
            },
            {
                "input": "7\n1 3 5 7 9 11 13\n6\n2 4 6 8 10 12",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13",
                "is_visible": false
            },
            {
                "input": "8\n5 10 15 20 25 30 35 40\n8\n1 2 3 4 6 8 12 16",
                "expected_output": "1 2 3 4 5 6 8 10 12 15 16 20 25 30 35 40",
                "is_visible": false
            },
            {
                "input": "10\n100 200 300 400 500 600 700 800 900 1000\n10\n50 150 250 350 450 550 650 750 850 950",
                "expected_output": "50 100 150 200 250 300 350 400 450 500 550 600 650 700 750 800 850 900 950 1000",
                "is_visible": false
            }
        ]
    },
    {
        "title": "8.4 Delete all occurrences of a given key in a Doubly Linked List",
        "description": "Given a doubly linked list and a key x. The problem is to delete all occurrences of the given key x from the doubly linked list. Input: 2 <-> 2 <-> 10 <-> 8 <-> 4 <-> 2 <-> 5 <-> 2 x = 2 Output: 10 <-> 8 <-> 4 <-> 5 Algorithm: delAllOccurOfGivenKey (head_ref, x) if head_ref == NULL return Initialize current = head_ref Declare next while current != NULL if current->data == x next = current->next deleteNode(head_ref, current) current = next else current = current->next",
        "starter_code": "class Node {\n    int data;\n    Node next, prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n    }\n}\n\npublic class DeleteOccurrenceInDoublyLinkedList\n    {\n    # Write Code Here\n    }\n    static Node deleteAllOccurOfX(Node head, int x)\n    {\n    # Write Code Here\n    }\n    static void printList(Node head)\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "8\n2 2 10 8 4 2 5 2\n2",
                "expected_output": "10 8 4 5",
                "is_visible": true
            },
            {
                "input": "5\n1 1 1 1 1\n1",
                "expected_output": "",
                "is_visible": true
            },
            {
                "input": "6\n10 20 30 40 50 60\n100",
                "expected_output": "10 20 30 40 50 60",
                "is_visible": true
            },
            {
                "input": "7\n5 10 5 15 5 20 5\n5",
                "expected_output": "10 15 20",
                "is_visible": true
            },
            {
                "input": "4\n100 200 300 400\n200",
                "expected_output": "100 300 400",
                "is_visible": true
            },
            {
                "input": "10\n1 2 1 3 1 4 1 5 1 6\n1",
                "expected_output": "2 3 4 5 6",
                "is_visible": false
            },
            {
                "input": "12\n10 20 10 30 10 40 10 50 10 60 10 70\n10",
                "expected_output": "20 30 40 50 60 70",
                "is_visible": false
            },
            {
                "input": "15\n5 1 5 2 5 3 5 4 5 5 5 6 5 7 5\n5",
                "expected_output": "1 2 3 4 6 7",
                "is_visible": false
            },
            {
                "input": "20\n2 4 2 6 2 8 2 10 2 12 2 14 2 16 2 18 2 20 2 22\n2",
                "expected_output": "4 6 8 10 12 14 16 18 20 22",
                "is_visible": false
            },
            {
                "input": "25\n1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13\n1",
                "expected_output": "2 3 4 5 6 7 8 9 10 11 12 13",
                "is_visible": false
            }
        ]
    },
    {
        "title": "8.5 Delete a Doubly Linked List Node at a Given Position",
        "description": "Given a doubly linked list and a position n. The task is to delete the node at the given position n from the beginning. Input: Initial doubly linked list 10 8 4 2 5 Output: Doubly Linked List after deletion of node at position n = 2 10 4 2 5 Procedure: 1. Get the pointer to the node at position n by traversing the doubly linked list up to the nth node from the beginning. 2. Delete the node using the pointer obtained in Step 1.",
        "starter_code": "class Node {\n    int data;\n    Node next, prev;\n\n    Node(int data) {\n    this.data = data;\n    this.next = null;\n    this.prev = null;\n}\n\npublic class DeleteNodeAtGivenPosition\n    {\n    # Write Code Here\n    }\n    static Node deleteNode(Node head, Node del)\n    {\n    # Write Code Here\n    }\n    static Node deleteNodeAtGivenPos(Node head, int n)\n    {\n    # Write Code Here\n    }\n    static void printList(Node head)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "5\n10 8 4 2 5\n2",
                "expected_output": "10 4 2 5",
                "is_visible": true
            },
            {
                "input": "3\n100 200 300\n1",
                "expected_output": "200 300",
                "is_visible": true
            },
            {
                "input": "4\n1 2 3 4\n4",
                "expected_output": "1 2 3",
                "is_visible": true
            },
            {
                "input": "6\n10 20 30 40 50 60\n3",
                "expected_output": "10 20 40 50 60",
                "is_visible": true
            },
            {
                "input": "1\n5\n1",
                "expected_output": "",
                "is_visible": true
            },
            {
                "input": "8\n1 2 3 4 5 6 7 8\n5",
                "expected_output": "1 2 3 4 6 7 8",
                "is_visible": false
            },
            {
                "input": "10\n10 20 30 40 50 60 70 80 90 100\n7",
                "expected_output": "10 20 30 40 50 60 80 90 100",
                "is_visible": false
            },
            {
                "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\n10",
                "expected_output": "5 10 15 20 25 30 35 40 45 55 60",
                "is_visible": false
            },
            {
                "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n12",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 13 14 15",
                "is_visible": false
            },
            {
                "input": "20\n100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000\n15",
                "expected_output": "100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1600 1700 1800 1900 2000",
                "is_visible": false
            }
        ]
    },
    {
        "title": "9.1 Tree Creation and Basic Tree Terminologies",
        "description": "A tree data structure is a hierarchical structure that is used to represent and organize data in a way that is easy to navigate and search. It is a collection of nodes that are connected by edges and has a hierarchical relationship between the nodes. Basic Terminologies in Tree: 1. Parent Node: The node which is a predecessor of a node is called the parent node of that node. (B) is the parent node of (D, E). 2. Child Node: The node which is the immediate successor of a node is called the child node of that node. Examples: (D, E) are the child nodes of (B). 3. Root Node: The topmost node of a tree or the node which does not have any parent node is called the root node. (A) is the root node of the tree. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree. 4. Leaf Node or External Node: The nodes which do not have any child nodes are called leaf nodes. (K, L, M, N, O, P) are the leaf nodes of the tree. 5. Ancestor of a Node: Any predecessor nodes on the path of the root to that node are called Ancestors of that node. (A, B) are the ancestor nodes of the node (E) 6. Descendant: Any successor node on the path from the leaf node to that node. (E, I) are the descendants of the node (B). 7. Sibling: Children of the same parent node are called siblings. (D, E) are called siblings. 8. Level of a node: The count of edges on the path from the root node to that node. The root node has level 0. 9. Internal node: A node with at least one child is called Internal Node. 10. Neighbour of a Node: Parent or child nodes of that node are called neighbors of that node. 11. Subtree: Any node of the tree along with its descendant.",
        "starter_code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeBasicTerminologies\n{\n    # Write Code Here\n    }\nstatic void printChildren(int root, List<List<Integer>> adj)\n{\n    # Write Code Here\n    }\nstatic void printLeafNodes(int root, List<List<Integer>> adj)\n{\n    # Write Code Here\n    }\nstatic void printDegrees(int root, List<List<Integer>> adj)\n{\n    # Write Code Here\n    }\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "6\n0 1\n0 2\n1 3\n1 4\n2 5\nfindChildren 0",
                "expected_output": "1 2",
                "is_visible": true
            },
            {
                "input": "6\n0 1\n0 2\n1 3\n1 4\n2 5\nfindLeaves",
                "expected_output": "3 4 5",
                "is_visible": true
            },
            {
                "input": "5\n0 1\n0 2\n1 3\n1 4\nfindDegree 1",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "4\n0 1\n0 2\n0 3\nfindChildren 0",
                "expected_output": "1 2 3",
                "is_visible": true
            },
            {
                "input": "7\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\nfindLeaves",
                "expected_output": "3 4 5 6",
                "is_visible": true
            },
            {
                "input": "8\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n3 7\nfindChildren 3",
                "expected_output": "6 7",
                "is_visible": false
            },
            {
                "input": "10\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n4 8\n5 9\nfindLeaves",
                "expected_output": "7 8 9 6",
                "is_visible": false
            },
            {
                "input": "12\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n5 10\n5 11\nfindDegree 5",
                "expected_output": "2",
                "is_visible": false
            },
            {
                "input": "15\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\nfindChildren 4",
                "expected_output": "9 10",
                "is_visible": false
            },
            {
                "input": "20\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\n7 15\n8 16\n9 17\n10 18\n11 19\nfindLeaves",
                "expected_output": "15 16 17 18 19 12 13 14",
                "is_visible": false
            }
        ]
    },
    {
        "title": "9.2 Binary Tree Traversal Techniques",
        "description": "A binary tree data structure can be traversed in following ways: 1. Inorder Traversal 2. Preorder Traversal 3. Postorder Traversal 4. Level Order Traversal Algorithm Inorder (tree) 1. Traverse the left subtree, i.e., call Inorder(left->subtree) 2. Visit the root. 3. Traverse the right subtree, i.e., call Inorder(right->subtree) Algorithm Preorder (tree) 1. Visit the root. 2. Traverse the left subtree, i.e., call Preorder(left->subtree) 3. Traverse the right subtree, i.e., call Preorder(right->subtree) Algorithm Postorder (tree) 1. Traverse the left subtree, i.e., call Postorder(left->subtree) 2. Traverse the right subtree, i.e., call Postorder(right->subtree) 3. Visit the root.",
        "starter_code": "import java.util.Scanner;\nclass Node\n    {\n    # Write Code Here\n    }\nclass BT {\n    Node root;\n    BT() {\n    this.root = null;\n    }\n    void insert(int data)\n    {\n    # Write Code Here\n    }\n    Node insertRec(Node root, int data)\n    {\n    # Write Code Here\n    }\n    void postorder(Node root)\n    {\n    # Write Code Here\n    }\n    void preorder(Node root)\n    {\n    # Write Code Here\n    }\n    }\n    void inorder(Node root)\n    {\n    # Write Code Here\n    }\n}\n\npublic class BinaryTreeTraversal {\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n    }",
        "testcases": [
            {
                "input": "7\n1 2 3 4 5 6 7\ninorder",
                "expected_output": "4 2 5 1 6 3 7",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5\npreorder",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "3\n1 2 3\npostorder",
                "expected_output": "3 2 1",
                "is_visible": true
            },
            {
                "input": "6\n1 2 3 4 5 6\ninorder",
                "expected_output": "4 2 5 1 6 3",
                "is_visible": true
            },
            {
                "input": "4\n1 2 3 4\npreorder",
                "expected_output": "1 2 3 4",
                "is_visible": true
            },
            {
                "input": "9\n1 2 3 4 5 6 7 8 9\ninorder",
                "expected_output": "8 4 9 2 5 1 6 3 7",
                "is_visible": false
            },
            {
                "input": "10\n1 2 3 4 5 6 7 8 9 10\npreorder",
                "expected_output": "1 2 4 8 9 5 3 6 7 10",
                "is_visible": false
            },
            {
                "input": "12\n1 2 3 4 5 6 7 8 9 10 11 12\npostorder",
                "expected_output": "8 9 4 10 5 2 11 12 6 7 3 1",
                "is_visible": false
            },
            {
                "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ninorder",
                "expected_output": "8 4 9 2 10 5 11 1 12 6 13 3 14 7 15",
                "is_visible": false
            },
            {
                "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\npreorder",
                "expected_output": "1 2 4 8 16 17 9 18 19 5 10 20 11 3 6 12 13 7 14 15",
                "is_visible": false
            }
        ]
    },
    {
        "title": "9.3 Insertion in a Binary Tree in Level Order",
        "description": "Given a binary tree and a key, insert the key into the binary tree at the first position available in level order. The idea is to do an iterative level order traversal of the given tree using queue. If we find a node whose left child is empty, we make a new key as the left child of the node. Else if we find a node whose right child is empty, we make the new key as the right child. We keep traversing the tree until we find a node whose either left or right child is empty.",
        "starter_code": "class Node\n{\n    # Write Code Here\n}\n\npublic class BinaryTreeInsertion\n{\n    # Write Code Here\n    }\n    static Node insert(Node root, int key)\n}\n\n# Write Code Here\n}\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "4\n1 2 3 4\ninsert 5\nlevelorder",
                "expected_output": "1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "3\n10 20 30\ninsert 40\nlevelorder",
                "expected_output": "10 20 30 40",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5\ninsert 6\nlevelorder",
                "expected_output": "1 2 3 4 5 6",
                "is_visible": true
            },
            {
                "input": "1\n100\ninsert 200\nlevelorder",
                "expected_output": "100 200",
                "is_visible": true
            },
            {
                "input": "6\n5 3 7 2 4 6\ninsert 8\nlevelorder",
                "expected_output": "5 3 7 2 4 6 8",
                "is_visible": true
            },
            {
                "input": "7\n1 2 3 4 5 6 7\ninsert 8\ninsert 9\nlevelorder",
                "expected_output": "1 2 3 4 5 6 7 8 9",
                "is_visible": false
            },
            {
                "input": "10\n10 20 30 40 50 60 70 80 90 100\ninsert 110\nlevelorder",
                "expected_output": "10 20 30 40 50 60 70 80 90 100 110",
                "is_visible": false
            },
            {
                "input": "12\n1 3 5 7 9 11 13 15 17 19 21 23\ninsert 24\nlevelorder",
                "expected_output": "1 3 5 7 9 11 13 15 17 19 21 23 24",
                "is_visible": false
            },
            {
                "input": "15\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30\ninsert 32\ninsert 34\nlevelorder",
                "expected_output": "2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34",
                "is_visible": false
            },
            {
                "input": "20\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\ninsert 105\nlevelorder",
                "expected_output": "5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105",
                "is_visible": false
            }
        ]
    },
    {
        "title": "9.4 Finding the Maximum Height or Depth of a Binary Tree",
        "description": "Given a binary tree, the task is to find the height of the tree. The height of the tree is the number of edges in the tree from the root to the deepest node. Note: The height of an empty tree is 0. Recursively calculate the height of the left and the right subtrees of a node and assign height to the node as max of the heights of two children plus 1. maxDepth('1') = max(maxDepth('2'), maxDepth('3')) + 1 = 2 + 1 because recursively maxDepth('2') = max (maxDepth('4'), maxDepth('5')) + 1 = 1 + 1 and (as height of both '4' and '5' are 1) maxDepth('3') = 1 Procedure: Recursively do a Depth-first search. If the tree is empty then return 0 Otherwise, do the following Get the max depth of the left subtree recursively i.e. call maxDepth( tree->left-subtree) Get the max depth of the right subtree recursively i.e. call maxDepth( tree->right-subtree) Get the max of max depths of left and right subtrees and add 1 to it for the current node. max_depth = max(max_depth[left]subtree, max_depth[right]subtree) + 1 Return max_depth.",
        "starter_code": "class Node\n{\n    int data;\n    Node left, right;\n\n    Node(int data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\npublic class MaximumDepthOfTree\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "3\n1 2 3",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "1\n10",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "7\n1 2 3 4 5 6 7",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "6\n1 2 3 4 5 6",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "10\n1 2 3 4 5 6 7 8 9 10",
                "expected_output": "4",
                "is_visible": false
            },
            {
                "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "expected_output": "4",
                "is_visible": false
            },
            {
                "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20",
                "expected_output": "5",
                "is_visible": false
            },
            {
                "input": "31\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31",
                "expected_output": "5",
                "is_visible": false
            },
            {
                "input": "63\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63",
                "expected_output": "6",
                "is_visible": false
            }
        ]
    },
    {
        "title": "9.5 Deletion in a Binary Tree",
        "description": "Given a binary tree, delete a node from it by making sure that the tree shrinks from the bottom (i.e. the deleted node is replaced by the bottom-most and rightmost node). Input: Delete 10 in below tree 10 / \\ 20 30 Output: 30 / \\ 20 Input: Delete 20 in below tree 10 / \\ 20 30 \\ 40 Output: 10 / \\ 40 30 Algorithm: 1. Starting at the root, find the deepest and rightmost node in the binary tree and the node which we want to delete. 2. Replace the deepest rightmost node's data with the node to be deleted. 3. Then delete the deepest rightmost node.",
        "starter_code": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\npublic class BinaryTreeDeletion\n{\n    # Write Code Here\n    }\n    static void deleteDeepest(Node root, Node dNode)\n    # Write Code Here\n}\n    static Node deletion(Node root, int key)\n    # Write Code Here\n}\n    public static void main(String[] args)\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "3\n10 20 30\ndelete 10\nlevelorder",
                "expected_output": "30 20",
                "is_visible": true
            },
            {
                "input": "4\n10 20 30 40\ndelete 20\nlevelorder",
                "expected_output": "10 40 30",
                "is_visible": true
            },
            {
                "input": "5\n1 2 3 4 5\ndelete 3\nlevelorder",
                "expected_output": "1 2 5 4",
                "is_visible": true
            },
            {
                "input": "6\n10 20 30 40 50 60\ndelete 40\nlevelorder",
                "expected_output": "10 20 30 60 50",
                "is_visible": true
            },
            {
                "input": "7\n1 2 3 4 5 6 7\ndelete 2\nlevelorder",
                "expected_output": "1 7 3 4 5 6",
                "is_visible": true
            },
            {
                "input": "8\n10 20 30 40 50 60 70 80\ndelete 30\nlevelorder",
                "expected_output": "10 20 80 40 50 60 70",
                "is_visible": false
            },
            {
                "input": "10\n1 2 3 4 5 6 7 8 9 10\ndelete 5\nlevelorder",
                "expected_output": "1 2 3 4 10 6 7 8 9",
                "is_visible": false
            },
            {
                "input": "12\n5 10 15 20 25 30 35 40 45 50 55 60\ndelete 20\nlevelorder",
                "expected_output": "5 10 15 60 25 30 35 40 45 50 55",
                "is_visible": false
            },
            {
                "input": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ndelete 8\nlevelorder",
                "expected_output": "1 2 3 4 5 6 7 15 9 10 11 12 13 14",
                "is_visible": false
            },
            {
                "input": "20\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\ndelete 12\nlevelorder",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 20 13 14 15 16 17 18 19",
                "is_visible": false
            }
        ]
    },
    {
        "title": "10.1 Searching in Binary Search Tree",
        "description": "Given a BST, the task is to delete a node in this BST. For searching a value in BST, consider it as a sorted array. Perform search operation in BST using Binary Search Algorithm. Algorithm to search for a key in a given Binary Search Tree: Let's say we want to search for the number X, We start at the root. Then: - We compare the value to be searched with the value of the root. - If it's equal we are done with the search if it's smaller we know that we need to go to the left subtree because in a binary search tree all the elements in the left subtree are smaller and all the elements in the right subtree are larger. - Repeat the above step till no more traversal is possible - If at any iteration, key is found, return True. Else False.",
        "starter_code": "class Node {\n    int key;\n    Node left, right;\n\n    public Node(int item) {\n    key = item;\n    left = right = null;\n    }\n}\n\nclass BST\n{\n# Write Code Here\n}\nNode search(int key) {\n    return searchRec(root, key);\n}\nNode searchRec(Node root, int key)\n    {\n    # Write Code Here\n    }\npublic static void main(String[] args)\n{\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "5\n8 3 10 1 6\nsearch 6",
                "expected_output": "Found",
                "is_visible": true
            },
            {
                "input": "4\n5 3 7 2\nsearch 8",
                "expected_output": "Not Found",
                "is_visible": true
            },
            {
                "input": "6\n10 5 15 3 7 12\nsearch 7",
                "expected_output": "Found",
                "is_visible": true
            },
            {
                "input": "3\n100 50 150\nsearch 100",
                "expected_output": "Found",
                "is_visible": true
            },
            {
                "input": "7\n20 10 30 5 15 25 35\nsearch 18",
                "expected_output": "Not Found",
                "is_visible": true
            },
            {
                "input": "10\n50 30 70 20 40 60 80 10 25 35\nsearch 25",
                "expected_output": "Found",
                "is_visible": false
            },
            {
                "input": "12\n100 50 150 25 75 125 175 12 37 62 87 112\nsearch 87",
                "expected_output": "Found",
                "is_visible": false
            },
            {
                "input": "15\n8 4 12 2 6 10 14 1 3 5 7 9 11 13 15\nsearch 16",
                "expected_output": "Not Found",
                "is_visible": false
            },
            {
                "input": "20\n500 250 750 125 375 625 875 62 187 312 437 562 687 812 937 31 93 156 218 281\nsearch 437",
                "expected_output": "Found",
                "is_visible": false
            },
            {
                "input": "25\n1000 500 1500 250 750 1250 1750 125 375 625 875 1125 1375 1625 1875 62 187 312 437 562 687 812 937 1062 1187\nsearch 1187",
                "expected_output": "Found",
                "is_visible": false
            }
        ]
    },
    {
        "title": "10.2 Find the node with Minimum Value in a BST",
        "description": "Write a function to find the node with minimum value in a Binary Search Tree.",
        "starter_code": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Node {\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n    data = item;\n    left = right = null;\n}\n\nclass BinarySearchTree\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "5\n8 3 10 1 6",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "4\n5 3 7 2",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "6\n10 5 15 3 7 12",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "3\n100 50 150",
                "expected_output": "50",
                "is_visible": true
            },
            {
                "input": "7\n20 10 30 5 15 25 35",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "10\n50 30 70 20 40 60 80 10 25 35",
                "expected_output": "10",
                "is_visible": false
            },
            {
                "input": "12\n100 50 150 25 75 125 175 12 37 62 87 112",
                "expected_output": "12",
                "is_visible": false
            },
            {
                "input": "15\n8 4 12 2 6 10 14 1 3 5 7 9 11 13 15",
                "expected_output": "1",
                "is_visible": false
            },
            {
                "input": "20\n500 250 750 125 375 625 875 62 187 312 437 562 687 812 937 31 93 156 218 281",
                "expected_output": "31",
                "is_visible": false
            },
            {
                "input": "25\n1000 500 1500 250 750 1250 1750 125 375 625 875 1125 1375 1625 1875 62 187 312 437 562 687 812 937 1062 1187",
                "expected_output": "62",
                "is_visible": false
            }
        ]
    },
    {
        "title": "10.3 Check if a Binary Tree is BST or not",
        "description": "A binary search tree (BST) is a node-based binary tree data structure that has the following properties. 1. The left subtree of a node contains only nodes with keys less than the node's key. 2. The right subtree of a node contains only nodes with keys greater than the node's key. 3. Both the left and right subtrees must also be binary search trees. 4. Each node (item in the tree) has a distinct key. Procedure: 1. If the current node is null then return true 2. If the value of the left child of the node is greater than or equal to the current node then return false 3. If the value of the right child of the node is less than or equal to the current node then return false 4. If the left subtree or the right subtree is not a BST then return false 5. Else return true",
        "starter_code": "class Node {\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n    data = item;\n    left = right = null;\n}\n\nclass BinaryTree\n    {\n    # Write Code Here\n    }\n    boolean isBST(Node node) {\n    return isBSTUtil(node, Integer.MIN_VALUE, Integer.MAX_VALUE);\n}\n    boolean isBSTUtil(Node node, int min, int max)\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "5\n8 3 10 1 6",
                "expected_output": "Is BST",
                "is_visible": true
            },
            {
                "input": "4\n5 3 7 2",
                "expected_output": "Is BST",
                "is_visible": true
            },
            {
                "input": "6\n10 5 15 3 7 12",
                "expected_output": "Is BST",
                "is_visible": true
            },
            {
                "input": "7\n20 10 30 5 15 25 35",
                "expected_output": "Is BST",
                "is_visible": true
            },
            {
                "input": "5\n10 5 15 12 8",
                "expected_output": "Not a BST",
                "is_visible": true
            },
            {
                "input": "10\n50 30 70 20 40 60 80 10 25 35",
                "expected_output": "Is BST",
                "is_visible": false
            },
            {
                "input": "8\n100 50 150 25 75 125 175 200",
                "expected_output": "Is BST",
                "is_visible": false
            },
            {
                "input": "9\n8 3 10 1 6 14 4 7 13",
                "expected_output": "Not a BST",
                "is_visible": false
            },
            {
                "input": "12\n100 50 150 25 75 125 175 12 37 62 87 112",
                "expected_output": "Is BST",
                "is_visible": false
            },
            {
                "input": "15\n8 4 12 2 6 10 14 1 3 5 7 9 11 13 15",
                "expected_output": "Is BST",
                "is_visible": false
            }
        ]
    },
    {
        "title": "10.4 Second Largest Element in BST",
        "description": "Given a Binary search tree (BST), find the second largest element. Input: Root of below BST 10 / 5 Output: 5 Input: Root of below BST 10 / \\ 5 20 \\ 30 Output: 20 Procedure: The second largest element is second last element in inorder traversal and second element in reverse inorder traversal. We traverse given Binary Search Tree in reverse inorder and keep track of counts of nodes visited. Once the count becomes 2, we print the node.",
        "starter_code": "class Node {\n    int key;\n    Node left, right;\n\n    public Node(int item) {\n    key = item;\n    left = right = null;\n    }\n}\n\nclass BinarySearchTree\n    {\n    # Write Code Here\n    }\n    secondLargestUtil(node.right);\n    count++;\n    // If count is equal to 2 then this is the second largest\n    if (count == 2) {\n    System.out.println(\"The second largest element is \" + node.key);\n    return;\n    }\n    secondLargestUtil(node.left);\n}\n\n// Function to find the second largest element\nvoid secondLargest(Node node) {\n    count = 0;\n    secondLargestUtil(node);\n}\n\n// Driver code\npublic static void main(String[] args)\n{\n    # Write Code Here\n}",
        "testcases": [
            {
                "input": "2\n10 5",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "4\n10 5 20 30",
                "expected_output": "20",
                "is_visible": true
            },
            {
                "input": "5\n8 3 10 1 6",
                "expected_output": "8",
                "is_visible": true
            },
            {
                "input": "6\n10 5 15 3 7 12",
                "expected_output": "12",
                "is_visible": true
            },
            {
                "input": "7\n20 10 30 5 15 25 35",
                "expected_output": "30",
                "is_visible": true
            },
            {
                "input": "10\n50 30 70 20 40 60 80 10 25 35",
                "expected_output": "70",
                "is_visible": false
            },
            {
                "input": "12\n100 50 150 25 75 125 175 12 37 62 87 112",
                "expected_output": "150",
                "is_visible": false
            },
            {
                "input": "15\n8 4 12 2 6 10 14 1 3 5 7 9 11 13 15",
                "expected_output": "14",
                "is_visible": false
            },
            {
                "input": "20\n500 250 750 125 375 625 875 62 187 312 437 562 687 812 937 31 93 156 218 281",
                "expected_output": "875",
                "is_visible": false
            },
            {
                "input": "25\n1000 500 1500 250 750 1250 1750 125 375 625 875 1125 1375 1625 1875 62 187 312 437 562 687 812 937 1062 1187",
                "expected_output": "1750",
                "is_visible": false
            }
        ]
    },
    {
        "title": "10.5 Insertion in Binary Search Tree (BST)",
        "description": "Given a Binary search tree (BST), the task is to insert a new node in this BST. Procedure for inserting a value in a BST: A new key is always inserted at the leaf by maintaining the property of the binary search tree. We start searching for a key from the root until we hit a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node. The below steps are followed while we try to insert a node into a binary search tree: - Check the value to be inserted (say X) with the value of the current node (say val) we are in: - If X is less than val move to the left subtree. - Otherwise, move to the right subtree. - Once the leaf node is reached, insert X to its right or left based on the relation between X and the leaf node's value.",
        "starter_code": "class Node {\n    int val;\n    Node left, right;\n\n    public Node(int item) {\n    val = item;\n    left = right = null;\n}\n\nclass BinarySearchTree\n    {\n    # Write Code Here\n    }\n    void inorder()\n    {\n    inorderRec(root);\n    }\n    void inorderRec(Node root)\n    {\n    # Write Code Here\n    }\n\n// Driver code\npublic static void main(String[] args)\n{\n    # White Code Here\n}",
        "testcases": [
            {
                "input": "5\n8 3 10 1 6\ninsert 4\ninorder",
                "expected_output": "1 3 4 6 8 10",
                "is_visible": true
            },
            {
                "input": "3\n5 3 7\ninsert 6\ninorder",
                "expected_output": "3 5 6 7",
                "is_visible": true
            },
            {
                "input": "4\n10 5 15 12\ninsert 8\ninorder",
                "expected_output": "5 8 10 12 15",
                "is_visible": true
            },
            {
                "input": "6\n20 10 30 5 15 25\ninsert 22\ninorder",
                "expected_output": "5 10 15 20 22 25 30",
                "is_visible": true
            },
            {
                "input": "7\n50 30 70 20 40 60 80\ninsert 35\ninorder",
                "expected_output": "20 30 35 40 50 60 70 80",
                "is_visible": true
            },
            {
                "input": "10\n100 50 150 25 75 125 175 12 37 62\ninsert 87\ninorder",
                "expected_output": "12 25 37 50 62 75 87 100 125 150 175",
                "is_visible": false
            },
            {
                "input": "12\n200 100 300 50 150 250 350 25 75 125 175 225\ninsert 275\ninorder",
                "expected_output": "25 50 75 100 125 150 175 200 225 250 275 300 350",
                "is_visible": false
            },
            {
                "input": "15\n8 4 12 2 6 10 14 1 3 5 7 9 11 13 15\ninsert 16\ninorder",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16",
                "is_visible": false
            },
            {
                "input": "20\n500 250 750 125 375 625 875 62 187 312 437 562 687 812 937 31 93 156 218 281\ninsert 400\ninorder",
                "expected_output": "31 62 93 125 156 187 218 250 281 312 375 400 437 500 562 625 687 750 812 875 937",
                "is_visible": false
            },
            {
                "input": "25\n1000 500 1500 250 750 1250 1750 125 375 625 875 1125 1375 1625 1875 62 187 312 437 562 687 812 937 1062 1187\ninsert 1300\ninorder",
                "expected_output": "62 125 187 250 312 375 437 500 562 625 687 750 812 875 937 1000 1062 1125 1187 1250 1300 1375 1500 1625 1750 1875",
                "is_visible": false
            }
        ]
    },
    {
        "title": "11.1 Insertion in an AVL Tree",
        "description": "AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes. To make sure that the given tree remains AVL after every insertion, we must augment the standard BST insert operation to perform some re-balancing. Following are two basic operations that can be performed to balance a BST without violating the BST property (keys(left) < key(root) < keys(right)).\n- Left Rotation\n- Right Rotation\n\nT1, T2 and T3 are subtrees of the tree, rooted with y (on the left side) or x (on the right side)\n\nKeys in both of the above trees follow the following order \nkeys(T1) < key(x) < keys(T2) < key(y) < keys(T3)  \nSo BST property is not violated anywhere.\n\n**Procedure for inserting a node into an AVL tree**\n\nLet the newly inserted node be w  \n- Perform standard BST insert for w.\n- Starting from w, travel up and find the first unbalanced node. Let z be the first unbalanced node, y be the child of z that comes on the path from w to z and x be the grandchild of z that comes on the path from w to z.\n- Re-balance the tree by performing appropriate rotations on the subtree rooted with z. There can be 4 possible cases that need to be handled as x, y and z can be arranged in 4 ways.\n- Following are the possible 4 arrangements:\n  - y is the left child of z and x is the left child of y (Left Left Case)\n  - y is the left child of z and x is the right child of y (Left Right Case)\n  - y is the right child of z and x is the right child of y (Right Right Case)\n  - y is the right child of z and x is the left child of y (Right Left Case)",
        "starter_code": "class TreeNode {\n    int val, height;\n    TreeNode left, right;\n\n    TreeNode(int d) {\n    val = d;\n    height = 1;\n    }\n}\n\nclass AVL_Tree {\n\n    # write the code\n\n } \n\n TreeNode leftRotate(TreeNode x) \n{ \n# write the code \n} \n public static void main(String[] args) { \n # write the code \n}",
        "testcases": [
            {
                "input": "5\n30\n20\n40\n10\n25\ninorder",
                "expected_output": "10 20 25 30 40",
                "is_visible": true
            },
            {
                "input": "7\n50\n30\n70\n20\n40\n60\n80\ninorder",
                "expected_output": "20 30 40 50 60 70 80",
                "is_visible": true
            },
            {
                "input": "6\n10\n20\n30\n40\n50\n60\ninorder",
                "expected_output": "10 20 30 40 50 60",
                "is_visible": true
            },
            {
                "input": "9\n5\n15\n10\n20\n25\n30\n35\n40\n45\ninorder",
                "expected_output": "5 10 15 20 25 30 35 40 45",
                "is_visible": true
            },
            {
                "input": "12\n100\n50\n150\n25\n75\n125\n175\n12\n37\n62\n87\n112\ninorder",
                "expected_output": "12 25 37 50 62 75 87 100 112 125 150 175",
                "is_visible": true
            },
            {
                "input": "15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\ninorder",
                "expected_output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
                "is_visible": false
            },
            {
                "input": "10\n41\n20\n65\n11\n29\n50\n91\n32\n72\n99\ninorder",
                "expected_output": "11 20 29 32 41 50 65 72 91 99",
                "is_visible": false
            },
            {
                "input": "8\n500\n250\n750\n125\n375\n625\n875\n62\ninorder",
                "expected_output": "62 125 250 375 500 625 750 875",
                "is_visible": false
            },
            {
                "input": "14\n1000\n500\n1500\n250\n750\n1250\n1750\n125\n375\n625\n875\n1125\n1375\n1625\ninorder",
                "expected_output": "125 250 375 500 625 750 875 1000 1125 1250 1375 1500 1625 1750",
                "is_visible": false
            },
            {
                "input": "20\n45\n22\n67\n15\n33\n55\n78\n10\n18\n28\n40\n50\n60\n70\n80\n5\n12\n16\n19\n25\ninorder",
                "expected_output": "5 10 12 15 16 18 19 22 25 28 33 40 45 50 55 60 67 70 78 80",
                "is_visible": false
            }
        ]
    },
    {
        "title": "11.2 Deletion in an AVL Tree",
        "description": "Given an AVL tree, make sure that the given tree remains AVL after every deletion, we must augment the standard BST delete operation to perform some re-balancing. Following are two basic operations that can be performed to re-balance a BST without violating the BST property (keys(left) < key(root) < keys(right)). 1. Left Rotation 2. Right Rotation T1, T2 and T3 are subtrees of the tree rooted with y (on left side) or x (on right side) Keys in both of the above trees follow the following order keys(T1) < key(x) < keys(T2) < key(y) < keys(T3) So BST property is not violated anywhere. Procedure to delete a node from AVL tree: Let w be the node to be deleted 1. Perform standard BST delete for w. 2. Starting from w, travel up and find the first unbalanced node. Let z be the first unbalanced node, y be the larger height child of z, and x be the larger height child of y. Note that the definitions of x and y are different from insertion here. 3. Re-balance the tree by performing appropriate rotations on the subtree rooted with z. There can be 4 possible cases that needs to be handled as x, y and z can be arranged in 4 ways. Following are the possible 4 arrangements: i. y is left child of z and x is left child of y (Left Left Case) ii. y is left child of z and x is right child of y (Left Right Case) iii. y is right child of z and x is right child of y (Right Right Case) iv. y is right child of z and x is left child of y (Right Left Case)",
        "starter_code": "class TreeNode\n{\n    int val, height;\n    TreeNode left, right;\n\n    TreeNode(int d) {\n    val = d;\n    height = 1;\n}\n\nclass AVL_Tree {\n\n    TreeNode leftRotate(TreeNode z)\n    {\n    # Write code here\n    }\n\n    TreeNode rightRotate(TreeNode z)\n    {\n    # Write code here\n    }\n\n    TreeNode insert(TreeNode node, int key)\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "5\n30\n20\n40\n10\n25\ndelete 20\ninorder",
                "expected_output": "10 25 30 40",
                "is_visible": true
            },
            {
                "input": "7\n50\n30\n70\n20\n40\n60\n80\ndelete 30\ninorder",
                "expected_output": "20 40 50 60 70 80",
                "is_visible": true
            },
            {
                "input": "6\n10\n20\n30\n40\n50\n60\ndelete 40\ninorder",
                "expected_output": "10 20 30 50 60",
                "is_visible": true
            },
            {
                "input": "8\n45\n22\n67\n15\n33\n55\n78\n10\ndelete 45\ninorder",
                "expected_output": "10 15 22 33 55 67 78",
                "is_visible": true
            },
            {
                "input": "9\n50\n25\n75\n12\n37\n62\n87\n6\n18\ndelete 75\ninorder",
                "expected_output": "6 12 18 25 37 50 62 87",
                "is_visible": true
            },
            {
                "input": "12\n100\n50\n150\n25\n75\n125\n175\n12\n37\n62\n87\n112\ndelete 150\ninorder",
                "expected_output": "12 25 37 50 62 75 87 100 112 125 175",
                "is_visible": false
            },
            {
                "input": "10\n41\n20\n65\n11\n29\n50\n91\n32\n72\n99\ndelete 20\ndelete 65\ninorder",
                "expected_output": "11 29 32 41 50 72 91 99",
                "is_visible": false
            },
            {
                "input": "15\n8\n4\n12\n2\n6\n10\n14\n1\n3\n5\n7\n9\n11\n13\n15\ndelete 8\ndelete 12\ninorder",
                "expected_output": "1 2 3 4 5 6 7 9 10 11 13 14 15",
                "is_visible": false
            },
            {
                "input": "14\n500\n250\n750\n125\n375\n625\n875\n62\n187\n312\n437\n562\n687\n812\ndelete 750\ndelete 125\ninorder",
                "expected_output": "62 187 250 312 375 437 500 562 625 687 812 875",
                "is_visible": false
            },
            {
                "input": "20\n1000\n500\n1500\n250\n750\n1250\n1750\n125\n375\n625\n875\n1125\n1375\n1625\n1875\n62\n187\n312\n437\n562\ndelete 1000\ndelete 750\ninorder",
                "expected_output": "62 125 187 250 312 375 437 500 562 625 875 1125 1250 1375 1500 1625 1750 1875",
                "is_visible": false
            }
        ]
    },
    {
        "title": "11.3 Count Greater Nodes in AVL Tree",
        "description": "Given an AVL tree, calculate number of elements which are greater than given value in AVL tree.\nInput: x = 5\nRoot of below AVL tree\n    9\n    / \\\n    1  10\n    / \\\n    0  5  11\n    / \\\n    -1  2  6\nOutput: 4\nExplanation: There are 4 values which are greater than 5 in AVL tree which are 6, 9, 10 and 11.",
        "starter_code": "class TreeNode {\n    int key, height, desc;\n    TreeNode left, right;\n\n    TreeNode(int d) {\n    key = d;\n    height = 1;\n    desc = 0;\n}\n\nclass AVL_Tree\n{\n    # Write code here\n}\n\nTreeNode insert(TreeNode node, int key)\n{\n    # Write code here\n}\nTreeNode minValueNode(TreeNode node)\n{\n    # Write code here\n}\n\nTreeNode deleteNode(TreeNode root, int key)\n{\n    # Write code here\n}\n\nvoid preOrder(TreeNode node)\n{\n    # Write code here\n}\n\npublic class Main\n{\n    # Write code here\n}",
        "testcases": [
            {
                "input": "7\n9\n1\n10\n0\n5\n11\n2\ncount 5",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "5\n10\n5\n15\n3\n7\ncount 7",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "6\n20\n10\n30\n5\n15\n25\ncount 15",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "8\n50\n30\n70\n20\n40\n60\n80\n45\ncount 40",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "10\n100\n50\n150\n25\n75\n125\n175\n12\n37\n62\ncount 75",
                "expected_output": "5",
                "is_visible": true
            },
            {
                "input": "12\n200\n100\n300\n50\n150\n250\n350\n25\n75\n125\n175\n225\ncount 150",
                "expected_output": "6",
                "is_visible": false
            },
            {
                "input": "9\n45\n22\n67\n15\n33\n55\n78\n10\n18\ncount 30",
                "expected_output": "5",
                "is_visible": false
            },
            {
                "input": "15\n8\n4\n12\n2\n6\n10\n14\n1\n3\n5\n7\n9\n11\n13\n15\ncount 8",
                "expected_output": "7",
                "is_visible": false
            },
            {
                "input": "14\n500\n250\n750\n125\n375\n625\n875\n62\n187\n312\n437\n562\n687\n812\ncount 400",
                "expected_output": "8",
                "is_visible": false
            },
            {
                "input": "20\n1000\n500\n1500\n250\n750\n1250\n1750\n125\n375\n625\n875\n1125\n1375\n1625\n1875\n62\n187\n312\n437\n562\ncount 1000",
                "expected_output": "10",
                "is_visible": false
            }
        ]
    },
    {
        "title": "11.4 Minimum Number of Nodes in an AVL Tree with given Height",
        "description": "Given the height of an AVL tree 'h', the task is to find the minimum number of nodes the tree can have.\nInput: H = 0\nOutput: N = 1\nOnly '1' node is possible if the height\nof the tree is '0' which is the root node.\nInput: H = 3\nOutput: N = 7\nRecursive approach:\nIn an AVL tree, we have to maintain the height balance property, i.e. difference in the height of the left and the right subtrees cannot be other than -1, 0 or 1 for each node.\nWe will try to create a recurrence relation to find minimum number of nodes for a given height, n(h).\n- For height = 0, we can only have a single node in an AVL tree, i.e. n(0) = 1\n- For height = 1, we can have a minimum of two nodes in an AVL tree, i.e. n(1) = 2\n- Now for any height 'h', root will have two subtrees (left and right). Out of which one has to be of height h-1 and other of h-2. [root node excluded]\n- So, n(h) = 1 + n(h-1) + n(h-2) is the required recurrence relation for h> = 2 [1 is added for the root node]",
        "starter_code": "public class AVLTreeMinimumNodes {\n    public static int AVLnodes(int height)\n    {\n    # Write code here\n    }\n\n    public static void main(String[] args) {\n    int H = 3;\n    System.out.println(AVLnodes(H)); // Output: 4\n    }\n}",
        "testcases": [
            {
                "input": "0",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "1",
                "expected_output": "2",
                "is_visible": true
            },
            {
                "input": "2",
                "expected_output": "4",
                "is_visible": true
            },
            {
                "input": "3",
                "expected_output": "7",
                "is_visible": true
            },
            {
                "input": "4",
                "expected_output": "12",
                "is_visible": true
            },
            {
                "input": "5",
                "expected_output": "20",
                "is_visible": false
            },
            {
                "input": "6",
                "expected_output": "33",
                "is_visible": false
            },
            {
                "input": "7",
                "expected_output": "54",
                "is_visible": false
            },
            {
                "input": "8",
                "expected_output": "88",
                "is_visible": false
            },
            {
                "input": "9",
                "expected_output": "143",
                "is_visible": false
            }
        ]
    },
    {
        "title": "12.1 Breadth First Search",
        "description": "The Breadth First Search (BFS) algorithm is used to search a graph data structure for a node that meets a set of criteria. It starts at the root of the graph and visits all nodes at the current depth level before moving on to the nodes at the next depth level.\nFor a given graph G, print BFS traversal from a given source vertex.",
        "starter_code": "import java.util.*;\npublic class Graph {\n    private Map<Integer, List<Integer>> graph;\n    public Graph()\n    {\n    graph = new HashMap<>();\n    }\n    public void addEdge(int u, int v) {\n    if (!graph.containsKey(u)) {\n    graph.put(u, new ArrayList<>());\n    }\n    graph.get(u).add(v);\n    }\n    public void BFS(int s)\n    {\n    # Write code here\n    }\n    public static void main(String[] args)\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "4 3\n0 1\n0 2\n0 3\n0",
                "expected_output": "0 1 2 3",
                "is_visible": true
            },
            {
                "input": "5 4\n0 1\n0 2\n0 3\n2 4\n0",
                "expected_output": "0 1 2 3 4",
                "is_visible": true
            },
            {
                "input": "6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0",
                "expected_output": "0 1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "7 6\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n0",
                "expected_output": "0 1 2 3 4 5 6",
                "is_visible": true
            },
            {
                "input": "8 7\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n0",
                "expected_output": "0 1 2 3 4 5 6 7",
                "is_visible": true
            },
            {
                "input": "10 9\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9",
                "is_visible": false
            },
            {
                "input": "12 11\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11",
                "is_visible": false
            },
            {
                "input": "15 14\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14",
                "is_visible": false
            },
            {
                "input": "20 19\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19",
                "is_visible": false
            },
            {
                "input": "25 24\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24",
                "is_visible": false
            }
        ]
    },
    {
        "title": "12.2 Depth First Search",
        "description": "Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array. A graph can have more than one DFS traversal.\nFor a given graph G, print DFS traversal from a given source vertex.",
        "starter_code": "import java.util.*;\nclass Graph {\n    private Map<Integer, List<Integer>> graph;\n\n    public Graph() {\n    // Initialize the graph as a HashMap of ArrayLists\n    graph = new HashMap>();\n    }\n    public void addEdge(int u, int v)\n    {\n    # Write code here\n    }\n\n    public void DFS(int v) {\n    DFSUtil(v, visited);\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "4 3\n0 1\n0 2\n0 3\n0",
                "expected_output": "0 1 2 3",
                "is_visible": true
            },
            {
                "input": "5 4\n0 1\n0 2\n0 3\n2 4\n0",
                "expected_output": "0 1 2 3 4",
                "is_visible": true
            },
            {
                "input": "6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0",
                "expected_output": "0 1 3 4 2 5",
                "is_visible": true
            },
            {
                "input": "7 6\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n0",
                "expected_output": "0 1 3 4 2 5 6",
                "is_visible": true
            },
            {
                "input": "8 7\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n0",
                "expected_output": "0 1 3 6 4 7 2 5",
                "is_visible": true
            },
            {
                "input": "10 9\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n0",
                "expected_output": "0 1 3 6 9 4 7 2 5 8",
                "is_visible": false
            },
            {
                "input": "12 11\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n0",
                "expected_output": "0 1 3 6 9 4 7 10 2 5 8 11",
                "is_visible": false
            },
            {
                "input": "15 14\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n0",
                "expected_output": "0 1 3 6 9 12 4 7 10 13 2 5 8 11 14",
                "is_visible": false
            },
            {
                "input": "20 19\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n0",
                "expected_output": "0 1 3 6 9 12 15 18 4 7 10 13 16 19 2 5 8 11 14 17",
                "is_visible": false
            },
            {
                "input": "25 24\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n0",
                "expected_output": "0 1 3 6 9 12 15 18 21 24 4 7 10 13 16 19 22 2 5 8 11 14 17 20 23",
                "is_visible": false
            }
        ]
    },
    {
        "title": "12.3 Best First Search (Informed Search)",
        "description": "The idea of Best First Search is to use an evaluation function to decide which adjacent is most promising and then explore. Best First Search falls under the category of Heuristic Search or Informed Search.\nImplementation of Best First Search:\nWe use a priority queue or heap to store the costs of nodes that have the lowest evaluation function value. So the implementation is a variation of BFS, we just need to change Queue to PriorityQueue.\nAlgorithm:\nBest-First-Search(Graph g, Node start)\n1) Create an empty PriorityQueue\n   PriorityQueue pq;\n2) Insert \"start\" in pq.\n   pq.insert(start)\n3) Until PriorityQueue is empty\n   u = PriorityQueue.DeleteMin\n   If u is the goal\n    Exit\n   Else\n    Foreach neighbor v of u\n    If v \"Unvisited\"\n    Mark v \"Visited\"\n    pq.insert(v)\n    Mark u \"Examined\"\nEnd procedure",
        "starter_code": "import java.util.*;\n\npublic class BestFirstSearch {\n    static int v = 14;\n    static List<List<Pair<Integer>, Integer>>> graph = new ArrayList<>();\n    static void addedge(int x, int y, int cost) {\n    graph.get(x).add(new Pair<>(y, cost));\n    graph.get(y).add(new Pair<>(x, cost));\n}\n\nstatic void best_first_search(int actual_Src, int target, int n)\n{\n    # Write code here\n    }\n\n    public static void main(String[] args)\n    {\n    # Write code here\n    }\n}",
        "testcases": [
            {
                "input": "5 6\n0 1 4\n0 2 2\n1 3 5\n1 4 12\n2 3 2\n3 4 3\n0 4",
                "expected_output": "0 2 3 4",
                "is_visible": true
            },
            {
                "input": "6 8\n0 1 7\n0 2 9\n0 5 14\n1 2 10\n1 3 15\n2 3 11\n2 5 2\n3 4 6\n0 4",
                "expected_output": "0 2 5 3 4",
                "is_visible": true
            },
            {
                "input": "7 10\n0 1 4\n0 2 3\n1 3 2\n1 4 5\n2 3 1\n2 5 6\n3 4 7\n3 5 4\n4 6 3\n5 6 2\n0 6",
                "expected_output": "0 2 3 1 4 6",
                "is_visible": true
            },
            {
                "input": "8 12\n0 1 3\n0 2 6\n0 3 2\n1 4 4\n2 4 5\n2 5 8\n3 5 9\n4 6 7\n4 7 5\n5 6 3\n5 7 4\n6 7 2\n0 7",
                "expected_output": "0 1 4 7",
                "is_visible": true
            },
            {
                "input": "10 15\n0 1 2\n0 2 4\n0 3 3\n1 4 7\n2 4 5\n2 5 6\n3 5 8\n4 6 4\n4 7 5\n5 7 3\n5 8 6\n6 9 2\n7 9 4\n7 8 5\n8 9 3\n0 9",
                "expected_output": "0 1 4 6 9",
                "is_visible": true
            },
            {
                "input": "12 20\n0 1 4\n0 2 3\n0 3 5\n1 4 6\n2 4 7\n2 5 8\n3 5 9\n4 6 2\n4 7 5\n5 7 4\n5 8 6\n6 9 3\n6 10 7\n7 9 5\n7 10 8\n8 10 9\n8 11 6\n9 11 4\n10 11 5\n0 11",
                "expected_output": "0 2 4 6 9 11",
                "is_visible": false
            },
            {
                "input": "15 25\n0 1 2\n0 2 4\n0 3 3\n1 4 5\n2 4 6\n2 5 7\n3 5 8\n4 6 9\n4 7 4\n5 7 5\n5 8 6\n6 9 3\n6 10 7\n7 9 5\n7 10 8\n8 10 9\n8 11 6\n9 12 4\n9 13 5\n10 13 6\n10 14 7\n11 14 8\n12 14 9\n13 14 3\n0 14",
                "expected_output": "0 1 4 7 9 12 14",
                "is_visible": false
            },
            {
                "input": "20 30\n0 1 3\n0 2 5\n0 3 4\n1 4 6\n2 4 7\n2 5 8\n3 5 9\n4 6 10\n4 7 5\n5 7 6\n5 8 7\n6 9 8\n6 10 9\n7 9 10\n7 10 11\n8 10 12\n8 11 13\n9 12 14\n9 13 15\n10 13 16\n10 14 17\n11 14 18\n12 15 19\n12 16 20\n13 16 21\n13 17 22\n14 17 23\n14 18 24\n15 19 25\n16 19 26\n0 19",
                "expected_output": "0 1 4 7 9 12 15 19",
                "is_visible": false
            },
            {
                "input": "25 40\n0 1 4\n0 2 5\n0 3 6\n1 4 7\n2 4 8\n2 5 9\n3 5 10\n4 6 11\n4 7 12\n5 7 13\n5 8 14\n6 9 15\n6 10 16\n7 10 17\n7 11 18\n8 11 19\n8 12 20\n9 13 21\n9 14 22\n10 14 23\n10 15 24\n11 15 25\n11 16 26\n12 16 27\n13 17 28\n13 18 29\n14 18 30\n14 19 31\n15 19 32\n15 20 33\n16 20 34\n16 21 35\n17 22 36\n18 22 37\n19 23 38\n20 23 39\n21 24 40\n22 24 41\n23 24 42\n0 24",
                "expected_output": "0 1 4 7 10 15 19 23 24",
                "is_visible": false
            },
            {
                "input": "30 50\n0 1 5\n0 2 6\n0 3 7\n1 4 8\n2 4 9\n2 5 10\n3 5 11\n4 6 12\n4 7 13\n5 7 14\n5 8 15\n6 9 16\n6 10 17\n7 10 18\n7 11 19\n8 11 20\n9 12 21\n9 13 22\n10 13 23\n10 14 24\n11 14 25\n11 15 26\n12 16 27\n13 16 28\n13 17 29\n14 17 30\n14 18 31\n15 18 32\n16 19 33\n17 19 34\n17 20 35\n18 20 36\n19 21 37\n20 21 38\n21 22 39\n22 23 40\n23 24 41\n24 25 42\n25 26 43\n26 27 44\n27 28 45\n28 29 46\n0 29",
                "expected_output": "0 1 4 7 10 14 18 21 24 27 29",
                "is_visible": false
            }
        ]
    },
    {
        "title": "12.4 Breadth First Traversal of a Graph",
        "description": "Given a directed graph. The task is to do Breadth First Traversal of this graph starting from 0. One can move from node u to node v only if there's an edge from u to v. Find the BFS traversal of the graph starting from the 0th vertex, from left to right according to the input graph. Also, you should only take nodes directly or indirectly connected from Node 0 in consideration.",
        "starter_code": "import java.util.*;\n\nclass Graph {\n    private int v;\n    private LinkedList<Integer>[] adj;\n\n    Graph(int v) {\n    V = v;\n    adj = new LinkedList[v];\n    for (int i = 0; i < v; ++i)\n    adj[i] = new LinkedList();\n}\n\nvoid addEdge(int v, int w) {\n    adj[v].add(w);\n}\n\nvoid BFS(int s)\n{\n    # Write Code Here\n}\npublic static void main(String args[]) {\n    # Write Code Here\n}\n}",
        "testcases": [
            {
                "input": "5 4\n0 1\n0 2\n0 3\n2 4\n0",
                "expected_output": "0 1 2 3 4",
                "is_visible": true
            },
            {
                "input": "6 5\n0 1\n0 2\n1 3\n1 4\n2 5\n0",
                "expected_output": "0 1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "7 6\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n0",
                "expected_output": "0 1 2 3 4 5 6",
                "is_visible": true
            },
            {
                "input": "8 7\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n0",
                "expected_output": "0 1 2 3 4 5 6 7",
                "is_visible": true
            },
            {
                "input": "10 9\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9",
                "is_visible": true
            },
            {
                "input": "12 11\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11",
                "is_visible": false
            },
            {
                "input": "15 14\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14",
                "is_visible": false
            },
            {
                "input": "20 19\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19",
                "is_visible": false
            },
            {
                "input": "25 24\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24",
                "is_visible": false
            },
            {
                "input": "30 29\n0 1\n0 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 12\n10 13\n11 14\n12 15\n13 16\n14 17\n15 18\n16 19\n17 20\n18 21\n19 22\n20 23\n21 24\n22 25\n23 26\n24 27\n25 28\n26 29\n0",
                "expected_output": "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29",
                "is_visible": false
            }
        ]
    },
    {
        "title": "12.5 Depth First Search (DFS) for Disconnected Graph",
        "description": "Given a Disconnected Graph, the task is to implement DFS or Depth First Search Algorithm for this Disconnected Graph.\nProcedure for DFS on Disconnected Graph:\nIterate over all the vertices of the graph and for any unvisited vertex, run a DFS from that vertex.",
        "starter_code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n// Class representing a directed graph using adjacency list representation class Graph\n{\n    # Write Code Here\n}\n\npublic Graph()\n{\n    graph = new HashMap<>();\n}\n\npublic void addEdge(int u, int v)\n{\n    # Write Code Here\n    }\nprivate void DFSUtil(int v, boolean[] visited)\n    {\n    # Write Code Here\n    }\n}\n\npublic void DFS() {\n    boolean[] visited = new boolean[graph.size()];\n    # Write Code Here\n    }\n\npublic static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "6 4\n0 1\n0 2\n1 2\n3 4\n5",
                "expected_output": "0 1 2 3 4 5",
                "is_visible": true
            },
            {
                "input": "8 6\n0 1\n0 2\n1 3\n2 3\n4 5\n6 7",
                "expected_output": "0 1 3 2 4 5 6 7",
                "is_visible": true
            },
            {
                "input": "10 8\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9",
                "expected_output": "0 1 3 2 4 5 6 8 7 9",
                "is_visible": true
            },
            {
                "input": "12 10\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n11",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11",
                "is_visible": true
            },
            {
                "input": "15 12\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14",
                "is_visible": true
            },
            {
                "input": "20 16\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19",
                "is_visible": false
            },
            {
                "input": "25 20\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24",
                "is_visible": false
            },
            {
                "input": "30 24\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24\n25 26\n25 27\n26 28\n27 29",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24 25 26 28 27 29",
                "is_visible": false
            },
            {
                "input": "35 28\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24\n25 26\n25 27\n26 28\n27 29\n30 31\n30 32\n31 33\n32 34",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24 25 26 28 27 29 30 31 33 32 34",
                "is_visible": false
            },
            {
                "input": "40 32\n0 1\n0 2\n1 3\n2 4\n5 6\n5 7\n6 8\n7 9\n10 11\n10 12\n11 13\n12 14\n15 16\n15 17\n16 18\n17 19\n20 21\n20 22\n21 23\n22 24\n25 26\n25 27\n26 28\n27 29\n30 31\n30 32\n31 33\n32 34\n35 36\n35 37\n36 38\n37 39",
                "expected_output": "0 1 3 2 4 5 6 8 7 9 10 11 13 12 14 15 16 18 17 19 20 21 23 22 24 25 26 28 27 29 30 31 33 32 34 35 36 38 37 39",
                "is_visible": false
            }
        ]
    },
    {
        "title": "13.1 Kruskal\u2019s Algorithm",
        "description": "In Kruskal\u2019s algorithm, sort all edges of the given graph in increasing order. Then it keeps on adding new edges and nodes in the MST if the newly added edge does not form a cycle. It picks the minimum weighted edge at first and the maximum weighted edge at last.\nMST using Kruskal\u2019s algorithm:\n1. Sort all the edges in non-decreasing order of their weight.\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If the cycle is not formed, include this edge. Else, discard it.\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\nKruskal\u2019s algorithm to find the minimum cost spanning tree uses the greedy approach. The Greedy Choice is to pick the smallest weight edge that does not cause a cycle in the MST constructed so far.",
        "starter_code": "import java.util.*;\n\npublic class Graph {\n    class Edge implements Comparable<Edge> {\n    int src, dest, weight;\n    // Comparator function used for sorting edges\n    public int compareTo(Edge compareEdge) {\n    return this.weight - compareEdge.weight;\n    }\n}\n\nprivate int V; // Number of vertices\nprivate List<Edge> edges; // List of edges\n\npublic Graph(int vertices) {\n    this.V = vertices;\n    this.edges = new ArrayList<>();\n}\n\npublic void addEdge(int u, int v, int w)\n{\n    # Write Code Here\n    }\nprivate void union(int[] parent, int[] rank, int x, int y)\n{\n    # Write Code Here\n    }\n\npublic void KruskalMST()\n{\n    # Write Code Here\n    }\n}\n\npublic static void main(String[] args) {\n    Graph g = new Graph(4);\n    g.addEdge(0, 1, 10);\n    g.addEdge(0, 2, 6);\n    g.addEdge(0, 3, 5);\n    g.addEdge(1, 3, 15);\n    g.addEdge(2, 3, 4);\n\n    // Function call\n    g.KruskalMST();\n\n}",
        "testcases": [
            {
                "input": "4 5\n0 1 10\n0 2 6\n0 3 5\n1 3 15\n2 3 4",
                "expected_output": "2 3 4\n0 3 5\n0 1 10\n19",
                "is_visible": true
            },
            {
                "input": "5 7\n0 1 2\n0 3 6\n1 2 3\n1 3 8\n1 4 5\n2 4 7\n3 4 9",
                "expected_output": "0 1 2\n1 2 3\n1 4 5\n0 3 6\n16",
                "is_visible": true
            },
            {
                "input": "6 9\n0 1 4\n0 2 4\n1 2 2\n1 3 6\n2 3 8\n2 4 4\n3 4 9\n3 5 2\n4 5 3",
                "expected_output": "1 2 2\n3 5 2\n4 5 3\n0 1 4\n0 2 4\n14",
                "is_visible": true
            },
            {
                "input": "7 11\n0 1 7\n0 3 5\n1 2 8\n1 3 9\n1 4 7\n2 4 5\n3 4 15\n3 5 6\n4 5 8\n4 6 9\n5 6 11",
                "expected_output": "0 3 5\n2 4 5\n3 5 6\n0 1 7\n1 4 7\n4 6 9\n39",
                "is_visible": true
            },
            {
                "input": "8 14\n0 1 4\n0 7 8\n1 2 8\n1 7 11\n2 3 7\n2 5 4\n2 8 2\n3 4 9\n3 5 14\n4 5 10\n5 6 2\n6 7 1\n6 8 6\n7 8 7",
                "expected_output": "6 7 1\n2 8 2\n5 6 2\n0 1 4\n2 5 4\n2 3 7\n0 7 8\n1 2 8\n37",
                "is_visible": true
            },
            {
                "input": "10 20\n0 1 2\n0 2 4\n0 3 3\n1 4 7\n2 4 5\n2 5 6\n3 5 8\n4 6 4\n4 7 5\n5 7 3\n5 8 6\n6 9 2\n7 9 4\n7 8 5\n8 9 3\n9 10 1\n10 11 2\n11 12 3\n12 13 4\n13 14 5",
                "expected_output": "9 10 1\n0 1 2\n6 9 2\n10 11 2\n5 7 3\n8 9 3\n11 12 3\n0 3 3\n0 2 4\n4 6 4\n7 9 4\n12 13 4\n2 4 5\n4 7 5\n7 8 5\n13 14 5\n2 5 6\n5 8 6\n1 4 7\n3 5 8\n92",
                "is_visible": false
            },
            {
                "input": "12 25\n0 1 3\n0 2 5\n0 3 4\n1 4 6\n2 4 7\n2 5 8\n3 5 9\n4 6 10\n4 7 5\n5 7 6\n5 8 7\n6 9 8\n6 10 9\n7 9 10\n7 10 11\n8 10 12\n8 11 13\n9 11 14\n9 12 15\n10 12 16\n10 13 17\n11 13 18\n12 13 19\n12 14 20\n13 14 21",
                "expected_output": "0 1 3\n0 3 4\n4 7 5\n1 4 6\n5 7 6\n5 8 7\n6 9 8\n6 10 9\n7 9 10\n4 6 10\n7 10 11\n8 10 12\n8 11 13\n9 11 14\n9 12 15\n10 12 16\n10 13 17\n11 13 18\n12 13 19\n12 14 20\n13 14 21\n238",
                "is_visible": false
            },
            {
                "input": "15 30\n0 1 4\n0 2 5\n0 3 6\n1 4 7\n2 4 8\n2 5 9\n3 5 10\n4 6 11\n4 7 12\n5 7 13\n5 8 14\n6 9 15\n6 10 16\n7 10 17\n7 11 18\n8 11 19\n8 12 20\n9 13 21\n9 14 22\n10 14 23\n10 15 24\n11 15 25\n11 16 26\n12 16 27\n13 17 28\n14 17 29\n15 18 30\n16 18 31\n17 19 32\n18 19 33",
                "expected_output": "0 1 4\n0 2 5\n0 3 6\n1 4 7\n2 4 8\n2 5 9\n3 5 10\n4 6 11\n4 7 12\n5 7 13\n5 8 14\n6 9 15\n6 10 16\n7 10 17\n7 11 18\n8 11 19\n8 12 20\n9 13 21\n9 14 22\n10 14 23\n10 15 24\n11 15 25\n11 16 26\n12 16 27\n13 17 28\n14 17 29\n15 18 30\n16 18 31\n17 19 32\n18 19 33\n465",
                "is_visible": false
            },
            {
                "input": "20 40\n0 1 5\n0 2 6\n0 3 7\n1 4 8\n2 4 9\n2 5 10\n3 5 11\n4 6 12\n4 7 13\n5 7 14\n5 8 15\n6 9 16\n6 10 17\n7 10 18\n7 11 19\n8 11 20\n9 12 21\n9 13 22\n10 13 23\n10 14 24\n11 14 25\n11 15 26\n12 16 27\n13 16 28\n13 17 29\n14 17 30\n14 18 31\n15 18 32\n16 19 33\n17 19 34\n18 20 35\n19 20 36\n20 21 37\n21 22 38\n22 23 39\n23 24 40\n24 25 41\n25 26 42\n26 27 43\n27 28 44",
                "expected_output": "0 1 5\n0 2 6\n0 3 7\n1 4 8\n2 4 9\n2 5 10\n3 5 11\n4 6 12\n4 7 13\n5 7 14\n5 8 15\n6 9 16\n6 10 17\n7 10 18\n7 11 19\n8 11 20\n9 12 21\n9 13 22\n10 13 23\n10 14 24\n11 14 25\n11 15 26\n12 16 27\n13 16 28\n13 17 29\n14 17 30\n14 18 31\n15 18 32\n16 19 33\n17 19 34\n18 20 35\n19 20 36\n20 21 37\n21 22 38\n22 23 39\n23 24 40\n24 25 41\n25 26 42\n26 27 43\n27 28 44\n860",
                "is_visible": false
            },
            {
                "input": "25 50\n0 1 6\n0 2 7\n0 3 8\n1 4 9\n2 4 10\n2 5 11\n3 5 12\n4 6 13\n4 7 14\n5 7 15\n5 8 16\n6 9 17\n6 10 18\n7 10 19\n7 11 20\n8 11 21\n9 12 22\n9 13 23\n10 13 24\n10 14 25\n11 14 26\n11 15 27\n12 16 28\n13 16 29\n13 17 30\n14 17 31\n14 18 32\n15 18 33\n16 19 34\n17 19 35\n18 20 36\n19 20 37\n20 21 38\n21 22 39\n22 23 40\n23 24 41\n24 25 42\n25 26 43\n26 27 44\n27 28 45\n28 29 46\n29 30 47\n30 31 48\n31 32 49\n32 33 50\n33 34 51\n34 35 52\n35 36 53\n36 37 54\n37 38 55",
                "expected_output": "0 1 6\n0 2 7\n0 3 8\n1 4 9\n2 4 10\n2 5 11\n3 5 12\n4 6 13\n4 7 14\n5 7 15\n5 8 16\n6 9 17\n6 10 18\n7 10 19\n7 11 20\n8 11 21\n9 12 22\n9 13 23\n10 13 24\n10 14 25\n11 14 26\n11 15 27\n12 16 28\n13 16 29\n13 17 30\n14 17 31\n14 18 32\n15 18 33\n16 19 34\n17 19 35\n18 20 36\n19 20 37\n20 21 38\n21 22 39\n22 23 40\n23 24 41\n24 25 42\n25 26 43\n26 27 44\n27 28 45\n28 29 46\n29 30 47\n30 31 48\n31 32 49\n32 33 50\n33 34 51\n34 35 52\n35 36 53\n36 37 54\n37 38 55\n1463",
                "is_visible": false
            }
        ]
    },
    {
        "title": "13.2 Prim\u2019s Algorithm",
        "description": "The Prim\u2019s algorithm starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, and the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.\nPrim\u2019s Algorithm:\nThe working of Prim\u2019s algorithm can be described by using the following steps:\n1. Determine an arbitrary vertex as the starting vertex of the MST.\n2. Follow steps 3 to 5 till there are vertices that are not included in the MST (known as fringe vertex).\n3. Find edges connecting any tree vertex with the fringe vertices.\n4. Find the minimum among these edges.\n5. Add the chosen edge to the MST if it does not form any cycle.\n6. Return the MST and exit",
        "starter_code": "import java.util.Arrays;\n\npublic class Graph {\n    private int V; // Number of vertices\n    private int[][] graph; // Adjacency matrix representation of graph\n\n    public Graph(int vertices) {\n    this.V = vertices;\n    this.graph = new int[V][V];\n    }\n    public void printMST(int[] parent) {\n    System.out.println(\"Edge \\tWeight\");\n    for (int i = 1; i < V; i++) {\n    System.out.println(parent[i] + \" - \" + i + \"\\t\" + graph[i][parent[i]]);\n    }\n    }\n    private int minKey(int[] key, boolean[] mstSet)\n    {\n    # Write Code Here\n    }\n    public void primMST()\n    {\n    # Write Code Here\n    }\n    public static void main(String[] args)\n    {\n    # Write Code Here\n    }\n}",
        "testcases": [
            {
                "input": "4\n0 2 0 6\n2 0 3 8\n0 3 0 0\n6 8 0 0",
                "expected_output": "0 - 1 2\n1 - 2 3\n0 - 3 6\n11",
                "is_visible": true
            },
            {
                "input": "5\n0 2 0 6 0\n2 0 3 8 5\n0 3 0 0 7\n6 8 0 0 9\n0 5 7 9 0",
                "expected_output": "0 - 1 2\n1 - 2 3\n0 - 3 6\n1 - 4 5\n16",
                "is_visible": true
            },
            {
                "input": "6\n0 4 0 0 0 0\n4 0 8 0 0 0\n0 8 0 7 0 4\n0 0 7 0 9 14\n0 0 0 9 0 10\n0 0 4 14 10 0",
                "expected_output": "0 - 1 4\n2 - 3 7\n2 - 5 4\n3 - 4 9\n1 - 2 8\n32",
                "is_visible": true
            },
            {
                "input": "7\n0 7 0 5 0 0 0\n7 0 8 9 7 0 0\n0 8 0 0 5 0 0\n5 9 0 0 15 6 0\n0 7 5 15 0 8 9\n0 0 0 6 8 0 11\n0 0 0 0 9 11 0",
                "expected_output": "0 - 1 7\n0 - 3 5\n1 - 4 7\n2 - 4 5\n3 - 5 6\n4 - 6 9\n39",
                "is_visible": true
            },
            {
                "input": "8\n0 4 0 0 0 0 0 8\n4 0 8 0 0 0 0 11\n0 8 0 7 0 4 0 0\n0 0 7 0 9 14 0 0\n0 0 0 9 0 10 0 0\n0 0 4 14 10 0 2 0\n0 0 0 0 0 2 0 1\n8 11 0 0 0 0 1 0",
                "expected_output": "0 - 1 4\n2 - 3 7\n2 - 5 4\n5 - 6 2\n6 - 7 1\n1 - 2 8\n0 - 7 8\n34",
                "is_visible": true
            },
            {
                "input": "10\n0 10 0 0 0 0 0 0 0 0\n10 0 20 0 0 0 0 0 0 0\n0 20 0 30 0 0 0 0 0 0\n0 0 30 0 40 0 0 0 0 0\n0 0 0 40 0 50 0 0 0 0\n0 0 0 0 50 0 60 0 0 0\n0 0 0 0 0 60 0 70 0 0\n0 0 0 0 0 0 70 0 80 0\n0 0 0 0 0 0 0 80 0 90\n0 0 0 0 0 0 0 0 90 0",
                "expected_output": "0 - 1 10\n1 - 2 20\n2 - 3 30\n3 - 4 40\n4 - 5 50\n5 - 6 60\n6 - 7 70\n7 - 8 80\n8 - 9 90\n450",
                "is_visible": false
            },
            {
                "input": "12\n0 5 0 0 0 0 0 0 0 0 0 0\n5 0 10 0 0 0 0 0 0 0 0 0\n0 10 0 15 0 0 0 0 0 0 0 0\n0 0 15 0 20 0 0 0 0 0 0 0\n0 0 0 20 0 25 0 0 0 0 0 0\n0 0 0 0 25 0 30 0 0 0 0 0\n0 0 0 0 0 30 0 35 0 0 0 0\n0 0 0 0 0 0 35 0 40 0 0 0\n0 0 0 0 0 0 0 40 0 45 0 0\n0 0 0 0 0 0 0 0 45 0 50 0\n0 0 0 0 0 0 0 0 0 50 0 55\n0 0 0 0 0 0 0 0 0 0 55 0",
                "expected_output": "0 - 1 5\n1 - 2 10\n2 - 3 15\n3 - 4 20\n4 - 5 25\n5 - 6 30\n6 - 7 35\n7 - 8 40\n8 - 9 45\n9 - 10 50\n10 - 11 55\n330",
                "is_visible": false
            },
            {
                "input": "15\n0 3 0 0 0 0 0 0 0 0 0 0 0 0 0\n3 0 4 0 0 0 0 0 0 0 0 0 0 0 0\n0 4 0 5 0 0 0 0 0 0 0 0 0 0 0\n0 0 5 0 6 0 0 0 0 0 0 0 0 0 0\n0 0 0 6 0 7 0 0 0 0 0 0 0 0 0\n0 0 0 0 7 0 8 0 0 0 0 0 0 0 0\n0 0 0 0 0 8 0 9 0 0 0 0 0 0 0\n0 0 0 0 0 0 9 0 10 0 0 0 0 0 0\n0 0 0 0 0 0 0 10 0 11 0 0 0 0 0\n0 0 0 0 0 0 0 0 11 0 12 0 0 0 0\n0 0 0 0 0 0 0 0 0 12 0 13 0 0 0\n0 0 0 0 0 0 0 0 0 0 13 0 14 0 0\n0 0 0 0 0 0 0 0 0 0 0 14 0 15 0\n0 0 0 0 0 0 0 0 0 0 0 0 15 0 16\n0 0 0 0 0 0 0 0 0 0 0 0 0 16 0",
                "expected_output": "0 - 1 3\n1 - 2 4\n2 - 3 5\n3 - 4 6\n4 - 5 7\n5 - 6 8\n6 - 7 9\n7 - 8 10\n8 - 9 11\n9 - 10 12\n10 - 11 13\n11 - 12 14\n12 - 13 15\n13 - 14 16\n119",
                "is_visible": false
            },
            {
                "input": "20\n0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 3 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 4 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 5 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 6 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 7 0 8 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 8 0 9 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 9 0 10 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 10 0 11 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 11 0 12 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 12 0 13 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 13 0 14 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 14 0 15 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 15 0 16 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 0 17 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 17 0 18 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 0 19 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19 0 20\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 0",
                "expected_output": "0 - 1 2\n1 - 2 3\n2 - 3 4\n3 - 4 5\n4 - 5 6\n5 - 6 7\n6 - 7 8\n7 - 8 9\n8 - 9 10\n9 - 10 11\n10 - 11 12\n11 - 12 13\n12 - 13 14\n13 - 14 15\n14 - 15 16\n15 - 16 17\n16 - 17 18\n17 - 18 19\n18 - 19 20\n209",
                "is_visible": false
            },
            {
                "input": "25\n0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 3 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 5 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 6 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 7 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 8 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 9 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 10 0 11 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 11 0 12 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 12 0 13 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 13 0 14 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 15 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 0 16 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 0 17 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 17 0 18 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 0 19 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19 0 20 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 0 21 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 21 0 22 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 23 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 23 0 24\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 24 0",
                "expected_output": "0 - 1 1\n1 - 2 2\n2 - 3 3\n3 - 4 4\n4 - 5 5\n5 - 6 6\n6 - 7 7\n7 - 8 8\n8 - 9 9\n9 - 10 10\n10 - 11 11\n11 - 12 12\n12 - 13 13\n13 - 14 14\n14 - 15 15\n15 - 16 16\n16 - 17 17\n17 - 18 18\n18 - 19 19\n19 - 20 20\n20 - 21 21\n21 - 22 22\n22 - 23 23\n23 - 24 24\n300",
                "is_visible": false
            }
        ]
    },
    {
        "title": "13.3 Total Number of Spanning Trees in a Graph",
        "description": "If a graph is a complete graph with n vertices, then total number of spanning trees is n^(n-2) where n is the number of nodes in the graph. In complete graph, the task is equal to counting different labeled trees with n nodes for which have Cayley's formula.\n**Laplacian matrix:**\nA Laplacian matrix L, where L[i, j] is the degree of node i and L[i, j] = -1 if there is an edge between nodes i and j, and otherwise L[i, j] = 0.\nKirchhoff\u2019s theorem provides a way to calculate the number of spanning trees for a given graph as a determinant of a special matrix.",
        "starter_code": "import java.util.Arrays;\n\npublic class NumberOfSpanningTrees {\n    static final int MAX = 100;\n    static final int MOD = 1000000000;\n}\n\nvoid multiply(long[][] A, long[][] B, long[][] C, int size) {\n    for (int i = 0; i < size; i++) {\n    for (int j = 0; j < size; j++) {\n    C[i][j] = 0;\n    for (int k = 0; k < size; k++) {\n    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;\n    }\n    }\n}\n}\nvoid power(long[][] A, int N, long[][] result, int size)\n{\n    # Write Code Here\n}\n\nlong numOfSpanningTree(int[][] graph, int V)\n{\n    # Write Code Here\n}\n\npublic static void main(String[] args) {\n    int V = 4; // Number of vertices in graph\n    int E = 5; // Number of edges in graph\n    int[][] graph = { { 0, 1, 1, 1 }, { 1, 0, 1, 1 }, { 1, 1, 0, 1 }, { 1, 1, 1, 0 } };\n\n    NumberOfSpanningTrees obj = new NumberOfSpanningTrees();\n    System.out.println(obj.numOfSpanningTree(graph, V));\n}",
        "testcases": [
            {
                "input": "4\n0 1 1 1\n1 0 1 1\n1 1 0 1\n1 1 1 0",
                "expected_output": "16",
                "is_visible": true
            },
            {
                "input": "3\n0 1 1\n1 0 1\n1 1 0",
                "expected_output": "3",
                "is_visible": true
            },
            {
                "input": "5\n0 1 1 1 1\n1 0 1 1 1\n1 1 0 1 1\n1 1 1 0 1\n1 1 1 1 0",
                "expected_output": "125",
                "is_visible": true
            },
            {
                "input": "2\n0 1\n1 0",
                "expected_output": "1",
                "is_visible": true
            },
            {
                "input": "6\n0 1 1 1 1 1\n1 0 1 1 1 1\n1 1 0 1 1 1\n1 1 1 0 1 1\n1 1 1 1 0 1\n1 1 1 1 1 0",
                "expected_output": "1296",
                "is_visible": true
            },
            {
                "input": "7\n0 1 1 1 1 1 1\n1 0 1 1 1 1 1\n1 1 0 1 1 1 1\n1 1 1 0 1 1 1\n1 1 1 1 0 1 1\n1 1 1 1 1 0 1\n1 1 1 1 1 1 0",
                "expected_output": "16807",
                "is_visible": false
            },
            {
                "input": "8\n0 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1\n1 1 0 1 1 1 1 1\n1 1 1 0 1 1 1 1\n1 1 1 1 0 1 1 1\n1 1 1 1 1 0 1 1\n1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 0",
                "expected_output": "262144",
                "is_visible": false
            },
            {
                "input": "9\n0 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1\n1 1 1 1 0 1 1 1 1\n1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 0 1 1\n1 1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 1 0",
                "expected_output": "4782969",
                "is_visible": false
            },
            {
                "input": "10\n0 1 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1 1\n1 1 1 1 0 1 1 1 1 1\n1 1 1 1 1 0 1 1 1 1\n1 1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 1 0 1 1\n1 1 1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 1 1 0",
                "expected_output": "10000000",
                "is_visible": false
            },
            {
                "input": "11\n0 1 1 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1 1 1\n1 1 1 1 0 1 1 1 1 1 1\n1 1 1 1 1 0 1 1 1 1 1\n1 1 1 1 1 1 0 1 1 1 1\n1 1 1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 1 1 0 1 1\n1 1 1 1 1 1 1 1 1 0 1\n1 1 1 1 1 1 1 1 1 1 0",
                "expected_output": "19487171",
                "is_visible": false
            }
        ]
    },
    {
        "title": "13.4 Minimum Product Spanning Tree",
        "description": "A minimum product spanning tree for a weighted, connected, and undirected graph is a spanning tree with a weight product less than or equal to the weight product of every other spanning tree. The weight product of a spanning tree is the product of weights corresponding to each edge of the spanning tree. All weights of the given graph will be positive for simplicity.\nThis problem can be solved using standard minimum spanning tree algorithms like Kruskal and prim\u2019s algorithm, but we need to modify our graph to use these algorithms. Minimum spanning tree algorithms tries to minimize the total sum of weights, here we need to minimize the total product of weights. We can use the property of logarithms to overcome this problem.\nlog(w1* w2 * w3 * .... * wN) = log(w1) + log(w2) + log(w3) .... + log(wN)\nWe can replace each weight of the graph by its log value, then we apply any minimum spanning tree algorithm which will try to minimize the sum of log(wi) which in turn minimizes the weight product.",
        "starter_code": "import java.util.Arrays;\n\npublic class MinimumProductMST {\n    // Number of vertices in the graph\n    static final int V = 5;\n\n    // A utility function to find the vertex with minimum key value, from the set of\n    // vertices not yet included in MST\n    int minKey(int key[], boolean mstSet[]) {\n    int min = Integer.MAX_VALUE, min_index = -1;\n\n    for (int v = 0; v < V; v++) {\n    if (mstSet[v] == false && key[v] < min) {\n    min = key[v];\n    min_index = v;\n    }\n    }\n\n    return min_index;\n}\n\nvoid printMST(int parent[], int n, int graph[][])\n{\n    # Write Code Here\n    }\nvoid printMST(int inputGraph[][], int logGraph[][])\n{\n    # Write Code Here\n    }\nvoid minimumProductMST(int graph[][])\n{\n    # Write Code Here\n    }\npublic static void main(String[] args)\n{\n    # Write Code Here\n}\n}",
        "testcases": [
            {
                "input": "5\n0 2 0 6 0\n2 0 3 8 5\n0 3 0 0 7\n6 8 0 0 9\n0 5 7 9 0",
                "expected_output": "0 1 2\n1 2 3\n0 3 6\n1 4 5\n180",
                "is_visible": true
            },
            {
                "input": "4\n0 5 0 10\n5 0 6 0\n0 6 0 15\n10 0 15 0",
                "expected_output": "0 1 5\n1 2 6\n0 3 10\n300",
                "is_visible": true
            },
            {
                "input": "6\n0 4 0 0 0 0\n4 0 8 0 0 0\n0 8 0 7 0 4\n0 0 7 0 9 14\n0 0 0 9 0 10\n0 0 4 14 10 0",
                "expected_output": "0 1 4\n2 3 7\n2 5 4\n3 4 9\n1 2 8\n32256",
                "is_visible": true
            },
            {
                "input": "7\n0 2 0 3 0 0 0\n2 0 4 0 5 0 0\n0 4 0 6 0 7 0\n3 0 6 0 8 0 9\n0 5 0 8 0 10 0\n0 0 7 0 10 0 11\n0 0 0 9 0 11 0",
                "expected_output": "0 1 2\n0 3 3\n1 2 4\n2 5 7\n3 4 8\n5 6 11\n29568",
                "is_visible": true
            },
            {
                "input": "8\n0 3 0 4 0 0 0 0\n3 0 5 0 6 0 0 0\n0 5 0 7 0 8 0 0\n4 0 7 0 9 0 10 0\n0 6 0 9 0 11 0 12\n0 0 8 0 11 0 13 0\n0 0 0 10 0 13 0 14\n0 0 0 0 12 0 14 0",
                "expected_output": "0 1 3\n0 3 4\n1 2 5\n2 5 8\n3 4 9\n4 7 12\n5 6 13\n786240",
                "is_visible": true
            },
            {
                "input": "10\n0 2 0 3 0 0 0 0 0 0\n2 0 4 0 5 0 0 0 0 0\n0 4 0 6 0 7 0 0 0 0\n3 0 6 0 8 0 9 0 0 0\n0 5 0 8 0 10 0 11 0 0\n0 0 7 0 10 0 12 0 13 0\n0 0 0 9 0 12 0 14 0 15\n0 0 0 0 11 0 14 0 16 0\n0 0 0 0 0 13 0 16 0 17\n0 0 0 0 0 0 15 0 17 0",
                "expected_output": "0 1 2\n0 3 3\n1 2 4\n2 5 7\n3 4 8\n4 7 11\n5 6 12\n6 9 15\n7 8 16\n8 9 17\n170559360",
                "is_visible": false
            },
            {
                "input": "12\n0 3 0 4 0 0 0 0 0 0 0 0\n3 0 5 0 6 0 0 0 0 0 0 0\n0 5 0 7 0 8 0 0 0 0 0 0\n4 0 7 0 9 0 10 0 0 0 0 0\n0 6 0 9 0 11 0 12 0 0 0 0\n0 0 8 0 11 0 13 0 14 0 0 0\n0 0 0 10 0 13 0 15 0 16 0 0\n0 0 0 0 12 0 15 0 17 0 18 0\n0 0 0 0 0 14 0 17 0 19 0 20\n0 0 0 0 0 0 16 0 19 0 21 0\n0 0 0 0 0 0 0 18 0 21 0 22\n0 0 0 0 0 0 0 0 20 0 22 0",
                "expected_output": "0 1 3\n0 3 4\n1 2 5\n2 5 8\n3 4 9\n4 7 12\n5 6 13\n6 9 16\n7 8 17\n8 11 20\n9 10 21\n10 11 22\n1203948748800",
                "is_visible": false
            },
            {
                "input": "15\n0 4 0 5 0 0 0 0 0 0 0 0 0 0 0\n4 0 6 0 7 0 0 0 0 0 0 0 0 0 0\n0 6 0 8 0 9 0 0 0 0 0 0 0 0 0\n5 0 8 0 10 0 11 0 0 0 0 0 0 0 0\n0 7 0 10 0 12 0 13 0 0 0 0 0 0 0\n0 0 9 0 12 0 14 0 15 0 0 0 0 0 0\n0 0 0 11 0 14 0 16 0 17 0 0 0 0 0\n0 0 0 0 13 0 16 0 18 0 19 0 0 0 0\n0 0 0 0 0 15 0 18 0 20 0 21 0 0 0\n0 0 0 0 0 0 17 0 20 0 22 0 23 0 0\n0 0 0 0 0 0 0 19 0 22 0 24 0 25 0\n0 0 0 0 0 0 0 0 21 0 24 0 26 0 27\n0 0 0 0 0 0 0 0 0 23 0 26 0 28 0\n0 0 0 0 0 0 0 0 0 0 25 0 28 0 29\n0 0 0 0 0 0 0 0 0 0 0 27 0 29 0",
                "expected_output": "0 1 4\n0 3 5\n1 2 6\n2 5 9\n3 4 10\n4 7 13\n5 6 14\n6 9 17\n7 8 18\n8 11 21\n9 10 22\n10 13 25\n11 12 26\n12 14 29\n13 14 29\n1.2234528E19",
                "is_visible": false
            },
            {
                "input": "20\n0 5 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n5 0 7 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 7 0 9 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n6 0 9 0 11 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 0 11 0 13 0 14 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 10 0 13 0 15 0 16 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 12 0 15 0 17 0 18 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 14 0 17 0 19 0 20 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 16 0 19 0 21 0 22 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 18 0 21 0 23 0 24 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 20 0 23 0 25 0 26 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 22 0 25 0 27 0 28 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 24 0 27 0 29 0 30 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 26 0 29 0 31 0 32 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 28 0 31 0 33 0 34 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 30 0 33 0 35 0 36 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 35 0 37 0 38\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 34 0 37 0 39 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 36 0 39 0 40\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 38 0 40 0",
                "expected_output": "0 1 5\n0 3 6\n1 2 7\n2 5 10\n3 4 11\n4 7 14\n5 6 15\n6 9 18\n7 8 19\n8 11 22\n9 10 23\n10 13 26\n11 12 27\n12 15 30\n13 14 31\n14 17 34\n15 16 35\n16 19 38\n17 18 39\n18 19 40\n1.1342748E28",
                "is_visible": false
            },
            {
                "input": "25\n0 6 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n6 0 8 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 0 10 0 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n7 0 10 0 12 0 13 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 9 0 12 0 14 0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 11 0 14 0 16 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 13 0 16 0 18 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 15 0 18 0 20 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 17 0 20 0 22 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 19 0 22 0 24 0 25 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 21 0 24 0 26 0 27 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 23 0 26 0 28 0 29 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 25 0 28 0 30 0 31 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 27 0 30 0 32 0 33 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 29 0 32 0 34 0 35 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 31 0 34 0 36 0 37 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 33 0 36 0 38 0 39 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 35 0 38 0 40 0 41 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 37 0 40 0 42 0 43 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 39 0 42 0 44 0 45 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41 0 44 0 46 0 47 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 43 0 46 0 48 0 49\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 45 0 48 0 50 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 47 0 50 0 51\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 49 0 51 0",
                "expected_output": "0 1 6\n0 3 7\n1 2 8\n2 5 11\n3 4 12\n4 7 15\n5 6 16\n6 9 19\n7 8 20\n8 11 23\n9 10 24\n10 13 27\n11 12 28\n12 15 31\n13 14 32\n14 17 35\n15 16 36\n16 19 39\n17 18 40\n18 21 43\n19 20 44\n20 23 47\n21 22 48\n22 24 50\n23 24 51\n1.0384593E38",
                "is_visible": false
            }
        ]
    }
]